<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NorthStar</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230b1220'/%3E%3Cpath d='M14 42V22h6v20h-6zm10 0V22h6v8l10-8h8L36 31l13 11h-8l-11-9v9h-6z' fill='%236aa9ff'/%3E%3C/svg%3E" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
    <style>
      @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap');

      :root {
        color-scheme: dark;
        --bg: #0b0d12;
        --panel: #14171d;
        --panel-2: #1a1f26;
        --panel-3: #0f131a;
        --text: #e6e9ef;
        --muted: #9aa4b2;
        --accent: #6aa9ff;
        --accent-2: #22c55e;
        --border: #242a33;
        --tab: #151a22;
        --danger: #ef4444;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: 'IBM Plex Sans', sans-serif;
        background: radial-gradient(circle at top, #111620 0%, #0b0d12 40%, #0a0c10 100%);
        color: var(--text);
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        background: #0c0f14;
        border-bottom: 1px solid var(--border);
      }
      .window-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        min-width: 80px;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: #ef4444;
      }
      .dot.yellow { background: #f59e0b; }
      .dot.green { background: #22c55e; }
      .topbar-title {
        font-weight: 600;
        color: #d7dce5;
        letter-spacing: 0.4px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .topbar-credit {
        font-size: 11px;
        color: #8fb4ff;
        border: 1px solid rgba(143, 180, 255, 0.35);
        border-radius: 999px;
        padding: 4px 8px;
        background: rgba(40, 71, 130, 0.2);
      }
      .badge {
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(12, 15, 20, 0.35);
        color: var(--muted);
      }
      .topbar-actions {
        display: flex;
        gap: 8px;
      }
      .icon-btn {
        background: #0f141d;
        border: 1px solid var(--border);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
      }
      .icon-btn svg { width: 16px; height: 16px; }
      .icon-btn.primary {
        background: var(--accent);
        color: #0b0f14;
        border: none;
        font-weight: 700;
      }
      .icon-btn.primary svg { stroke: #0b0f14; }
      .icon-btn.toggled {
        border-color: rgba(106,169,255,0.55);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.14) inset;
      }
      .icon-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .icon-btn[data-tip]:hover::after {
        content: attr(data-tip);
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: rgba(12, 15, 20, 0.92);
        border: 1px solid rgba(255,255,255,0.14);
        color: var(--text);
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        z-index: 50;
        box-shadow: 0 14px 36px rgba(0,0,0,0.35);
      }
      .icon-btn[data-tip]:hover::before {
        content: "";
        position: absolute;
        top: calc(100% + 2px);
        right: 12px;
        border: 6px solid transparent;
        border-bottom-color: rgba(255,255,255,0.14);
        z-index: 51;
        pointer-events: none;
      }
      .icon-btn[data-tip]:focus-visible::after,
      .icon-btn[data-tip]:focus-visible::before {
        opacity: 1;
      }

      .layout {
        display: grid;
        grid-template-columns: 280px 6px 1fr 6px 360px;
        grid-template-rows: 1fr;
        height: calc(100vh - 48px);
        gap: 0;
      }

      /* Pin items to specific columns so toggling widths never reflows to a new row. */
      #leftPanel { grid-column: 1; grid-row: 1; }
      #splitterLeft { grid-column: 2; grid-row: 1; }
      main.workspace { grid-column: 3; grid-row: 1; }
      #splitterRight { grid-column: 4; grid-row: 1; }
      #rightPanel { grid-column: 5; grid-row: 1; }

      .splitter {
        background: #0f141d;
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        cursor: col-resize;
      }
      .splitter.hidden { display: none; }

      .panel {
        background: var(--panel);
        border-right: 1px solid var(--border);
        border-left: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      .panel-header {
        padding: 10px 12px;
        font-weight: 600;
        border-bottom: 1px solid var(--border);
        background: var(--panel-2);
      }
      .panel-body {
        padding: 10px 12px;
        overflow: auto;
      }
      #leftPanel .panel-body {
        display: flex;
        flex-direction: column;
      }
      #historyPanel { margin-top: auto; }

      .tabs {
        display: flex;
        gap: 6px;
        padding: 8px;
        background: var(--panel-2);
        border-bottom: 1px solid var(--border);
      }
      .tab {
        padding: 6px 12px;
        border-radius: 8px;
        background: var(--tab);
        border: 1px solid var(--border);
        font-size: 12px;
        cursor: pointer;
        color: var(--muted);
      }
      .tab.active {
        background: #1c2430;
        border-color: var(--accent);
        color: var(--accent);
      }

      .tab-panels {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .tab-panel {
        display: none;
        padding: 12px;
        flex: 1;
        min-height: 0;
        /* Keep the middle pane "IDE fixed". Specific panels implement their own internal scrolling. */
        overflow: hidden;
      }
      .tab-panel.active { display: block; }
      /* Keep the middle pane fixed; allow only internal cards to scroll. */
      .tab-panel[data-tab="canvas"] { overflow: hidden; }
      .tab-panel[data-tab="code"].active,
      .tab-panel[data-tab="settings"].active {
        display: flex;
        flex-direction: column;
      }

      .tree {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        display: grid;
        gap: 6px;
      }
      .tree summary { cursor: pointer; color: #93c5fd; list-style: none; }
      .tree summary::-webkit-details-marker { display: none; }
      .tree details { padding-left: 0; }
      .tree details > .tree-children {
        margin-left: 14px;
        padding-left: 10px;
        border-left: 1px solid rgba(255,255,255,0.08);
        display: grid;
        gap: 4px;
      }
      .tree .tree-file {
        color: #cbd5f5;
        padding-left: 0;
        cursor: grab;
      }
      .tree .tree-file:hover { color: var(--accent); }
      .compact-scroll {
        max-height: 320px;
        overflow: auto;
        padding-right: 2px;
      }
      .tree-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        align-items: center;
        gap: 8px;
        padding-left: 12px;
        border-radius: 8px;
        padding-top: 3px;
        padding-bottom: 3px;
      }
      .tree-row.selected {
        background: rgba(106,169,255,0.14);
        border: 1px solid rgba(106,169,255,0.35);
      }
      .tree-row.drop-target {
        border: 1px dashed rgba(106,169,255,0.6);
        background: rgba(59, 130, 246, 0.12);
      }
      .tree-row-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .tree-row-name input {
        width: 100%;
        padding: 4px 6px;
        border-radius: 8px;
        font-size: 12px;
        line-height: 1.25;
      }
      .tree-row-actions {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .tree-act {
        width: 24px;
        height: 24px;
        min-width: 24px;
        padding: 0;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--muted);
        font-size: 11px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .tree-act svg {
        width: 12px;
        height: 12px;
        display: block;
      }
      .tree-act:hover {
        color: var(--text);
        border-color: rgba(106,169,255,0.55);
      }
      .tree-act.danger:hover {
        border-color: rgba(239,68,68,0.55);
        color: #fca5a5;
      }
      .tree-act.confirm {
        border-color: rgba(34,197,94,0.55);
        color: #86efac;
      }
      .tree-act.confirm:hover {
        border-color: rgba(34,197,94,0.85);
        color: #dcfce7;
      }
      .tree-act.reject {
        border-color: rgba(239,68,68,0.55);
        color: #fca5a5;
      }
      .tree-act.reject:hover {
        border-color: rgba(239,68,68,0.85);
        color: #ffe4e6;
      }

      .section-title {
        margin-top: 12px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
        display: block;
        margin-bottom: 6px;
      }
      input, select, textarea, button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: var(--panel-3);
        color: var(--text);
        font-family: inherit;
      }
      textarea { min-height: 90px; }
      button {
        background: var(--accent);
        color: #0b1220;
        font-weight: 700;
        border: none;
        cursor: pointer;
      }
      button.secondary { background: #1f2937; color: var(--text); }
      button.ghost { background: transparent; border: 1px solid var(--border); color: var(--text); }

      .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .row.small { grid-template-columns: 1fr auto auto auto; align-items: center; }
      .muted { color: var(--muted); font-size: 12px; }
      code { font-family: 'IBM Plex Mono', monospace; font-size: 12px; }

      .workspace { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }

      .canvas-grid {
        display: grid;
        grid-template-columns: 1fr;
        /* Top/bottom canvas sections are draggable via splitter. */
        --canvas-top: 72%;
        --canvas-timeline: 16%;
        --canvas-controls: calc(100% - var(--canvas-top) - var(--canvas-timeline) - 8px);
        grid-template-rows: minmax(180px, var(--canvas-top)) 8px minmax(110px, var(--canvas-timeline)) minmax(120px, var(--canvas-controls));
        gap: 12px;
        height: 100%;
        min-height: 0;
      }
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 12px;
        min-height: 0;
      }
      .card.scroll { overflow: auto; }
      .timeline-card { grid-column: 1 / -1; }
      .timeline-card {
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .preview-card { display: flex; flex-direction: column; min-height: 0; }
      .controls-card { grid-column: 1 / -1; grid-row: 4; overflow: auto; }
      .preview-card { grid-column: 1 / -1; grid-row: 1; }
      .timeline-card { grid-column: 1 / -1; grid-row: 3; }
      .canvas-splitter {
        grid-column: 1 / -1;
        grid-row: 2;
        height: 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(106,169,255,0.18), rgba(106,169,255,0.08));
        cursor: row-resize;
        position: relative;
        z-index: 6;
        pointer-events: auto;
      }

      .preview-area {
        height: 100%;
        min-height: 240px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(11, 13, 18, 0.4);
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.06);
        padding: 10px;
        overflow: hidden;
      }
      .preview-shell {
        height: 100%;
        aspect-ratio: var(--preview-aspect, 9 / 16);
        width: auto;
        max-width: 100%;
        max-height: 100%;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .preview-shell video { width: 100%; height: 100%; object-fit: contain; }

      .preview-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 8px;
        pointer-events: none;
      }
      .preview-overlay-left {
        position: absolute;
        top: 10px;
        left: 10px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        z-index: 12;
      }
      .preview-aspect-quick {
        pointer-events: auto;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 5px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(12, 15, 20, 0.76);
        color: var(--muted);
        font-size: 11px;
      }
      .preview-aspect-quick select {
        margin: 0;
        width: auto;
        min-width: 76px;
        padding: 4px 8px;
        border-radius: 8px;
      }
      .overlay-btn {
        pointer-events: auto;
        width: auto;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(12, 15, 20, 0.72);
        backdrop-filter: blur(10px);
        color: var(--text);
        display: inline-flex;
        align-items: center;
        gap: 0;
      }
      .overlay-btn svg { width: 16px; height: 16px; }
      .overlay-btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      .voiceover-panel {
        position: absolute;
        top: 50px;
        right: 10px;
        width: min(340px, calc(100% - 20px));
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(9, 12, 18, 0.92);
        backdrop-filter: blur(12px);
        padding: 10px;
        display: grid;
        gap: 8px;
        z-index: 9;
      }
      .voiceover-panel.hidden { display: none; }
      .voiceover-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .voiceover-title {
        font-weight: 700;
        font-size: 12px;
        letter-spacing: 0.3px;
      }
      .voiceover-panel textarea {
        min-height: 72px;
      }

      .preview-wrap {
        position: relative;
        flex: 1;
        min-height: 0;
      }
      .preview-transport {
        margin-top: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        border-radius: 12px;
        background: rgba(11, 13, 18, 0.58);
        padding: 8px 10px;
      }
      .preview-transport #timelineScrub {
        margin-top: 0;
      }
      .preview-transport .timeline-controls {
        margin-top: 8px;
      }
      .split-controls {
        margin-top: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .split-controls .ghost,
      .split-controls .secondary {
        width: auto;
        padding: 6px 10px;
        border-radius: 8px;
      }
      #cutRangeLabel {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 11px;
      }
      .preview-empty {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        color: rgba(255,255,255,0.55);
        font-weight: 700;
        letter-spacing: 0.2px;
        text-align: center;
        padding: 20px;
      }
      .preview-empty.hidden { display: none !important; }

      .health-badges { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
      .badge-pill {
        width: auto;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.55);
        font-size: 12px;
        font-weight: 800;
      }
      .badge-pill.ok { border-color: rgba(34,197,94,0.35); color: rgba(134,239,172,0.95); }
      .badge-pill.bad { border-color: rgba(248,113,113,0.35); color: rgba(253,164,175,0.95); }

      .asset-tray {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .asset-slot {
        border: 1px dashed rgba(255,255,255,0.18);
        background: rgba(15, 19, 26, 0.65);
        border-radius: 12px;
        padding: 8px;
        min-height: 96px;
        display: grid;
        gap: 6px;
        align-content: start;
      }
      .asset-title { font-size: 11px; color: var(--muted); }
      .asset-meta { font-size: 11px; color: var(--muted); }
      .asset-meta.selected {
        color: #bfe4ff;
        font-weight: 700;
      }
      .asset-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .asset-actions button {
        width: auto;
        padding: 6px 8px;
        font-size: 11px;
      }
      .scene-target-input {
        width: 74px;
        padding: 6px 7px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(15, 20, 29, 0.9);
        color: var(--text);
        font-size: 11px;
        font-family: 'IBM Plex Mono', monospace;
      }
      .asset-thumb {
        height: 64px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f14;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 11px;
      }
      .asset-thumb img { width: 100%; height: 100%; object-fit: cover; }
      .asset-thumb.draggable { cursor: grab; }
      .asset-grid {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
        padding: 6px;
      }
      .asset-item {
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.08);
        background: #0f172a;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
      }
      .asset-item img { width: 100%; height: 100%; object-fit: cover; }
      .asset-item.selected {
        outline: 2px solid rgba(106,169,255,0.8);
        box-shadow: 0 0 0 1px rgba(106,169,255,0.4);
      }
      .asset-item-label {
        position: absolute;
        bottom: 4px;
        right: 6px;
        font-size: 9px;
        color: #e2e8f0;
        background: rgba(15,23,42,0.8);
        padding: 2px 4px;
        border-radius: 6px;
      }
      .prompt-chip-row {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .prompt-chip {
        width: auto;
        padding: 5px 9px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(11, 13, 18, 0.7);
        color: #cfd6e5;
        font-size: 11px;
        cursor: pointer;
      }
      .prompt-chip:hover {
        border-color: rgba(106,169,255,0.55);
        color: #dbeafe;
      }
      .slider-label-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .slider-readout {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 11px;
        color: #c7d2e3;
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 999px;
        padding: 2px 7px;
        background: rgba(15, 20, 29, 0.65);
      }

      .timeline-wrap {
        margin-top: 12px;
        min-height: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .timeline-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .timeline-hide-btn {
        width: auto;
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 11px;
      }
      .timeline-ruler {
        position: relative;
        height: 26px;
        background: #0b1220;
        border-radius: 8px;
        border: 1px solid var(--border);
        overflow: hidden;
      }
      .timeline-ruler .tick {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 1px;
        background: rgba(255,255,255,0.10);
      }
      .timeline-ruler .tick.major {
        background: rgba(106,169,255,0.45);
      }
      .timeline-ruler .tick-label {
        position: absolute;
        top: 6px;
        transform: translateX(-50%);
        font-size: 10px;
        color: var(--muted);
        white-space: nowrap;
      }
      .timeline-marker {
        position: absolute;
        top: 0;
        bottom: 0;
        transform: translateX(-50%);
        pointer-events: none;
      }
      .timeline-marker-dot {
        position: absolute;
        top: 2px;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: #6aa9ff;
        box-shadow: 0 0 10px rgba(106,169,255,0.55);
      }
      .timeline-marker-label {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #cfe3ff;
        font-family: 'IBM Plex Mono', monospace;
      }
      .timeline-track {
        display: flex;
        gap: 6px;
        align-items: stretch;
        margin-top: 8px;
        overflow-x: auto;
        overflow-y: hidden;
        padding-bottom: 6px;
        min-height: 120px;
        flex: 1 1 auto;
      }
      .timeline-block {
        flex: 0 0 180px;
        min-width: 160px;
        background: #0b1220;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 7px 8px;
        display: grid;
        gap: 6px;
        position: relative;
      }
      .timeline-block.has-bg {
        border-color: rgba(34, 197, 94, 0.6);
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.12) inset;
      }
      .timeline-block.has-fg {
        border-color: rgba(59, 130, 246, 0.65);
        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.16) inset;
      }
      .timeline-block.has-bg.has-fg {
        border-color: rgba(250, 204, 21, 0.65);
        box-shadow: 0 0 0 1px rgba(250, 204, 21, 0.16) inset;
      }
      .timeline-edit-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
        align-items: center;
      }
      .timeline-edit-input {
        width: 100%;
        padding: 5px 7px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--text);
        font-size: 13px;
        font-weight: 600;
        min-height: 28px;
      }
      .timeline-goal-input {
        font-size: 15px;
        line-height: 1.25;
        font-weight: 700;
      }
      .timeline-edit-note {
        width: 100%;
        min-height: 38px;
        max-height: 84px;
        resize: vertical;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--muted);
        font-size: 11px;
        line-height: 1.25;
        padding: 6px 7px;
      }
      .timeline-edit-note::placeholder,
      .timeline-edit-input::placeholder {
        color: rgba(154,164,178,0.75);
      }
      .timeline-dur-input {
        width: 58px;
        padding: 4px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--text);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 11px;
        text-align: right;
      }
      .timeline-block.dragging { opacity: 0.55; }
      .timeline-block.active {
        border-color: rgba(106,169,255,0.7);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.16) inset;
      }
      .timeline-details {
        border-top: 1px dashed rgba(255,255,255,0.1);
        padding-top: 4px;
      }
      .timeline-details summary {
        cursor: pointer;
        font-size: 11px;
        color: var(--muted);
      }
      .timeline-handle {
        position: absolute;
        right: 3px;
        top: 3px;
        bottom: 3px;
        width: 8px;
        border-radius: 8px;
        background: rgba(106,169,255,0.20);
        cursor: ew-resize;
        opacity: 0.65;
      }
      .timeline-block:hover .timeline-handle { opacity: 1; }
      .timeline-block-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        font-size: 11px;
        color: var(--muted);
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .timeline-scene-delete {
        width: 22px;
        height: 22px;
        border-radius: 8px;
        border: 1px solid rgba(239, 68, 68, 0.35);
        background: rgba(127, 29, 29, 0.28);
        color: #fecaca;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        cursor: pointer;
        padding: 0;
        flex-shrink: 0;
      }
      .timeline-scene-delete:hover {
        border-color: rgba(248, 113, 113, 0.65);
        background: rgba(127, 29, 29, 0.44);
      }
      .timeline-block-meta {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        flex-shrink: 0;
      }
      .timeline-asset-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255,255,255,0.3);
        border: 1px solid rgba(0,0,0,0.4);
        box-shadow: 0 0 8px rgba(255,255,255,0.12);
      }
      .timeline-asset-dot.bg { background: #22c55e; }
      .timeline-asset-dot.fg { background: #60a5fa; }
      .timeline-block-title {
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .timeline-badges {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }
      .timeline-badge {
        width: auto;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        font-size: 10px;
        color: var(--muted);
        background: rgba(11,13,18,0.55);
      }
      .timeline-asset-badge {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 2px 7px 2px 3px;
      }
      .timeline-asset-badge img {
        width: 14px;
        height: 14px;
        border-radius: 4px;
        object-fit: cover;
        border: 1px solid rgba(255,255,255,0.16);
        box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset;
      }
      .timeline-asset-badge .asset-label {
        font-size: 10px;
        color: var(--text);
        letter-spacing: 0.2px;
      }

      .timeline-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        flex-wrap: wrap;
        padding-bottom: 2px;
        width: 100%;
      }
      .timeline-controls .ctl {
        width: auto;
        min-width: 42px;
        padding: 8px 9px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0f141d;
        color: var(--text);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }
      .timeline-controls .ctl svg { width: 16px; height: 16px; }
      .timeline-controls .ctl-label { display: none; }
      #timeReadout {
        font-family: 'IBM Plex Mono', monospace;
        margin-left: 8px;
      }
      .install-prompt {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel);
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .install-prompt.hidden { display: none; }
      .timeline-hint {
        margin-top: 6px;
        font-size: 11px;
        color: var(--muted);
      }
      .canvas-grid.timeline-hidden {
        grid-template-rows: minmax(220px, var(--canvas-top)) 0 minmax(0, 0) minmax(180px, 1fr);
      }
      .canvas-grid.timeline-hidden .canvas-splitter,
      .canvas-grid.timeline-hidden .timeline-card {
        display: none;
      }
      .deck-btn {
        width: auto;
        min-width: 34px;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(12, 16, 22, 0.78);
        color: var(--text);
        font-weight: 700;
      }
      .deck-inline {
        margin-top: 8px;
        display: grid;
        grid-template-columns: auto minmax(0, 1fr) auto;
        gap: 6px;
        align-items: center;
      }
      .deck-inline.hidden {
        display: none !important;
      }
      .deck-inline-track {
        min-width: 0;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 4px 2px;
        scrollbar-width: thin;
      }
      .deck-card {
        flex: 0 0 150px;
        width: 150px;
        height: 56px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.16);
        background: linear-gradient(180deg, rgba(16, 24, 35, 0.95), rgba(8, 12, 18, 0.95));
        transition: transform 160ms ease, opacity 160ms ease, box-shadow 160ms ease;
        overflow: hidden;
        cursor: pointer;
      }
      .deck-card.active {
        border-color: rgba(106,169,255,0.75);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.22) inset, 0 6px 18px rgba(0,0,0,0.45);
      }
      .deck-card-line1 {
        font-size: 11px;
        color: #dbeafe;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 8px 10px 2px;
      }
      .deck-card-line2 {
        font-size: 10px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 0 10px;
      }

      .preview-busy {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(circle at center, rgba(15,20,29,0.55), rgba(11,13,18,0.85));
        border-radius: 16px;
        z-index: 8;
        pointer-events: none;
      }
      .busy-title {
        font-size: 18px;
        font-weight: 800;
        letter-spacing: 0.4px;
        background: linear-gradient(90deg, #93c5fd, #22c55e, #93c5fd);
        background-size: 220% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: shimmer 1.8s ease-in-out infinite;
      }
      .busy-sub { color: var(--muted); font-size: 12px; margin-top: 4px; max-width: 260px; text-align: center; }
      .busy-thought {
        color: #93c5fd;
        font-size: 11px;
        margin-top: 2px;
        opacity: 0.9;
        text-align: center;
        animation: thoughtPulse 1.25s ease-in-out infinite;
      }
      @keyframes shimmer {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      @keyframes thoughtPulse {
        0% { opacity: 0.5; }
        50% { opacity: 1; }
        100% { opacity: 0.5; }
      }
      .spinner {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 3px solid rgba(255,255,255,0.18);
        border-top-color: rgba(106,169,255,0.9);
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

      .terminal {
        border-top: 1px solid var(--border);
        background: #0b1119;
        padding: 10px;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
      }
      .terminal.hidden { display: none; }
      .terminal pre { white-space: pre-wrap; margin: 0; color: #86efac; }

      .chat {
        display: flex;
        flex-direction: column;
        height: 100%;
        gap: 10px;
      }
      .chat-carousel {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 8px;
        align-items: center;
      }
      .chat-carousel-btn {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.7);
        color: #e2e8f0;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .chat-carousel-btn:hover { border-color: rgba(59, 130, 246, 0.6); }
      .chat-sessions {
        display: flex;
        gap: 10px;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        padding: 6px 2px;
      }
      .chat-session-card {
        min-width: 180px;
        scroll-snap-align: center;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.2);
        color: #e2e8f0;
        padding: 8px 10px;
        border-radius: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: grid;
        gap: 6px;
      }
      .chat-session-card.active {
        border-color: rgba(59, 130, 246, 0.7);
        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.4);
      }
      .chat-session-card-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .chat-session-head-right {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .chat-session-name {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        min-width: 0;
      }
      .chat-session-name-label {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 120px;
      }
      .chat-session-name-input {
        width: 124px;
        border-radius: 8px;
        border: 1px solid rgba(106, 169, 255, 0.55);
        background: rgba(8, 12, 20, 0.88);
        color: var(--text);
        font-size: 11px;
        padding: 4px 7px;
        outline: none;
      }
      .chat-session-swatch {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        display: inline-block;
      }
      .chat-session-phase {
        font-size: 11px;
        color: #93c5fd;
        background: rgba(59, 130, 246, 0.12);
        border-radius: 999px;
        padding: 2px 6px;
      }
      .chat-session-lock {
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 20, 29, 0.75);
        color: var(--muted);
        border-radius: 8px;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }
      .chat-session-lock.on {
        border-color: rgba(34, 197, 94, 0.5);
        color: #bbf7d0;
        background: rgba(22, 101, 52, 0.35);
      }
      .chat-session-edit {
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 20, 29, 0.75);
        color: var(--muted);
        border-radius: 8px;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }
      .chat-session-edit:hover {
        border-color: rgba(106, 169, 255, 0.6);
        color: var(--text);
      }
      .chat-session-close {
        border: 1px solid rgba(244, 63, 94, 0.28);
        background: rgba(36, 10, 18, 0.55);
        color: #fda4af;
        border-radius: 8px;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        cursor: pointer;
      }
      .chat-session-close:hover {
        border-color: rgba(244, 63, 94, 0.55);
        background: rgba(64, 16, 30, 0.66);
      }
      .chat-session-close.confirm,
      .chat-session-close.cancel {
        border-color: rgba(148, 163, 184, 0.35);
        background: rgba(15, 20, 29, 0.72);
        color: var(--muted);
      }
      .chat-session-close.confirm {
        border-color: rgba(34, 197, 94, 0.55);
        color: #86efac;
      }
      .chat-session-close.cancel {
        border-color: rgba(244, 63, 94, 0.45);
        color: #fda4af;
      }
      .chat-session-add {
        width: auto;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px dashed rgba(255,255,255,0.26);
        background: rgba(11, 13, 18, 0.42);
        color: var(--muted);
        font-size: 12px;
        scroll-snap-align: center;
      }
      .chat-messages {
        flex: 1;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 4px;
      }
      .chat-compose {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .compose-mode-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 6px;
        flex-wrap: nowrap;
        overflow-x: auto;
      }
      .crazy-countdown {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid rgba(106, 169, 255, 0.36);
        border-radius: 999px;
        background: rgba(11, 13, 18, 0.75);
        white-space: nowrap;
        animation: pulseGlow 1.1s ease-in-out infinite;
      }
      .crazy-countdown-text {
        font-size: 11px;
        color: #dbeafe;
        font-weight: 700;
      }
      @keyframes pulseGlow {
        0% { box-shadow: 0 0 0 rgba(106,169,255,0); }
        50% { box-shadow: 0 0 16px rgba(106,169,255,0.28); }
        100% { box-shadow: 0 0 0 rgba(106,169,255,0); }
      }
      .mode-chip {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        padding: 6px 9px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 999px;
        background: rgba(15, 20, 29, 0.7);
        color: var(--muted);
        cursor: pointer;
        font-size: 11px;
        line-height: 1;
        user-select: none;
      }
      .mode-chip input {
        position: absolute;
        width: 0;
        height: 0;
        opacity: 0;
        pointer-events: none;
      }
      .mode-chip .mode-icon {
        width: 15px;
        height: 15px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #93c5fd;
        opacity: 0.95;
      }
      .mode-chip .mode-label {
        font-weight: 700;
        color: #dbeafe;
        white-space: nowrap;
        font-size: 11px;
      }
      .mode-chip.checked {
        border-color: rgba(106, 169, 255, 0.58);
        background: linear-gradient(180deg, rgba(59,130,246,0.18), rgba(15,20,29,0.78));
      }
      .mode-chip.checked .mode-icon {
        color: #dbeafe;
      }
      .compose-polish {
        width: 36px;
        height: 32px;
        padding: 0;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .compose-polish svg {
        width: 16px;
        height: 16px;
      }
      .first60-panel {
        margin-top: 8px;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        background: rgba(11, 13, 18, 0.52);
        padding: 8px;
      }
      .first60-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .first60-title {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .first60-sub {
        font-size: 11px;
        color: var(--muted);
      }
      .first60-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .first60-mini {
        width: auto;
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 11px;
      }
      .first60-progress {
        margin-top: 7px;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(255,255,255,0.08);
        overflow: hidden;
      }
      .first60-progress-fill {
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(90deg, #6aa9ff, #22c55e);
        transition: width 180ms ease;
      }
      .first60-list {
        margin-top: 8px;
        display: grid;
        gap: 6px;
      }
      .first60-item {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
      }
      .first60-dot {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.24);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: var(--muted);
        background: rgba(15, 20, 29, 0.8);
      }
      .first60-state {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 10px;
        color: var(--muted);
      }
      .first60-item.done { color: #d1fae5; }
      .first60-item.done .first60-dot {
        border-color: rgba(34,197,94,0.7);
        color: #22c55e;
        background: rgba(34,197,94,0.16);
      }
      .first60-item.active { color: #dbeafe; }
      .first60-item.active .first60-dot {
        border-color: rgba(106,169,255,0.8);
        color: #6aa9ff;
        background: rgba(59,130,246,0.16);
      }
      .first60-show {
        margin-top: 6px;
        width: auto;
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 11px;
      }
      .mention-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .mention-bar.collapsed { display: none; }
      .mention-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .mention-toggle {
        width: auto;
        padding: 4px 8px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: rgba(12, 16, 22, 0.72);
        color: var(--muted);
        font-size: 11px;
      }
      .mention-chip {
        width: auto;
        max-width: 220px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(11, 13, 18, 0.65);
        color: var(--muted);
        font-size: 11px;
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .mention-icon {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 800;
        margin-right: 6px;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(106,169,255,0.18);
        color: #cfe3ff;
        flex: 0 0 auto;
      }
      .mention-chip.agent .mention-icon {
        background: rgba(34,197,94,0.18);
        color: #c7f9d7;
      }
      .mention-text {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .mention-chip:hover {
        border-color: rgba(106,169,255,0.5);
        color: var(--text);
      }
      .compose-btn, .compose-send {
        width: auto;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #0f141d;
        color: var(--text);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .compose-btn svg, .compose-send svg { width: 18px; height: 18px; }
      .compose-send {
        background: var(--accent);
        color: #0b0f14;
        border: none;
      }
      .compose-send svg { stroke: #0b0f14; }
      .compose-model {
        width: auto;
        flex: 0 0 auto;
        min-width: 0;
        max-width: 220px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.65);
        font-weight: 700;
        letter-spacing: 0.2px;
        color: var(--text);
      }
      .bubble {
        max-width: 92%;
        border-radius: 16px;
        padding: 10px 12px;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(11, 18, 32, 0.55);
        backdrop-filter: blur(8px);
      }
      .bubble.user {
        align-self: flex-end;
        border-color: rgba(106,169,255,0.14);
        background: linear-gradient(180deg, rgba(106,169,255,0.16), rgba(11,18,32,0.35));
      }
      .bubble.agent {
        align-self: flex-start;
        border-color: rgba(34,197,94,0.12);
        background: linear-gradient(180deg, rgba(34,197,94,0.10), rgba(11,18,32,0.35));
      }
      .bubble-title { font-weight: 600; font-size: 12px; color: var(--muted); }
      .bubble pre {
        margin: 8px 0 0 0;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.72);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        word-break: break-word;
        max-height: 260px;
        overflow: auto;
      }
      .bubble code {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
      }
      .bubble a { color: #93c5fd; }

      /* Code editor (editable) with line numbers. */
      .code-editor {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 0;
        border-radius: 12px;
        border: 1px solid var(--border);
        overflow: hidden;
        background: rgba(11, 13, 18, 0.6);
      }
      .code-gutter {
        padding: 12px 8px;
        border-right: 1px solid rgba(255,255,255,0.08);
        color: rgba(255,255,255,0.38);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
        text-align: right;
        user-select: none;
        background: rgba(11, 13, 18, 0.75);
      }
      .code-editor textarea {
        border: none;
        outline: none;
        border-radius: 0;
        min-height: 520px;
        padding: 12px;
        resize: none;
        background: transparent;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
        white-space: pre;
        overflow: auto;
        tab-size: 4;
      }

      /* Highlighted code view with line numbers. */
      pre.hljs {
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 0;
        overflow: auto;
        max-height: 640px;
        background: linear-gradient(180deg, rgba(6, 10, 16, 0.95), rgba(8, 12, 18, 0.92));
      }
      pre.hljs code { color: #dbeafe; }
      .hljs-keyword,
      .hljs-selector-tag,
      .hljs-meta .hljs-keyword { color: #ff7ab2; }
      .hljs-title,
      .hljs-title.function_,
      .hljs-title.class_ { color: #7dd3fc; }
      .hljs-built_in,
      .hljs-type { color: #86efac; }
      .hljs-string,
      .hljs-regexp { color: #fcd34d; }
      .hljs-number,
      .hljs-literal { color: #fca5a5; }
      .hljs-comment,
      .hljs-quote { color: #94a3b8; }
      .hljs-params,
      .hljs-variable { color: #c4b5fd; }
      .code-lines {
        counter-reset: line;
        padding: 12px 0;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
      }
      .code-line {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 0;
        padding: 0 12px 0 0;
      }
      .code-line::before {
        counter-increment: line;
        content: counter(line);
        padding: 0 10px 0 0;
        text-align: right;
        color: rgba(255,255,255,0.38);
        user-select: none;
      }
      .code-line > span {
        display: block;
        padding-left: 12px;
        border-left: 1px solid rgba(255,255,255,0.08);
        white-space: pre;
      }
      .code-line.highlight {
        background: rgba(106,169,255,0.08);
      }

      .agent-steps { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
      .agent-progress {
        margin-top: 6px;
        height: 5px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.6);
        overflow: hidden;
      }
      .agent-progress-fill {
        height: 100%;
        width: 0%;
        transition: width 220ms ease;
        background: linear-gradient(90deg, #6aa9ff, #22c55e);
      }
      .agent-step {
        background: #0b1220;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px;
        font-size: 11px;
        text-align: center;
        cursor: pointer;
      }
      .agent-step.active { border-color: var(--accent); color: var(--accent); }
      .agent-step.done { border-color: var(--accent-2); color: var(--accent-2); }
      .agent-step.error { border-color: var(--danger); color: var(--danger); }
      .agent-step.selected {
        box-shadow: 0 0 0 2px rgba(106,169,255,0.25) inset;
      }

      @keyframes glowPulse {
        0% { box-shadow: 0 0 0 rgba(106,169,255,0.0); transform: translateY(0); }
        50% { box-shadow: 0 0 22px rgba(106,169,255,0.30); transform: translateY(-1px); }
        100% { box-shadow: 0 0 0 rgba(106,169,255,0.0); transform: translateY(0); }
      }
      @keyframes glowPulseOk {
        0% { box-shadow: 0 0 0 rgba(34,197,94,0.0); }
        50% { box-shadow: 0 0 22px rgba(34,197,94,0.25); }
        100% { box-shadow: 0 0 0 rgba(34,197,94,0.0); }
      }
      .agent-step.active { animation: glowPulse 1.2s ease-in-out infinite; }
      .agent-step.done { animation: glowPulseOk 0.8s ease-in-out 1; }
      .step-detail {
        margin-top: 8px;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        background: rgba(11, 13, 18, 0.55);
        color: var(--muted);
        font-size: 12px;
        padding: 8px 10px;
        min-height: 34px;
        white-space: pre-wrap;
      }

      .context-block {
        margin: 4px 0 6px;
      }
      .context-block summary {
        cursor: pointer;
        color: var(--muted);
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
      }
      .context-tabs {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      .ctx-tab {
        width: auto;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(15, 19, 26, 0.55);
        color: var(--muted);
        font-weight: 700;
        font-size: 12px;
      }
      .ctx-tab.active {
        color: var(--text);
        border-color: rgba(106,169,255,0.55);
        background: rgba(106,169,255,0.12);
      }
      .context-panel-shell {
        margin-top: 8px;
        height: var(--context-panel-height, 168px);
        min-height: var(--context-panel-height, 168px);
        max-height: var(--context-panel-height, 168px);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        background: rgba(11, 13, 18, 0.42);
        overflow: hidden;
        position: relative;
      }
      .context-panel {
        display: none;
        height: 100%;
        overflow: auto;
        padding: 6px 9px 7px;
      }
      .context-panel textarea {
        min-height: 42px;
      }
      #sourceNotes {
        min-height: 46px;
      }
      .context-panel.active { display: block; }
      .context-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
      .context-memory-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }
      .context-memory-grid .field {
        display: grid;
        gap: 6px;
      }
      .context-doc-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }
      .source-status {
        margin-top: 8px;
        min-height: 20px;
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: normal;
        line-height: 1.35;
      }
      .source-status::before {
        content: '';
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid rgba(148, 163, 184, 0.35);
        border-top-color: transparent;
        opacity: 0;
        transform: scale(0.85);
      }
      .source-status.loading::before {
        opacity: 1;
        animation: spin 1s linear infinite;
      }
      .source-status.ok { color: #93c5fd; }
      .source-status.warn { color: #facc15; }
      .source-status.err { color: #fca5a5; }
      .index-skeleton {
        position: relative;
        overflow: hidden;
      }
      .index-skeleton::after {
        content: '';
        position: absolute;
        inset: 0;
        transform: translateX(-100%);
        background: linear-gradient(90deg, transparent, rgba(106,169,255,0.2), transparent);
        animation: shimmer 1s ease-in-out infinite;
      }
      @keyframes shimmer {
        100% { transform: translateX(100%); }
      }
      .memory-entry {
        margin-top: 8px;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        background: rgba(11, 13, 18, 0.55);
        padding: 8px;
      }
      .memory-entry-title {
        font-weight: 700;
        font-size: 12px;
        color: var(--text);
      }
      .memory-entry-body {
        margin-top: 4px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }
      .memory-empty {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
      }
      #memoryList {
        margin-top: 6px;
        max-height: 74px;
        overflow: auto;
      }
      .memory-row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 8px;
        align-items: start;
      }
      .memory-row > input[type="checkbox"] {
        margin-top: 2px;
      }
      .memory-row .ghost {
        width: auto;
        padding: 4px 8px;
        height: 24px;
      }
      #indexSource.indexing {
        position: relative;
        padding-right: 34px;
      }
      #indexSource.indexing::after {
        content: '';
        position: absolute;
        right: 10px;
        top: 50%;
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid rgba(148,163,184,0.45);
        border-top-color: #93c5fd;
        transform: translateY(-50%);
        animation: spin 0.8s linear infinite;
      }
      .context-actions-row {
        display: flex;
        align-items: end;
        gap: 8px;
      }
      .context-skill-help {
        font-size: 11px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .skill-rail-shell {
        display: grid;
        grid-template-columns: auto minmax(0, 1fr) auto;
        gap: 6px;
        align-items: center;
      }
      .skill-rail-btn {
        width: 22px;
        height: 46px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.7);
        color: #cbd5e1;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }
      .skill-rail-btn:hover {
        border-color: rgba(106, 169, 255, 0.6);
      }
      .skill-rail {
        display: flex;
        gap: 8px;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 2px 0 4px 0;
        scroll-snap-type: x mandatory;
        scrollbar-width: thin;
      }
      .skill-pill {
        flex: 0 0 calc((100% - 32px) / 5);
        min-width: 52px;
        max-width: 64px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.24);
        background: rgba(11, 13, 18, 0.68);
        color: var(--muted);
        padding: 6px 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        cursor: pointer;
        transition: transform 160ms ease, border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
        scroll-snap-align: center;
        animation: skillIn 220ms ease both;
      }
      @keyframes skillIn {
        from { opacity: 0; transform: translateY(4px) scale(0.98); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      .skill-pill:hover {
        transform: translateY(-1px);
        border-color: rgba(106, 169, 255, 0.5);
      }
      .skill-pill.is-selected {
        color: #dbeafe;
        border-color: rgba(106, 169, 255, 0.72);
        background: linear-gradient(180deg, rgba(59,130,246,0.2), rgba(11,13,18,0.7));
        box-shadow: 0 0 0 1px rgba(106,169,255,0.35) inset, 0 8px 20px rgba(5,10,20,0.45);
      }
      .skill-pill-icon {
        width: 36px;
        height: 36px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.16);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 800;
        background: rgba(106, 169, 255, 0.16);
        color: #cfe3ff;
      }
      .skill-pill.is-selected .skill-pill-icon {
        background: rgba(34, 197, 94, 0.22);
        color: #dcfce7;
        border-color: rgba(34, 197, 94, 0.45);
      }
      .skill-pill-name {
        position: absolute;
        width: 1px;
        height: 1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
      }
      .skill-rail-meta {
        margin-top: 4px;
        font-size: 10px;
        color: var(--muted);
      }
      .context-panel .saved-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
        margin-top: 8px;
      }
      #sourceCards {
        max-height: 56px;
        overflow: auto;
      }
      .context-panel .saved-card {
        padding: 7px 8px;
      }
      .context-panel .saved-card .saved-card-body {
        max-height: 40px;
      }
      .context-panel .saved-card .row.small {
        gap: 6px;
        flex-wrap: wrap;
      }
      .skill-tooltip {
        position: fixed;
        z-index: 1400;
        max-width: 280px;
        border: 1px solid rgba(106, 169, 255, 0.4);
        background: rgba(6, 10, 16, 0.96);
        border-radius: 12px;
        box-shadow: 0 16px 34px rgba(2, 6, 23, 0.65);
        padding: 10px 12px;
        color: var(--text);
        pointer-events: none;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 130ms ease, transform 130ms ease;
      }
      .skill-tooltip.show {
        opacity: 1;
        transform: translateY(0);
      }
      .skill-tooltip-title {
        font-size: 12px;
        font-weight: 700;
        color: #dbeafe;
      }
      .skill-tooltip-handle {
        margin-top: 3px;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 11px;
        color: #93c5fd;
      }
      .skill-tooltip-body {
        margin-top: 6px;
        font-size: 11px;
        color: var(--muted);
        line-height: 1.35;
      }

      .drop-target { outline: 2px dashed var(--accent); }
      .context-drop {
        border-color: rgba(106,169,255,0.55) !important;
        box-shadow: 0 0 0 2px rgba(106,169,255,0.16) inset;
      }

      .hidden { display: none !important; }

      .status-pulse { animation: glowPulse 1.2s ease-in-out infinite; border-radius: 10px; padding: 6px 8px; display: inline-block; }

      button:disabled, input:disabled, select:disabled, textarea:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .toolbar .spacer { flex: 1; }
      .btn-inline { width: auto; padding: 8px 10px; }
      .icon-only {
        width: 36px;
        height: 36px;
        padding: 0;
      }
      .icon-only svg {
        width: 15px;
        height: 15px;
      }

      .editor-tabs-wrap {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }
      .editor-tabs {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        padding-bottom: 2px;
      }
      .editor-tab {
        width: auto;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.1);
        background: rgba(15, 19, 26, 0.55);
        color: var(--muted);
        font-size: 12px;
      }
      .editor-tab.active {
        border-color: rgba(106,169,255,0.55);
        background: rgba(106,169,255,0.12);
        color: var(--text);
      }
      .editor-tab-name {
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
      }
      .editor-tab-close {
        width: 20px;
        height: 20px;
        padding: 0;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(11, 13, 18, 0.6);
        color: var(--muted);
      }
      .editor-tab-close:hover {
        color: #fecaca;
        border-color: rgba(239,68,68,0.6);
      }

      /* Settings live in the middle panel (IDE style). */
      .tab-panel[data-tab="settings"] { padding: 0; }
      .settings-shell {
        flex: 1;
        min-height: 0;
        display: grid;
        grid-template-columns: 180px 1fr;
        gap: 12px;
        padding: 12px;
      }
      .settings-nav {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 8px;
        display: grid;
        gap: 6px;
        align-content: start;
        min-height: 0;
      }
      .settings-nav button {
        width: 100%;
        background: #0f141d;
        border: 1px solid rgba(255,255,255,0.08);
        color: var(--muted);
        text-align: left;
        font-weight: 700;
      }
      .settings-nav button.active {
        border-color: rgba(106,169,255,0.55);
        color: var(--text);
        background: rgba(106,169,255,0.12);
      }
      .settings-content {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 12px;
        overflow: auto;
        min-height: 0;
      }
      .settings-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 12px;
        border-bottom: 1px solid rgba(255,255,255,0.06);
      }
      .settings-title { font-weight: 800; letter-spacing: 0.2px; }
      .settings-section { display: none; }
      .settings-section.active { display: block; }

      /* Code tab: fixed toolbar + scrollable editor body. */
      .tab-panel[data-tab="code"] { padding: 12px; }
      .code-body {
        flex: 1;
        min-height: 0;
        overflow: auto;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        background: rgba(11, 13, 18, 0.45);
        padding: 8px;
      }

      .drawer-section {
        border: 1px solid var(--border);
        background: rgba(15, 19, 26, 0.55);
        border-radius: 12px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .drawer-title {
        font-weight: 700;
        font-size: 12px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 8px;
      }
      .saved-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 8px;
        margin-top: 10px;
      }
      .saved-card {
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 8px;
        background: rgba(11,13,18,0.55);
      }
      .saved-card[data-kind="youtube"] {
        border-color: rgba(239, 68, 68, 0.45);
      }
      .saved-card[data-kind="web"] {
        border-color: rgba(106, 169, 255, 0.4);
      }
      .saved-card-title {
        font-weight: 700;
        font-size: 12px;
        color: var(--text);
      }
      .saved-card-body {
        margin-top: 4px;
        font-size: 12px;
        color: var(--muted);
        max-height: 48px;
        overflow: hidden;
      }

      .toast {
        position: fixed;
        bottom: 14px;
        right: 14px;
        max-width: 420px;
        background: rgba(15, 20, 29, 0.95);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        z-index: 40;
      }
      .toast.ok { border-color: rgba(34, 197, 94, 0.6); }
      .toast.err { border-color: rgba(239, 68, 68, 0.6); }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.55);
        z-index: 50;
        padding: 16px;
      }
      .modal.open { display: flex; }
      .modal-card {
        width: min(720px, 96vw);
        border-radius: 16px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(20,23,29,0.98), rgba(15,19,26,0.98));
        box-shadow: 0 30px 80px rgba(0,0,0,0.6);
        padding: 14px;
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255,255,255,0.06);
        margin-bottom: 10px;
      }
      .modal-title { font-weight: 700; letter-spacing: 0.2px; }
      .modal-body { color: var(--text); font-size: 13px; line-height: 1.45; }
      .modal-body kbd {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(255,255,255,0.12);
        border-bottom-color: rgba(255,255,255,0.18);
        border-radius: 8px;
        background: rgba(11,13,18,0.6);
      }
      .tour-shell {
        display: grid;
        gap: 12px;
      }
      .tour-headline {
        font-size: 12px;
        color: var(--muted);
      }
      .tour-progress-row {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: center;
        gap: 10px;
      }
      .tour-step-count {
        font-size: 12px;
        color: #dbeafe;
        font-family: 'IBM Plex Mono', monospace;
      }
      .tour-progress {
        height: 7px;
        border-radius: 999px;
        overflow: hidden;
        background: rgba(255,255,255,0.1);
      }
      .tour-progress-fill {
        width: 0%;
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(90deg, #6aa9ff, #22c55e);
        transition: width 180ms ease;
      }
      .tour-card {
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 14px;
        background: rgba(12, 16, 22, 0.72);
        padding: 10px;
        display: grid;
        grid-template-columns: 74px 1fr;
        gap: 10px;
        align-items: start;
      }
      .tour-icon-wrap {
        width: 74px;
        height: 74px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(11,13,18,0.76);
        overflow: hidden;
        position: relative;
      }
      .tour-icon-wrap img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .tour-icon-fallback {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        letter-spacing: 0.3px;
      }
      .tour-step-title {
        font-size: 18px;
        font-weight: 700;
        line-height: 1.25;
      }
      .tour-step-body {
        margin-top: 6px;
        color: var(--text);
        line-height: 1.45;
      }
      .tour-step-hint {
        margin-top: 8px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(106, 169, 255, 0.45);
        background: rgba(37, 99, 235, 0.16);
        color: #dbeafe;
        font-size: 11px;
      }
      .tour-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }
      .tour-nav {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .tour-hurray {
        border: 1px solid rgba(34, 197, 94, 0.45);
        border-radius: 12px;
        background: radial-gradient(circle at center, rgba(16,185,129,0.22), rgba(11,13,18,0.8));
        padding: 10px 12px;
        font-weight: 700;
        color: #d1fae5;
        animation: hurrayPop 600ms ease;
      }
      @keyframes hurrayPop {
        0% { transform: scale(0.95); opacity: 0; }
        60% { transform: scale(1.02); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
      }
      .tour-highlight {
        position: fixed;
        border-radius: 14px;
        border: 2px solid rgba(106, 169, 255, 0.95);
        box-shadow: 0 0 0 6px rgba(106, 169, 255, 0.16), 0 0 34px rgba(34, 197, 94, 0.16);
        pointer-events: none;
        z-index: 51;
        transition: left 180ms ease, top 180ms ease, width 180ms ease, height 180ms ease, opacity 180ms ease;
      }
      .tour-highlight.hidden {
        opacity: 0;
      }
      @media (max-width: 700px) {
        .tour-card {
          grid-template-columns: 1fr;
        }
        .tour-icon-wrap {
          width: 56px;
          height: 56px;
        }
      }
      .welcome-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
        margin-top: 10px;
      }
      .welcome-subline {
        margin-top: 6px;
        color: var(--muted);
        font-size: 12px;
      }
      .welcome-flow {
        margin-top: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .flow-step {
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 11px;
        color: #dbeafe;
        background: rgba(11, 18, 32, 0.8);
      }
      .flow-arrow {
        color: rgba(154, 164, 178, 0.9);
        font-size: 12px;
      }
      .welcome-card {
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        background: rgba(9, 13, 20, 0.72);
        padding: 10px;
      }
      .welcome-kicker {
        font-size: 11px;
        letter-spacing: 0.9px;
        text-transform: uppercase;
        color: var(--accent);
        margin-bottom: 6px;
      }
      .welcome-actions {
        margin-top: 12px;
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        flex-wrap: wrap;
      }
      @keyframes welcomeEnter {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      #welcomeModal .welcome-subline,
      #welcomeModal .welcome-flow,
      #welcomeModal .welcome-card,
      #welcomeModal .welcome-actions {
        opacity: 0;
        transform: translateY(10px);
      }
      #welcomeModal.open .welcome-subline {
        animation: welcomeEnter 240ms ease forwards;
      }
      #welcomeModal.open .welcome-flow {
        animation: welcomeEnter 280ms ease forwards;
        animation-delay: 60ms;
      }
      #welcomeModal.open .welcome-card:nth-of-type(1) {
        animation: welcomeEnter 320ms ease forwards;
        animation-delay: 120ms;
      }
      #welcomeModal.open .welcome-card:nth-of-type(2) {
        animation: welcomeEnter 320ms ease forwards;
        animation-delay: 190ms;
      }
      #welcomeModal.open .welcome-card:nth-of-type(3) {
        animation: welcomeEnter 320ms ease forwards;
        animation-delay: 260ms;
      }
      #welcomeModal.open .welcome-actions {
        animation: welcomeEnter 320ms ease forwards;
        animation-delay: 330ms;
      }

      @media (max-width: 1200px) {
        .layout { grid-template-columns: 1fr; grid-template-rows: auto; height: auto; }
        /* Undo column pinning on smaller viewports to avoid implicit off-screen columns. */
        #leftPanel, #splitterLeft, main.workspace, #splitterRight, #rightPanel { grid-column: 1 !important; grid-row: auto !important; }
        .splitter { display: none !important; }
        .canvas-grid { grid-template-columns: 1fr; }
        .context-grid { grid-template-columns: 1fr; }
        .settings-shell { grid-template-columns: 1fr; }
        .welcome-grid { grid-template-columns: 1fr; }
        .preview-overlay-left {
          top: 8px;
          left: 8px;
        }
        .split-controls {
          gap: 6px;
        }
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="window-controls">
        <span class="dot"></span>
        <span class="dot yellow"></span>
        <span class="dot green"></span>
      </div>
      <div class="topbar-title">
        NorthStar
        <span class="badge">NorthStar  Gemini Hackathon 2026</span>
        <span class="topbar-credit">Built by Arnav Salkade</span>
      </div>
      <div class="topbar-actions">
        <button id="backBtn" class="icon-btn" title="Back" aria-label="Back" data-tip="Back">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <button id="toggleLeft" class="icon-btn" title="Explorer" aria-label="Explorer" data-tip="Explorer">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7h6l2 2h10v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><path d="M3 7V5a2 2 0 0 1 2-2h4l2 2"/></svg>
        </button>
        <button id="toggleRight" class="icon-btn" title="Chat" aria-label="Chat" data-tip="Chat">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a4 4 0 0 1-4 4H7l-4 3V7a4 4 0 0 1 4-4h10a4 4 0 0 1 4 4z"/></svg>
        </button>
        <button id="toggleTerminal" class="icon-btn" title="Terminal" aria-label="Terminal" data-tip="Terminal">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17l6-5-6-5"/><path d="M12 19h8"/></svg>
        </button>
        <button id="saveProject" class="icon-btn" title="Save" aria-label="Save" data-tip="Save">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><path d="M17 21v-8H7v8"/><path d="M7 3v5h8"/></svg>
        </button>
        <button id="openInfo" class="icon-btn" title="How It Works" aria-label="How it works" data-tip="How it works">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        </button>
        <button id="openSettings" class="icon-btn primary" title="Settings" aria-label="Settings" data-tip="Settings">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/><path d="M19.4 15a1.8 1.8 0 0 0 .36 1.98l.03.03a2.2 2.2 0 0 1-1.56 3.75 2.2 2.2 0 0 1-1.56-.65l-.03-.03a1.8 1.8 0 0 0-1.98-.36 1.8 1.8 0 0 0-1.08 1.65V22a2.2 2.2 0 0 1-4.4 0v-.04a1.8 1.8 0 0 0-1.08-1.65 1.8 1.8 0 0 0-1.98.36l-.03.03a2.2 2.2 0 0 1-3.12 0 2.2 2.2 0 0 1 0-3.12l.03-.03A1.8 1.8 0 0 0 4.6 15a1.8 1.8 0 0 0-1.65-1.08H2.9a2.2 2.2 0 0 1 0-4.4h.04A1.8 1.8 0 0 0 4.6 8.44a1.8 1.8 0 0 0-.36-1.98l-.03-.03a2.2 2.2 0 0 1 3.12-3.12l.03.03A1.8 1.8 0 0 0 9.34 3.7 1.8 1.8 0 0 0 10.42 2.05V2a2.2 2.2 0 0 1 4.4 0v.04a1.8 1.8 0 0 0 1.08 1.65 1.8 1.8 0 0 0 1.98-.36l.03-.03a2.2 2.2 0 0 1 3.12 3.12l-.03.03a1.8 1.8 0 0 0-.36 1.98 1.8 1.8 0 0 0 1.65 1.08H22a2.2 2.2 0 0 1 0 4.4h-.04A1.8 1.8 0 0 0 19.4 15z"/></svg>
        </button>
      </div>
    </div>

    <div class="layout" id="layoutRoot">
      <aside class="panel" id="leftPanel">
        <div class="panel-header">Explorer</div>
        <div class="panel-body">
          <div class="section-title">Template</div>
          <label for="templateSelect">Preset</label>
          <select id="templateSelect"></select>
          <div class="row" style="margin-top:8px;">
            <button id="resetToTemplate" class="ghost" title="Reset prompt + brief to the selected template (demo fast-path)">Reset to template</button>
            <div class="muted" style="display:flex; align-items:center;">One-click demo recovery.</div>
          </div>
          <div class="muted" id="templateOutputPath" style="margin-top:8px;">
            Output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code>
          </div>
          <label for="templateDescription" style="margin-top:8px;">Template description</label>
          <textarea id="templateDescription" disabled></textarea>

          <div class="section-title">Workspace</div>
          <div class="row small" style="margin-top:8px;">
            <input id="newPath" placeholder="notes/outline.md" />
            <button id="applyRename" class="ghost hidden" title="Apply rename" aria-label="Apply rename">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>
            </button>
            <button id="createFolder" class="ghost" title="Create folder">+ Folder</button>
            <button id="createFile" class="ghost" title="Create file">+ File</button>
          </div>
          <div class="muted" id="fileStatus" style="margin-top:6px;">Tip: type a path, then click + Folder or + File.</div>
          <div class="tree" id="workspaceTree" style="margin-top:8px;"></div>

          <div class="section-title">Job</div>
          <div class="muted" id="outputPaths" style="margin-bottom:8px;">Current output: work/jobs/&lt;job_id&gt;/out.mp4</div>
          <div class="row" style="margin-top:8px;">
            <div>
              <div class="slider-label-row">
                <label for="creativeMotion">Camera motion</label>
                <span id="creativeMotionReadout" class="slider-readout">58 / 100</span>
              </div>
              <input id="creativeMotion" type="range" min="0" max="100" step="1" value="58" />
            </div>
            <div>
              <div class="slider-label-row">
                <label for="creativeDensity">Label density</label>
                <span id="creativeDensityReadout" class="slider-readout">62 / 100</span>
              </div>
              <input id="creativeDensity" type="range" min="0" max="100" step="1" value="62" />
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <div>
              <div class="slider-label-row">
                <label for="creativeEnergy">Animation energy</label>
                <span id="creativeEnergyReadout" class="slider-readout">68 / 100</span>
              </div>
              <input id="creativeEnergy" type="range" min="0" max="100" step="1" value="68" />
            </div>
            <div>
              <div class="slider-label-row">
                <label for="creativeComplexity">Scene complexity</label>
                <span id="creativeComplexityReadout" class="slider-readout">54 / 100</span>
              </div>
              <input id="creativeComplexity" type="range" min="0" max="100" step="1" value="54" />
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <div>
              <div class="slider-label-row">
                <label for="creativePolish">Refinement polish</label>
                <span id="creativePolishReadout" class="slider-readout">72 / 100</span>
              </div>
              <input id="creativePolish" type="range" min="0" max="100" step="1" value="72" />
            </div>
            <div>
              <div class="slider-label-row">
                <label for="creativePrecision">Precision focus</label>
                <span id="creativePrecisionReadout" class="slider-readout">66 / 100</span>
              </div>
              <input id="creativePrecision" type="range" min="0" max="100" step="1" value="66" />
            </div>
          </div>
          <div class="section-title" style="margin-top:10px;">Vibe Motion</div>
          <details id="vibeMotionDetails" open>
            <summary>Overlay text, captions, and orientation</summary>
            <div class="compact-scroll" style="margin-top:8px;">
              <div class="row">
                <label style="display:flex; align-items:center; gap:8px;">
                  <input id="vibeEnable" type="checkbox" checked />
                  Enable animated overlays + captions
                </label>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="vibePreset">Vibe preset</label>
                  <select id="vibePreset">
                    <option value="cinematic_science">Cinematic science</option>
                    <option value="clean_education">Clean education</option>
                    <option value="dramatic_docu">Dramatic documentary</option>
                    <option value="neon_explainer">Neon explainer</option>
                    <option value="minimal_elegant">Minimal elegant</option>
                    <option value="chalkboard_classic">Chalkboard classic</option>
                    <option value="shortform_punchy">Shortform punchy</option>
                  </select>
                </div>
                <div>
                  <label for="orientationGuide">Orientation guide</label>
                  <select id="orientationGuide">
                    <option value="auto">Auto from aspect</option>
                    <option value="portrait_9_16">Portrait storyteller (9:16)</option>
                    <option value="landscape_16_9">Landscape board (16:9)</option>
                    <option value="square_1_1">Square social (1:1)</option>
                  </select>
                  <button id="applyOrientationGuide" class="ghost" style="margin-top:6px;">Apply orientation style</button>
                </div>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="vibeTitle">Video title overlay</label>
                  <input id="vibeTitle" placeholder="The Quantum Spark" />
                </div>
                <div>
                  <label for="vibeCaptionMode">Caption mode</label>
                  <select id="vibeCaptionMode">
                    <option value="concise">Concise subtitles</option>
                    <option value="narrative">Narrative subtitles</option>
                    <option value="keyword">Keyword popups</option>
                    <option value="callout">Callout labels</option>
                    <option value="none">No extra captions</option>
                  </select>
                </div>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="vibeTextAnim">Text animation style</label>
                  <select id="vibeTextAnim">
                    <option value="cinematic_fade">Cinematic fade</option>
                    <option value="kinetic_slide">Kinetic slide</option>
                    <option value="typewriter">Typewriter</option>
                    <option value="glow_pop">Glow pop</option>
                    <option value="parallax_float">Parallax float</option>
                    <option value="burst_scale">Burst scale</option>
                    <option value="flash_cut">Flash cut</option>
                    <option value="chalk_draw">Chalk draw</option>
                  </select>
                </div>
                <div>
                  <label for="vibeCaptionAnim">Caption animation</label>
                  <select id="vibeCaptionAnim">
                    <option value="soft_fade">Soft fade</option>
                    <option value="word_by_word">Word-by-word</option>
                    <option value="line_slide">Line slide</option>
                    <option value="pulse_highlight">Pulse highlight</option>
                    <option value="ticker_flow">Ticker flow</option>
                    <option value="pop_stagger">Pop stagger</option>
                  </select>
                </div>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="vibeCaptionPosition">Caption position</label>
                  <select id="vibeCaptionPosition">
                    <option value="lower_third">Lower third</option>
                    <option value="center">Center</option>
                    <option value="top">Top</option>
                  </select>
                </div>
                <div>
                  <label for="vibeCaptionDensity">Caption density</label>
                  <select id="vibeCaptionDensity">
                    <option value="light">Light</option>
                    <option value="balanced">Balanced</option>
                    <option value="dense">Dense</option>
                  </select>
                </div>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="vibeOverlayStrength">Overlay intensity</label>
                  <input id="vibeOverlayStrength" type="range" min="0" max="100" value="62" />
                </div>
                <div>
                  <label for="vibeTitleWeight">Title weight</label>
                  <select id="vibeTitleWeight">
                    <option value="bold">Bold</option>
                    <option value="medium">Medium</option>
                    <option value="light">Light</option>
                  </select>
                </div>
              </div>
            </div>
            <div class="muted" style="margin-top:8px;">
              Orientation tip: portrait keeps captions in lower third; landscape shifts captions upward and allows wider scene layouts.
            </div>
          </details>
          <details id="jobArtifacts" style="margin-top:8px;">
            <summary>Artifacts</summary>
            <div class="muted" style="margin-top:6px;">Job ID</div>
            <div id="jobId" style="margin-bottom:8px;"></div>
            <div class="tree" id="jobFileList"></div>
          </details>
          <details id="historyPanel" style="margin-top:10px;">
            <summary>History</summary>
            <div class="muted" style="margin-top:6px;">Last 3 actions</div>
            <div class="tree" id="historyList"></div>
          </details>
          <details id="sidebarHealthPanel" style="margin-top:10px;">
            <summary>Backend Health</summary>
            <div class="muted" style="margin-top:6px;">Live runtime checks from the API.</div>
            <div class="health-badges" style="margin-top:8px;">
              <span class="badge-pill" id="sidebarBadgeApi">API: Unknown</span>
              <span class="badge-pill" id="sidebarBadgeManim">Manim: Unknown</span>
              <span class="badge-pill" id="sidebarBadgeFfmpeg">ffmpeg: Unknown</span>
              <span class="badge-pill" id="sidebarBadgeOutput">Output: Unknown</span>
            </div>
            <pre id="sidebarHealthText" class="muted" style="margin-top:8px; white-space:pre-wrap;">No checks yet.</pre>
            <button id="refreshSidebarHealth" class="ghost" style="margin-top:8px;">Refresh health</button>
          </details>
        </div>
      </aside>

      <div class="splitter" id="splitterLeft"></div>

      <main class="panel workspace">
        <div class="tabs">
          <button class="tab active" data-tab="canvas">Canvas</button>
          <button class="tab" data-tab="code">Code</button>
        </div>

        <div class="tab-panels">
          <section class="tab-panel active" data-tab="canvas">
            <div class="canvas-grid">
              <div class="card scroll controls-card">
                <details id="imageGenDetails" open>
                  <summary>Image generation</summary>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="imagePreset">Physics preset</label>
                      <select id="imagePreset"></select>
                    </div>
                    <div>
                      <label for="imageAssetType">Asset type</label>
                      <select id="imageAssetType">
                        <option value="cinematic_background">Cinematic background</option>
                        <option value="explanation_avatar">Explanation avatar</option>
                        <option value="equation_card">Equation card</option>
                        <option value="tdx_card">TDX card (term-definition-example)</option>
                        <option value="concept_diagram">Concept diagram panel</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="imagePrompt">Image prompt</label>
                      <input id="imagePrompt" value="Matte black cinematic background, soft vignette, subtle texture, no text, no objects" placeholder="Scientist walking in a park" />
                    </div>
                    <div>
                      <label for="imageMinorEdit">Minor edits</label>
                      <input id="imageMinorEdit" placeholder="e.g. add subtle blue rim light, cleaner equation typography" />
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="imageMode">Image placement</label>
                      <select id="imageMode">
                        <option value="background">Background</option>
                        <option value="foreground">Foreground</option>
                        <option value="both">Both</option>
                      </select>
                      <label for="imageVariants" style="margin-top:6px;">Variations</label>
                      <select id="imageVariants">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                      </select>
                    </div>
                    <div>
                      <label>Physics prompt pack</label>
                      <div class="muted">Click once to replace prompt.</div>
                      <div class="prompt-chip-row" id="imagePromptPack"></div>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <button id="genImages" type="button" class="secondary" title="Generate background/foreground previews using the image model (Nano Banana)">
                      Generate images
                    </button>
                    <div class="muted" style="display:flex; align-items:center;">
                      Nano Banana Pro flow: pick preset -> (optional) minor edits -> generate -> click best variant -> drag into scenes.
                    </div>
                  </div>

                  <div class="asset-tray">
                    <div class="asset-slot">
                      <div class="asset-title">Background preview (drag into a scene)</div>
                      <div class="asset-thumb" id="bgThumb">No image yet</div>
                      <div class="asset-meta selected" id="bgVariantStatus">Selected variant: none</div>
                      <div class="asset-meta" id="bgAppliedInfo">Applied to: none</div>
                      <div class="asset-actions">
                        <input id="bgSceneTarget" class="scene-target-input" placeholder="Scene #" title="Scene number (example: 2)" />
                        <button id="applyBgScene" class="ghost">BG -> scene</button>
                        <button id="applyBgAll" class="ghost">BG -> all scenes</button>
                        <button id="clearBgAll" class="ghost">Clear BG</button>
                      </div>
                    </div>
                    <div class="asset-slot">
                      <div class="asset-title">Foreground preview (drag into a scene)</div>
                      <div class="asset-thumb" id="fgThumb">No image yet</div>
                      <div class="asset-meta selected" id="fgVariantStatus">Selected variant: none</div>
                      <div class="asset-meta" id="fgAppliedInfo">Applied to: none</div>
                      <div class="asset-actions">
                        <input id="fgSceneTarget" class="scene-target-input" placeholder="Scene #" title="Scene number (example: 2)" />
                        <button id="applyFgScene" class="ghost">FG -> scene</button>
                        <button id="applyFgAll" class="ghost">FG -> all scenes</button>
                        <button id="clearFgAll" class="ghost">Clear FG</button>
                      </div>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <button id="resetSceneAssets" class="ghost">Reset scene image mapping</button>
                    <div class="muted" style="display:flex; align-items:center;">Keeps generated images, clears BG/FG assignments from timeline scenes.</div>
                  </div>
                </details>

                <div class="row" style="margin-top:8px;">
                  <div>
                    <label for="includeImages">Include images</label>
                    <select id="includeImages">
                      <option value="true">Yes</option>
                      <option value="false">No</option>
                    </select>
                  </div>
                  <div>
                    <label for="aspect">Aspect ratio</label>
                    <select id="aspect">
                      <option value="9:16">9:16</option>
                      <option value="16:9">16:9</option>
                      <option value="1:1">1:1</option>
                      <option value="4:5">4:5</option>
                      <option value="3:4">3:4</option>
                      <option value="2:3">2:3</option>
                      <option value="3:2">3:2</option>
                      <option value="4:3">4:3</option>
                      <option value="5:4">5:4</option>
                      <option value="5:3">5:3</option>
                      <option value="18:9">18:9</option>
                      <option value="21:9">21:9</option>
                      <option value="1.91:1">1.91:1</option>
                      <option value="2.39:1">2.39:1</option>
                    </select>
                  </div>
                </div>

                <details style="margin-top:10px;">
                  <summary>Advanced creative controls</summary>
                  <div class="muted" style="margin-top:8px;">These controls are applied by default on every plan and render.</div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="audience">Audience</label>
                      <select id="audience">
                        <option value="general">General</option>
                        <option value="high school">High school</option>
                        <option value="undergrad">Undergrad</option>
                        <option value="expert">Expert</option>
                      </select>
                    </div>
                    <div>
                      <label for="tone">Tone</label>
                      <select id="tone">
                        <option value="epic">Epic</option>
                        <option value="calm">Calm</option>
                        <option value="playful">Playful</option>
                        <option value="serious">Serious</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="style">Style</label>
                      <select id="style">
                        <option value="cinematic">Cinematic</option>
                        <option value="clean">Clean</option>
                        <option value="chalkboard">Chalkboard</option>
                        <option value="neon">Neon</option>
                      </select>
                    </div>
                    <div>
                      <label for="pace">Pace</label>
                      <select id="pace">
                        <option value="medium">Medium</option>
                        <option value="slow">Slow</option>
                        <option value="fast">Fast</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="palette">Color palette</label>
                      <select id="palette">
                        <option value="cool">Cool</option>
                        <option value="warm">Warm</option>
                        <option value="neon">Neon</option>
                        <option value="monochrome">Monochrome</option>
                      </select>
                    </div>
                    <div>
                      <label for="quality">Render quality</label>
                      <select id="quality">
                        <option value="pql">Low</option>
                        <option value="pqm">Medium</option>
                        <option value="pqh">High</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="targetSeconds">Target seconds</label>
                      <input id="targetSeconds" placeholder="Leave blank" />
                      <select id="durationPreset" style="margin-top:6px;">
                        <option value="">Duration presets</option>
                        <option value="30">30s</option>
                        <option value="45">45s</option>
                        <option value="60">1 min</option>
                        <option value="90">1:30</option>
                        <option value="120">2 min</option>
                        <option value="180">3 min</option>
                      </select>
                    </div>
                    <div>
                      <label for="maxScenes">Max scenes</label>
                      <input id="maxScenes" placeholder="Leave blank" />
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="maxObjects">Max objects</label>
                      <input id="maxObjects" placeholder="Leave blank" />
                    </div>
                    <div>
                      <label for="directorBrief">Director brief</label>
                      <input id="directorBrief" placeholder="Use a strong hook" />
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="equations">Equations</label>
                      <select id="equations">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                    <div>
                      <label for="graphs">Graphs</label>
                      <select id="graphs">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="narration">Narration</label>
                      <select id="narration">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                    <div>
                      <label for="imageModelOverride">Image model override</label>
                      <select id="imageModelOverride">
                        <option value="">Default</option>
                        <option value="gemini-2.5-flash-image">nano banana pro (gemini-2.5-flash-image)</option>
                        <option value="gemini-3-pro-image-preview">gemini-3-pro-image-preview</option>
                      </select>
                    </div>
                  </div>
                </details>
              </div>

              <div class="card preview-card">
                <div class="muted" style="margin-bottom:6px;">Preview</div>
                <div class="preview-wrap">
                  <div class="preview-area">
                    <div class="preview-shell" id="previewSlot"></div>
                  </div>
                  <div class="preview-overlay-left">
                    <label class="preview-aspect-quick" title="Quick aspect ratio switch">
                      <span>Aspect</span>
                      <select id="aspectQuick" aria-label="Quick aspect ratio">
                        <option value="9:16">9:16</option>
                        <option value="9:19.5">9:19.5</option>
                        <option value="16:9">16:9</option>
                        <option value="2:1">2:1</option>
                        <option value="1:2">1:2</option>
                        <option value="1:1">1:1</option>
                        <option value="4:5">4:5</option>
                        <option value="3:4">3:4</option>
                        <option value="2:3">2:3</option>
                        <option value="3:2">3:2</option>
                        <option value="4:3">4:3</option>
                        <option value="5:4">5:4</option>
                        <option value="5:3">5:3</option>
                        <option value="18:9">18:9</option>
                        <option value="21:9">21:9</option>
                        <option value="1.91:1">1.91:1</option>
                        <option value="2.39:1">2.39:1</option>
                      </select>
                    </label>
                    <button id="toggleTimelineBtn" class="overlay-btn" title="Hide or show timeline" aria-label="Toggle timeline">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M3 12h18"/><path d="M3 18h18"/></svg>
                    </button>
                  </div>
                  <div class="preview-empty" id="previewEmpty">Create a plan, approve it, and your rendered video will appear here.</div>
                  <div class="preview-busy hidden" id="busyOverlay" aria-hidden="true">
                    <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
                      <div style="display:flex; align-items:center; gap:10px;">
                        <div class="spinner"></div>
                        <div class="busy-title" id="busyTitle">Rendering</div>
                      </div>
                      <div class="busy-sub" id="busySub">Directing scenes</div>
                      <div class="busy-thought" id="busyThought">Thinking about scene pacing</div>
                    </div>
                  </div>
                  <div class="preview-overlay">
                    <button id="downloadBtn" class="overlay-btn" title="Download video" aria-label="Download video" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 21h14"/></svg>
                    </button>
                    <button id="shareBtn" class="overlay-btn" title="Share link" aria-label="Share link" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><path d="M16 6l-4-4-4 4"/><path d="M12 2v14"/></svg>
                    </button>
                    <button id="appendBtn" class="overlay-btn" title="Add next scene (+)" aria-label="Add next scene" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg>
                    </button>
                    <button id="snapshotBtn" class="overlay-btn" title="Capture PNG frame" aria-label="Capture PNG frame" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                    </button>
                    <button id="voiceoverBtn" class="overlay-btn" title="Add ElevenLabs voiceover" aria-label="Add ElevenLabs voiceover" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>
                    </button>
                    <button id="exportBtn" class="overlay-btn" title="Download project ZIP" aria-label="Download project ZIP" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M7 10l5 5 5-5"/><path d="M12 15V3"/></svg>
                    </button>
                    <button id="ccBtn" class="overlay-btn" title="Download captions (.srt)" aria-label="Download captions" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H3v14h18V5z"/><path d="M7 10h1"/><path d="M7 14h1"/><path d="M11 10h1"/><path d="M11 14h1"/><path d="M15 10h2"/><path d="M15 14h2"/></svg>
                    </button>
                    <button id="scriptPackOverlayBtn" class="overlay-btn" title="Generate multilingual script packs" aria-label="Generate multilingual script packs" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M2 12h20"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
                    </button>
                  </div>
                  <div id="voiceoverPanel" class="voiceover-panel hidden" aria-hidden="true">
                    <div class="voiceover-head">
                      <div class="voiceover-title">Narration Voiceover</div>
                      <button id="closeVoiceoverPanel" class="overlay-btn" title="Close voiceover panel" aria-label="Close voiceover panel">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                      </button>
                    </div>
                    <label for="voiceoverVoiceSelect">Voice</label>
                    <select id="voiceoverVoiceSelect">
                      <option value="">Use settings voice</option>
                      <option value="21m00Tcm4TlvDq8ikWAM">Rachel (clear)</option>
                      <option value="EXAVITQu4vr4xnSDxMaL">Bella (warm)</option>
                      <option value="TxGEqnHWrfWFTfGW9XjX">Josh (confident)</option>
                      <option value="VR6AewLTigWG4xSOukaG">Arnold (narrative)</option>
                    </select>
                    <label for="voiceoverModelSelect">Voice model</label>
                    <select id="voiceoverModelSelect">
                      <option value="">Use settings model</option>
                      <option value="eleven_multilingual_v2">eleven_multilingual_v2</option>
                      <option value="eleven_turbo_v2_5">eleven_turbo_v2_5</option>
                    </select>
                    <label for="voiceoverScript">Optional script override</label>
                    <textarea id="voiceoverScript" placeholder="Leave blank to auto-generate a natural script (Gemini)."></textarea>
                    <label><input id="voiceoverUseGemini" type="checkbox" checked /> Use Gemini to draft a more natural voiceover</label>
                    <label><input id="voiceoverUseContext" type="checkbox" checked /> Include chat context for narration cues</label>
                    <button id="voiceoverApply" class="secondary">Apply voiceover</button>
                    <hr style="border:none; border-top:1px solid var(--line); margin:10px 0;" />
                    <label>Multilingual script packs</label>
                    <div class="row">
                      <label style="display:flex; align-items:center; gap:6px;"><input id="langEn" type="checkbox" checked /> EN</label>
                      <label style="display:flex; align-items:center; gap:6px;"><input id="langHi" type="checkbox" checked /> HI</label>
                      <label style="display:flex; align-items:center; gap:6px;"><input id="langEs" type="checkbox" checked /> ES</label>
                    </div>
                    <button id="scriptPackBtn" class="secondary">Generate script packs</button>
                    <div id="scriptPackStatus" class="muted" style="margin-top:6px;">Generates natural narration text + timing-ready captions per scene.</div>
                  </div>
                </div>
                <div class="preview-transport">
                  <input id="timelineScrub" type="range" min="0" max="100" value="0" />
                  <div class="timeline-controls">
                    <button id="rew10" class="ctl" title="Rewind 10s" aria-label="Rewind 10 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 19l-9-7 9-7v14z"/></svg>
                      <span class="ctl-label">10s</span>
                    </button>
                    <button id="rew5" class="ctl" title="Back 5s" aria-label="Back 5 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 5v14"/></svg>
                      <span class="ctl-label">5s</span>
                    </button>
                    <button id="playPause" class="ctl" title="Play/Pause" aria-label="Play pause">
                      <svg id="playPauseIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 5v14l11-7z"/></svg>
                      <span id="playPauseLabel" class="ctl-label">Play</span>
                    </button>
                    <button id="ff5" class="ctl" title="Forward 5s" aria-label="Forward 5 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19l9-7-9-7v14z"/><path d="M2 5v14"/></svg>
                      <span class="ctl-label">5s</span>
                    </button>
                    <button id="ff10" class="ctl" title="Forward 10s" aria-label="Forward 10 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19l9-7-9-7v14z"/><path d="M2 19l9-7-9-7v14z"/></svg>
                      <span class="ctl-label">10s</span>
                    </button>
                    <div class="muted" id="timeReadout">0:00</div>
                  </div>
                  <div class="split-controls">
                    <button id="setCutStart" class="ghost">IN</button>
                    <button id="setCutEnd" class="ghost">OUT</button>
                    <button id="applyCutRange" class="secondary">Split & remove</button>
                    <button id="clearCutRange" class="ghost">Clear</button>
                    <div class="muted" id="cutRangeLabel">Cut range: not set</div>
                  </div>
                  <div id="deckCarousel" class="deck-inline hidden" aria-label="Render history">
                    <button id="deckPrev" class="deck-btn" title="Previous render"></button>
                    <div id="deckTrack" class="deck-inline-track"></div>
                    <button id="deckNext" class="deck-btn" title="Next render"></button>
                  </div>
                </div>
              </div>

              <div class="canvas-splitter" id="canvasSplitter" title="Drag to resize preview/timeline"></div>

              <div class="card timeline-card">
                <div class="timeline-wrap">
                  <div class="timeline-head">
                    <div class="muted" id="timelineLabel">Timeline</div>
                    <button id="timelineHideBtn" class="ghost timeline-hide-btn" title="Hide timeline">Hide</button>
                  </div>
                  <div class="timeline-ruler" id="timelineRuler" style="margin-top:6px;"></div>
                  <div class="timeline-track" id="timelineTrack"></div>
                  <div class="timeline-hint">Tip: drag scene cards to reorder, drag right-edge to resize, and drop BG/FG assets on a scene.</div>
                </div>

                <div class="muted" style="margin-top:10px;">
                  Pro tip: type <code>/health</code>, <code>/settings</code>, <code>/attach notes/outline.md</code>, <code>/clear</code> in the prompt box.
                </div>
              </div>
            </div>
          </section>

          <section class="tab-panel" data-tab="code">
            <div class="editor-tabs-wrap">
              <div id="editorTabs" class="editor-tabs"></div>
              <button id="newCodeTab" class="ghost btn-inline" title="New file tab">+</button>
            </div>
              <div class="toolbar">
                <div class="muted" id="editorLabel">Editor</div>
                <div class="spacer"></div>
                <button id="undoCode" class="ghost btn-inline icon-only" title="Undo" aria-label="Undo">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 14L4 9l5-5"/><path d="M4 9h9a7 7 0 1 1 0 14h-1"/></svg>
                </button>
                <button id="redoCode" class="ghost btn-inline icon-only" title="Redo" aria-label="Redo">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 14l5-5-5-5"/><path d="M20 9h-9a7 7 0 1 0 0 14h1"/></svg>
                </button>
                <button id="addSelection" class="ghost btn-inline" title="Add selected text to prompt (@reference)">@</button>
                <button id="saveFile" class="ghost btn-inline" disabled>Save file</button>
                <button id="renderCode" class="secondary btn-inline">Render code</button>
              <button id="downloadVideo" class="secondary btn-inline">Download video</button>
              <button id="toggleHighlight" class="ghost btn-inline" title="Toggle syntax highlighting">Highlight</button>
            </div>
            <div class="code-body">
              <div class="code-editor" id="codeEditor">
                <div class="code-gutter" id="codeGutter">1</div>
                <textarea id="code" spellcheck="false" wrap="off"></textarea>
              </div>
              <pre id="codePrettyWrap" class="hljs hidden"><code id="codePretty" class="language-python code-lines"></code></pre>
            </div>
          </section>

          <section class="tab-panel" data-tab="settings" id="settingsPanel">
            <div class="settings-header">
              <div class="settings-title">Settings</div>
              <button id="closeSettings" class="icon-btn" title="Close settings" aria-label="Close settings" style="width:auto;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
              </button>
            </div>

            <div class="settings-shell">
              <div class="settings-nav" id="settingsNav">
                <button class="ghost active" data-stab="api">API & Models</button>
                <button class="ghost" data-stab="render">Rendering</button>
                <button class="ghost" data-stab="output">Output</button>
                <button class="ghost" data-stab="agent">Agent</button>
                <button class="ghost" data-stab="skills">Skills</button>
                <button class="ghost" data-stab="layout">Layout</button>
              </div>

              <div class="settings-content">
                <div class="settings-section active" data-stab="api">
                  <div class="drawer-section">
                    <div class="drawer-title">API & Models</div>
                    <label for="settingsApiKey">Gemini API key</label>
                    <input id="settingsApiKey" type="password" placeholder="Paste key" />
                    <button id="settingsShowKey" class="ghost" style="margin-top:6px;">Show/Hide Gemini key</button>
                    <button id="settingsShowAllKeys" class="ghost" style="margin-top:6px;">Show/Hide all keys</button>

                    <div class="row" style="margin-top:10px;">
                      <div>
                        <label for="settingsTextModel">Default text model</label>
                        <select id="settingsTextModel">
                          <option value="gemini-3-flash-preview">gemini-3-flash-preview</option>
                          <option value="gemini-3-pro-preview">gemini-3-pro-preview</option>
                          <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                          <option value="gemini-2.5-pro">gemini-2.5-pro</option>
                        </select>
                      </div>
                      <div>
                        <label for="settingsImageModel">Default image model</label>
                        <select id="settingsImageModel">
                          <option value="gemini-2.5-flash-image">gemini-2.5-flash-image (Nano Banana)</option>
                          <option value="gemini-3-pro-image-preview">gemini-3-pro-image-preview</option>
                        </select>
                      </div>
                    </div>
                    <div class="muted" style="margin-top:6px;">Nano Banana = <code>gemini-2.5-flash-image</code></div>
                    <div class="drawer-section" style="margin-top:10px;">
                      <div class="drawer-title">Voiceover (ElevenLabs)</div>
                      <div class="row">
                        <div>
                          <label for="settingsElevenApiKey">ElevenLabs API key</label>
                          <input id="settingsElevenApiKey" type="password" placeholder="Paste key" />
                        </div>
                        <div>
                          <label for="settingsElevenVoiceId">Voice ID</label>
                          <input id="settingsElevenVoiceId" placeholder="21m00Tcm4TlvDq8ikWAM" />
                        </div>
                      </div>
                      <label for="settingsElevenModelId" style="margin-top:8px;">Model ID</label>
                      <input id="settingsElevenModelId" placeholder="eleven_multilingual_v2" />
                    </div>
                    <button id="saveSettings" style="margin-top:10px;">Save</button>
                  </div>
                </div>

                <div class="settings-section" data-stab="render">
                  <div class="drawer-section">
                    <div class="drawer-title">Rendering</div>
                    <label for="settingsManimPy">Python executable for Manim</label>
                    <input id="settingsManimPy" type="text" placeholder="python3" />
                    <div class="muted" style="margin-top:6px;">
                      This is the python executable used to run <code>python -m manim</code>. Leave blank to auto-detect.
                      Outputs are saved under <code>work/jobs/&lt;job_id&gt;/out.mp4</code>.
                    </div>
                    <div class="health-badges">
                      <span id="badgeManim" class="badge-pill bad">Manim: </span>
                      <span id="badgeFfmpeg" class="badge-pill bad">ffmpeg: </span>
                    </div>
                    <div class="row" style="margin-top:10px;">
                      <button id="getStarted" class="secondary">Get started</button>
                      <button id="runHealth" class="secondary">Health</button>
                      <button id="openInstallGuide" class="ghost">Install guide</button>
                    </div>
                    <div id="installPrompt" class="install-prompt hidden">
                      <div class="muted">Missing: <span id="installMissingList">manim</span></div>
                      <button id="installDeps" class="secondary">Install missing</button>
                      <button id="cancelInstall" class="ghost">Cancel</button>
                    </div>
                    <pre id="health" class="muted" style="margin-top:8px; white-space:pre-wrap;">No checks yet.</pre>
                  </div>
                </div>

                <div class="settings-section" data-stab="output">
                  <div class="drawer-section">
                    <div class="drawer-title">Output Paths</div>
                    <div class="muted">Where your generated files go:</div>
                    <div style="margin-top:8px;">
                      <div class="muted">Current MP4</div>
                      <code id="settingsOutputVideoPath">work/jobs/&lt;job_id&gt;/out.mp4</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Current scene code</div>
                      <code id="settingsOutputCodePath">notes/generated/&lt;job_id&gt;/scene.py</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Workspace files</div>
                      <code>work/user_files/...</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Project root</div>
                      <code id="settingsProjectRoot"></code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Work root</div>
                      <code id="settingsWorkRoot"></code>
                    </div>
                    <label for="settingsOutputCopyDir" style="margin-top:10px;">Optional extra copy destination</label>
                    <input id="settingsOutputCopyDir" placeholder="~/Desktop/NorthStar-Exports" />
                    <div class="muted" style="margin-top:6px;">After render, click Copy to output folder to copy MP4 there.</div>
                    <button id="copyOutputNow" class="secondary" style="margin-top:8px;">Copy to output folder</button>
                  </div>
                </div>

                <div class="settings-section" data-stab="agent">
                  <div class="drawer-section">
                    <div class="drawer-title">Agent Structure</div>
                    <div class="muted">These rules/subagents are appended to your director brief.</div>
                    <label for="rulesText" style="margin-top:8px;">Rules</label>
                    <textarea id="rulesText" placeholder="Example: 1 concept per scene. Always label variables. Keep text centered."></textarea>
                    <label for="subagentsText" style="margin-top:8px;">Subagents (optional)</label>
                    <textarea id="subagentsText" placeholder="Example:\nDirector: creates storyboard\nAnimator: writes manim code\nQA: validates labels + spacing"></textarea>
                    <div class="saved-grid" id="subagentCards"></div>
                  </div>
                </div>

                <div class="settings-section" data-stab="skills">
                  <div class="drawer-section">
                    <div class="drawer-title">Skills</div>
                    <div class="muted">Create reusable instruction blocks. Select them in Chat  Context.</div>
                    <label for="skillName" style="margin-top:8px;">Skill name</label>
                    <input id="skillName" placeholder="Physics explainers" />
                    <label for="skillContent" style="margin-top:6px;">Skill instructions</label>
                    <textarea id="skillContent" placeholder="Always define variables on screen. Keep text centered."></textarea>
                    <button id="saveSkill" style="margin-top:6px;">Save skill</button>
                    <label for="skillIdea" style="margin-top:10px;">Generate skill idea</label>
                    <input id="skillIdea" placeholder="Make a concise storyboard rule" />
                    <input id="skillGenerateName" placeholder="Skill name (optional)" style="margin-top:6px;" />
                    <button id="generateSkill" class="secondary" style="margin-top:6px;">Generate skill</button>
                    <div class="saved-grid" id="savedSkillCards"></div>
                  </div>
                </div>

                <div class="settings-section" data-stab="layout">
                  <div class="drawer-section">
                    <div class="drawer-title">Layout</div>
                    <div class="muted">If panels disappear or sizes feel broken, reset the layout.</div>
                    <button id="resetLayout" class="secondary" style="margin-top:8px;">Reset layout</button>
                    <div class="muted" style="margin-top:10px;">Replay onboarding intro for first-time demo flow.</div>
                    <button id="replayWelcome" class="ghost" style="margin-top:6px;">Replay intro</button>
                  </div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <div class="terminal hidden" id="terminalPanel">
          <div class="toolbar" style="margin:0 0 8px 0;">
            <div class="muted">Terminal</div>
            <div class="spacer"></div>
            <input id="termCmd" class="btn-inline" style="width: 320px;" placeholder="help | manim --version | ffmpeg -version | ls jobs" />
            <button id="termRun" class="ghost btn-inline" title="Run command">Run</button>
          </div>
          <pre id="logs">Logs will appear here.</pre>
        </div>
      </main>

      <div class="splitter" id="splitterRight"></div>

      <aside class="panel" id="rightPanel">
        <div class="panel-header">Chat & Agent</div>
        <div class="panel-body chat">
          <div class="chat-carousel" id="chatCarousel">
            <button id="sessionPrev" class="chat-carousel-btn" title="Previous session"></button>
            <div class="chat-sessions" id="chatSessions"></div>
            <button id="sessionNext" class="chat-carousel-btn" title="Next session"></button>
          </div>
          <div class="agent-steps" id="agentSteps">
            <div class="agent-step" data-step="plan">Plan</div>
            <div class="agent-step" data-step="approve">Approve</div>
            <div class="agent-step" data-step="code">Code</div>
            <div class="agent-step" data-step="render">Render</div>
          </div>
          <div class="agent-progress" aria-hidden="true"><div id="agentProgressFill" class="agent-progress-fill"></div></div>
          <div id="stepDetail" class="step-detail">Click a step to inspect details.</div>

          <div class="chat-messages" id="chatMessages"></div>

          <details class="context-block">
            <summary>Context</summary>
            <div class="context-tabs" role="tablist" aria-label="Context tabs">
              <button class="ctx-tab active" data-ctx="memory" role="tab" aria-selected="true" title="Memory facts for this run">Memory</button>
              <button class="ctx-tab" data-ctx="docs" role="tab" aria-selected="false" title="Indexed links, transcripts, and source summaries">Docs</button>
              <button class="ctx-tab" data-ctx="skills" role="tab" aria-selected="false" title="Skill icon rail with quick enable/disable">Skills</button>
            </div>
            <div class="context-panel-shell">
              <div class="context-panel active" data-ctx="memory" role="tabpanel">
                <div class="muted" style="margin-bottom:6px;">Save key facts you want Gemini to remember for this run.</div>
                <div class="context-memory-grid">
                  <div class="field">
                    <label for="memoryTitle">Title</label>
                    <input id="memoryTitle" placeholder="Key idea" />
                  </div>
                  <div class="field">
                    <label for="memoryContent">Content</label>
                    <input id="memoryContent" placeholder="Threshold frequency depends on work function" />
                  </div>
                </div>
                <button id="addMemory" style="margin-top:8px;">Add memory</button>
                <div class="tree" id="memoryList"></div>
              </div>

              <div class="context-panel" data-ctx="docs" role="tabpanel">
                <div class="muted" style="margin-bottom:6px;">Paste a YouTube/web link + notes. Indexing creates a short source summary you can drag into prompt or timeline.</div>
                <div class="context-doc-grid">
                  <div>
                    <label for="sourceUrl">Link</label>
                    <input id="sourceUrl" placeholder="https://..." />
                  </div>
                  <div>
                    <label for="sourceNotes">Notes / transcript</label>
                    <textarea id="sourceNotes" placeholder="Paste transcript or key points here"></textarea>
                  </div>
                </div>
                <div class="context-doc-grid" style="margin-top:8px;">
                  <div>
                    <label for="sourceType">Source type</label>
                    <select id="sourceType">
                      <option value="auto">Auto detect</option>
                      <option value="youtube">YouTube link</option>
                      <option value="web">Web article/page</option>
                    </select>
                  </div>
                  <div class="context-actions-row">
                    <button id="indexSource" class="secondary">Index source</button>
                    <button id="saveSource" class="ghost">Save source</button>
                  </div>
                </div>
                <div id="sourceCards" class="saved-grid" style="margin-top:10px;"></div>
                <div id="sourceStatus" class="source-status muted">No sources yet.</div>
              </div>

              <div class="context-panel" data-ctx="skills" role="tabpanel">
                <div class="context-skill-help">Tap to enable per run. Hover to preview instruction; drag references into prompt.</div>
                <div class="skill-rail-shell">
                  <button id="skillRailPrev" class="skill-rail-btn" title="Scroll skills left"></button>
                  <div id="skillList" class="skill-rail"></div>
                  <button id="skillRailNext" class="skill-rail-btn" title="Scroll skills right"></button>
                </div>
                <div id="skillRailMeta" class="skill-rail-meta">0 selected</div>
              </div>
            </div>
          </details>

          <div class="muted">
            Tip: use <code>/</code> commands like <code>/health</code> and drag files into the prompt.
          </div>

          <textarea id="chatInput" placeholder="Type a prompt (or /health, /settings, /attach notes/outline.md)"></textarea>
          <div class="chat-compose">
            <input id="filePicker" type="file" class="hidden" multiple />
            <button id="attachBtn" class="compose-btn" title="Attach file (+)" aria-label="Attach file">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
            </button>
            <select id="chatModel" class="compose-model" title="Model" aria-label="Model">
              <option value="gemini-3-flash-preview">gemini-3-flash-preview</option>
              <option value="gemini-3-pro-preview">gemini-3-pro-preview</option>
              <option value="gemini-2.5-flash">gemini-2.5-flash</option>
              <option value="gemini-2.5-pro">gemini-2.5-pro</option>
            </select>
            <button id="voiceBtn" class="compose-btn" title="Voice input" aria-label="Voice input">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>
            </button>
            <button id="planBtn" class="compose-send" title="Send / Create plan" aria-label="Send">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/></svg>
            </button>
          </div>
          <div class="compose-mode-row">
            <label class="mode-chip" title="Crazy mode: run 3 parallel plan+render variants">
              <input id="crazyMode" type="checkbox" />
              <span class="mode-icon" aria-hidden="true"></span>
              <span class="mode-label">Crazy</span>
            </label>
            <label class="mode-chip" title="Gemini assist (auto-polish prompt before planning)">
              <input id="geminiAssist" type="checkbox" checked />
              <span class="mode-icon" aria-hidden="true"></span>
              <span class="mode-label">Assist</span>
            </label>
            <button id="polishPromptBtn" class="ghost compose-polish" title="Polish prompt + brief with Gemini" aria-label="Polish prompt + brief with Gemini">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3l2.2 4.5L19 10l-4.8 2.5L12 17l-2.2-4.5L5 10l4.8-2.5L12 3z"/><path d="M4 19l1.5-3L9 14.5 7.5 18 4 19z"/><path d="M16.5 18 15 14.5 18.5 16 20 19.5 16.5 18z"/></svg>
            </button>
            <div id="crazyCountdown" class="crazy-countdown hidden" aria-live="polite">
              <span id="crazyCountdownText" class="crazy-countdown-text">Crazy in 10s</span>
              <button id="crazyUndoBtn" class="ghost" title="Undo crazy mode launch">Undo</button>
            </div>
          </div>
          <div id="first60Panel" class="first60-panel">
            <div class="first60-head">
              <div>
                <div class="first60-title">First 60 seconds</div>
                <div id="first60Sub" class="first60-sub">0/4 complete</div>
              </div>
              <div class="first60-actions">
                <button id="first60Demo" class="ghost first60-mini" title="Load demo prompt">Demo</button>
                <button id="first60Health" class="ghost first60-mini" title="Run environment checks">Health</button>
                <button id="first60Hide" class="ghost first60-mini" title="Hide checklist" aria-label="Hide checklist">Hide</button>
              </div>
            </div>
            <div class="first60-progress" aria-hidden="true">
              <div id="first60Progress" class="first60-progress-fill"></div>
            </div>
            <div class="first60-list">
              <div id="first60ItemPrompt" class="first60-item">
                <span class="first60-dot">1</span>
                <span>Write prompt</span>
                <span class="first60-state">pending</span>
              </div>
              <div id="first60ItemPlan" class="first60-item">
                <span class="first60-dot">2</span>
                <span>Create plan</span>
                <span class="first60-state">pending</span>
              </div>
              <div id="first60ItemImage" class="first60-item">
                <span class="first60-dot">3</span>
                <span>Generate/select image</span>
                <span class="first60-state">pending</span>
              </div>
              <div id="first60ItemRender" class="first60-item">
                <span class="first60-dot">4</span>
                <span>Approve & render</span>
                <span class="first60-state">pending</span>
              </div>
            </div>
          </div>
          <button id="first60Show" class="ghost first60-show hidden" title="Show checklist">Show checklist</button>
          <div class="mention-toolbar">
            <button id="toggleMentions" class="mention-toggle">Show refs</button>
            <div class="muted" id="mentionInfo">Skills & agents references</div>
          </div>
          <div id="mentionBar" class="mention-bar"></div>
          <div class="muted" id="status">Ready.</div>
        </div>
      </aside>
    </div>

    <!-- settings drawer removed (settings are now in the middle panel) -->

    <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>
    <div id="skillTooltip" class="skill-tooltip hidden" aria-hidden="true"></div>

    <div id="infoModal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">How It Works</div>
          <button id="closeInfo" class="icon-btn" style="width:auto;" title="Close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="modal-body">
          <div id="tourIntroLine" class="tour-headline">
            Fast path: Create plan -> Generate images -> Approve & Render.
          </div>
          <div class="tour-shell">
            <div class="tour-progress-row">
              <div id="tourStepCount" class="tour-step-count">1 / 6</div>
              <div class="tour-progress" aria-hidden="true">
                <div id="tourProgressFill" class="tour-progress-fill"></div>
              </div>
            </div>
            <div class="tour-card">
              <div class="tour-icon-wrap">
                <img id="tourStepIcon" alt="Tour step icon" class="hidden" />
                <div id="tourIconFallback" class="tour-icon-fallback">icon</div>
              </div>
              <div>
                <div id="tourStepTitle" class="tour-step-title">Step</div>
                <div id="tourStepBody" class="tour-step-body">Description</div>
                <div id="tourStepHint" class="tour-step-hint">Hint</div>
              </div>
            </div>
            <div id="tourHurray" class="tour-hurray hidden">Hurray. You are ready to create.</div>
            <div class="tour-actions">
              <button id="tourRefreshBtn" class="ghost" title="Regenerate guide with Gemini + Nano Banana">
                Refresh with Gemini + Nano Banana
              </button>
              <div class="tour-nav">
                <button id="tourPrevBtn" class="ghost" title="Previous step">Back</button>
                <button id="tourNextBtn" title="Next step">Next</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="welcomeModal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Welcome to NorthStar</div>
          <button id="closeWelcome" class="icon-btn" style="width:auto;" title="Close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="modal-body">
          <div class="muted">No login. No paywall. Judges can use this immediately.</div>
          <div class="welcome-subline">Idea in -> Scene plan -> Manim code -> Rendered MP4</div>
          <div class="welcome-flow">
            <span class="flow-step">Create plan</span>
            <span class="flow-arrow">-></span>
            <span class="flow-step">Generate images</span>
            <span class="flow-arrow">-></span>
            <span class="flow-step">Approve & Render</span>
          </div>
          <div class="welcome-grid">
            <div class="welcome-card">
              <div class="welcome-kicker">Step 1</div>
              <div><strong>Create Plan</strong></div>
              <div class="muted">Describe the topic. Gemini builds the scene plan.</div>
            </div>
            <div class="welcome-card">
              <div class="welcome-kicker">Step 2</div>
              <div><strong>Generate Images</strong></div>
              <div class="muted">Create BG/FG assets and drag them into timeline scenes.</div>
            </div>
            <div class="welcome-card">
              <div class="welcome-kicker">Step 3</div>
              <div><strong>Approve & Render</strong></div>
              <div class="muted">Gemini writes Manim code and renders MP4 end-to-end.</div>
            </div>
            <div class="welcome-card">
              <div class="welcome-kicker">Agentic edits</div>
              <div><strong>Type natural commands</strong></div>
              <div class="muted">Examples: cut last 15s, extend to 60s, or redo. NorthStar updates the plan and re-renders.</div>
            </div>
          </div>
          <div class="welcome-actions">
            <button id="welcomeTourBtn" class="ghost">View quick guide</button>
            <button id="welcomeDemoBtn" class="secondary">Load demo prompt</button>
            <button id="welcomeStartBtn">Start</button>
          </div>
        </div>
      </div>
    </div>

    <div id="tourHighlight" class="tour-highlight hidden" aria-hidden="true"></div>

    <script>
      const jobFileListEl = document.getElementById('jobFileList');
      const jobIdEl = document.getElementById('jobId');
      const outputPathsEl = document.getElementById('outputPaths');
      const workspaceTreeEl = document.getElementById('workspaceTree');
      const newPathEl = document.getElementById('newPath');
      const applyRenameBtn = document.getElementById('applyRename');
      const createFolderBtn = document.getElementById('createFolder');
      const createFileBtn = document.getElementById('createFile');
      const fileStatusEl = document.getElementById('fileStatus');

      const templateSelectEl = document.getElementById('templateSelect');
      const templateDescriptionEl = document.getElementById('templateDescription');
      const resetToTemplateBtn = document.getElementById('resetToTemplate');
      const templateOutputPathEl = document.getElementById('templateOutputPath');
      const creativeMotionEl = document.getElementById('creativeMotion');
      const creativeMotionReadoutEl = document.getElementById('creativeMotionReadout');
      const creativeDensityEl = document.getElementById('creativeDensity');
      const creativeDensityReadoutEl = document.getElementById('creativeDensityReadout');
      const creativeEnergyEl = document.getElementById('creativeEnergy');
      const creativeEnergyReadoutEl = document.getElementById('creativeEnergyReadout');
      const creativeComplexityEl = document.getElementById('creativeComplexity');
      const creativeComplexityReadoutEl = document.getElementById('creativeComplexityReadout');
      const creativePolishEl = document.getElementById('creativePolish');
      const creativePolishReadoutEl = document.getElementById('creativePolishReadout');
      const creativePrecisionEl = document.getElementById('creativePrecision');
      const creativePrecisionReadoutEl = document.getElementById('creativePrecisionReadout');
      const vibeEnableEl = document.getElementById('vibeEnable');
      const vibePresetEl = document.getElementById('vibePreset');
      const orientationGuideEl = document.getElementById('orientationGuide');
      const applyOrientationGuideEl = document.getElementById('applyOrientationGuide');
      const vibeTitleEl = document.getElementById('vibeTitle');
      const vibeCaptionModeEl = document.getElementById('vibeCaptionMode');
      const vibeTextAnimEl = document.getElementById('vibeTextAnim');
      const vibeCaptionAnimEl = document.getElementById('vibeCaptionAnim');
      const vibeCaptionPositionEl = document.getElementById('vibeCaptionPosition');
      const vibeCaptionDensityEl = document.getElementById('vibeCaptionDensity');
      const vibeOverlayStrengthEl = document.getElementById('vibeOverlayStrength');
      const vibeTitleWeightEl = document.getElementById('vibeTitleWeight');
      const imageGenDetailsEl = document.getElementById('imageGenDetails');
      const imagePresetEl = document.getElementById('imagePreset');
      const imageAssetTypeEl = document.getElementById('imageAssetType');
      const imagePromptEl = document.getElementById('imagePrompt');
      const imageMinorEditEl = document.getElementById('imageMinorEdit');
      const imageModeEl = document.getElementById('imageMode');
      const imageVariantsEl = document.getElementById('imageVariants');
      const imagePromptPackEl = document.getElementById('imagePromptPack');
      const genImagesBtn = document.getElementById('genImages');
      const includeImagesEl = document.getElementById('includeImages');
      const aspectEl = document.getElementById('aspect');
      const aspectQuickEl = document.getElementById('aspectQuick');
      const audienceEl = document.getElementById('audience');
      const toneEl = document.getElementById('tone');
      const styleEl = document.getElementById('style');
      const paceEl = document.getElementById('pace');
      const paletteEl = document.getElementById('palette');
      const qualityEl = document.getElementById('quality');
      const targetSecondsEl = document.getElementById('targetSeconds');
      const durationPresetEl = document.getElementById('durationPreset');
      const maxScenesEl = document.getElementById('maxScenes');
      const maxObjectsEl = document.getElementById('maxObjects');
      const directorBriefEl = document.getElementById('directorBrief');
      const equationsEl = document.getElementById('equations');
      const graphsEl = document.getElementById('graphs');
      const narrationEl = document.getElementById('narration');
      const imageModelOverrideEl = document.getElementById('imageModelOverride');

      const memoryTitleEl = document.getElementById('memoryTitle');
      const memoryContentEl = document.getElementById('memoryContent');
      const addMemoryBtn = document.getElementById('addMemory');
      const memoryListEl = document.getElementById('memoryList');
      const ctxTabs = Array.from(document.querySelectorAll('.ctx-tab'));
      const ctxPanels = Array.from(document.querySelectorAll('.context-panel'));
      const contextPanelShellEl = document.querySelector('.context-panel-shell');
      const skillNameEl = document.getElementById('skillName');
      const skillContentEl = document.getElementById('skillContent');
      const saveSkillBtn = document.getElementById('saveSkill');
      const skillIdeaEl = document.getElementById('skillIdea');
      const skillGenerateNameEl = document.getElementById('skillGenerateName');
      const generateSkillBtn = document.getElementById('generateSkill');
      const skillListEl = document.getElementById('skillList');
      const skillRailPrevEl = document.getElementById('skillRailPrev');
      const skillRailNextEl = document.getElementById('skillRailNext');
      const skillRailMetaEl = document.getElementById('skillRailMeta');
      const skillTooltipEl = document.getElementById('skillTooltip');
      const savedSkillCardsEl = document.getElementById('savedSkillCards');

      const bgThumbEl = document.getElementById('bgThumb');
      const fgThumbEl = document.getElementById('fgThumb');
      const bgVariantStatusEl = document.getElementById('bgVariantStatus');
      const fgVariantStatusEl = document.getElementById('fgVariantStatus');
      const bgAppliedInfoEl = document.getElementById('bgAppliedInfo');
      const fgAppliedInfoEl = document.getElementById('fgAppliedInfo');
      const bgSceneTargetEl = document.getElementById('bgSceneTarget');
      const fgSceneTargetEl = document.getElementById('fgSceneTarget');
      const applyBgSceneBtn = document.getElementById('applyBgScene');
      const applyFgSceneBtn = document.getElementById('applyFgScene');
      const applyBgAllBtn = document.getElementById('applyBgAll');
      const clearBgAllBtn = document.getElementById('clearBgAll');
      const applyFgAllBtn = document.getElementById('applyFgAll');
      const clearFgAllBtn = document.getElementById('clearFgAll');
      const resetSceneAssetsBtn = document.getElementById('resetSceneAssets');

      const previewSlot = document.getElementById('previewSlot');
      const previewEmptyEl = document.getElementById('previewEmpty');
      const downloadBtnEl = document.getElementById('downloadBtn');
      const shareBtnEl = document.getElementById('shareBtn');
      const appendBtnEl = document.getElementById('appendBtn');
      const snapshotBtnEl = document.getElementById('snapshotBtn');
      const voiceoverBtnEl = document.getElementById('voiceoverBtn');
      const voiceoverPanelEl = document.getElementById('voiceoverPanel');
      const closeVoiceoverPanelEl = document.getElementById('closeVoiceoverPanel');
      const voiceoverVoiceSelectEl = document.getElementById('voiceoverVoiceSelect');
      const voiceoverModelSelectEl = document.getElementById('voiceoverModelSelect');
      const voiceoverScriptEl = document.getElementById('voiceoverScript');
      const voiceoverUseGeminiEl = document.getElementById('voiceoverUseGemini');
      const voiceoverUseContextEl = document.getElementById('voiceoverUseContext');
      const voiceoverApplyEl = document.getElementById('voiceoverApply');
      const scriptPackOverlayBtnEl = document.getElementById('scriptPackOverlayBtn');
      const scriptPackBtnEl = document.getElementById('scriptPackBtn');
      const scriptPackStatusEl = document.getElementById('scriptPackStatus');
      const langEnEl = document.getElementById('langEn');
      const langHiEl = document.getElementById('langHi');
      const langEsEl = document.getElementById('langEs');
      const exportBtnEl = document.getElementById('exportBtn');
      const ccBtnEl = document.getElementById('ccBtn');
      const deckCarouselEl = document.getElementById('deckCarousel');
      const deckTrackEl = document.getElementById('deckTrack');
      const deckPrevBtn = document.getElementById('deckPrev');
      const deckNextBtn = document.getElementById('deckNext');
      const timelineRulerEl = document.getElementById('timelineRuler');
      const timelineTrackEl = document.getElementById('timelineTrack');
      const timelineLabelEl = document.getElementById('timelineLabel');
      const timelineHideBtnEl = document.getElementById('timelineHideBtn');
      const toggleTimelineBtnEl = document.getElementById('toggleTimelineBtn');
      const timelineScrubEl = document.getElementById('timelineScrub');
      const canvasGridEl = document.querySelector('.canvas-grid');
      const canvasSplitterEl = document.getElementById('canvasSplitter');
      const controlsCardEl = document.querySelector('.controls-card');
      const rew10Btn = document.getElementById('rew10');
      const rew5Btn = document.getElementById('rew5');
      const playPauseBtn = document.getElementById('playPause');
      const playPauseIcon = document.getElementById('playPauseIcon');
      const playPauseLabel = document.getElementById('playPauseLabel');
      const ff5Btn = document.getElementById('ff5');
      const ff10Btn = document.getElementById('ff10');
      const timeReadoutEl = document.getElementById('timeReadout');
      const setCutStartBtn = document.getElementById('setCutStart');
      const setCutEndBtn = document.getElementById('setCutEnd');
      const applyCutRangeBtn = document.getElementById('applyCutRange');
      const clearCutRangeBtn = document.getElementById('clearCutRange');
      const cutRangeLabelEl = document.getElementById('cutRangeLabel');
      const codeEl = document.getElementById('code');
      const codeEditorEl = document.getElementById('codeEditor');
      const codeGutterEl = document.getElementById('codeGutter');
      const editorTabsEl = document.getElementById('editorTabs');
      const newCodeTabBtn = document.getElementById('newCodeTab');
      const editorLabelEl = document.getElementById('editorLabel');
      const undoCodeBtn = document.getElementById('undoCode');
      const redoCodeBtn = document.getElementById('redoCode');
      const addSelectionBtn = document.getElementById('addSelection');
      const saveFileBtn = document.getElementById('saveFile');
      const renderCodeBtn = document.getElementById('renderCode');
      const downloadVideoBtn = document.getElementById('downloadVideo');
      const toggleHighlightBtn = document.getElementById('toggleHighlight');
      const codePrettyWrapEl = document.getElementById('codePrettyWrap');
      const codePrettyEl = document.getElementById('codePretty');
      const logsEl = document.getElementById('logs');
      const terminalPanel = document.getElementById('terminalPanel');
      const termCmdEl = document.getElementById('termCmd');
      const termRunEl = document.getElementById('termRun');
      const busyOverlayEl = document.getElementById('busyOverlay');
      const busyTitleEl = document.getElementById('busyTitle');
      const busySubEl = document.getElementById('busySub');
      const busyThoughtEl = document.getElementById('busyThought');
      const toastEl = document.getElementById('toast');
      let toastTimer = null;
      document.querySelectorAll('button:not([type])').forEach((btn) => btn.setAttribute('type', 'button'));

      function showToast(message, kind = '') {
        if (!toastEl) return;
        toastEl.textContent = String(message || '');
        toastEl.classList.remove('ok', 'err', 'hidden');
        if (kind) toastEl.classList.add(kind);
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          toastEl.classList.add('hidden');
        }, 2600);
      }

      function formatValidationDetails(details) {
        if (!Array.isArray(details) || !details.length) return '';
        const first = details[0] || {};
        const loc = Array.isArray(first.loc) ? first.loc.filter(Boolean).join('.') : '';
        const msg = String(first.msg || '').trim();
        if (!loc && !msg) return '';
        if (!loc) return msg;
        if (!msg) return loc;
        return `${loc}: ${msg}`;
      }

      function normalizeApiError(data, fallback = 'Request failed.') {
        if (!data) return fallback;
        if (typeof data === 'string') return data || fallback;
        const direct = String(data.error || data.message || '').trim();
        if (direct && direct.toLowerCase() !== 'validation error') return direct;
        const detail = formatValidationDetails(data.details || data.detail);
        if (detail) return detail;
        if (direct) return direct;
        return fallback;
      }

      async function parseApiResponse(resp, fallback = 'Request failed.') {
        let raw = '';
        let data = null;
        try {
          raw = await resp.text();
          data = raw ? JSON.parse(raw) : null;
        } catch {
          data = null;
        }
        if (resp.ok && data && data.ok !== false) return data;
        let err = normalizeApiError(data, fallback);
        if ((!err || err === fallback) && raw) {
          const clipped = String(raw).trim().slice(0, 400);
          if (clipped) err = `HTTP ${resp.status}: ${clipped}`;
        } else if (!err || err === fallback) {
          err = `HTTP ${resp.status}: ${fallback}`;
        }
        return { ...(data && typeof data === 'object' ? data : {}), ok: false, error: err };
      }

      let isBusy = false;
      let crazyCountdownTimer = null;
      let crazyCountdownRemaining = 0;
      let crazyCountdownAction = null;
      let busyThoughtTimer = null;
      let busyThoughtIndex = 0;
      function busyThoughtPool(phase) {
        const key = String(phase || '').toLowerCase();
        if (key.includes('plan')) return [
          'Breaking topic into scenes',
          'Balancing clarity and pacing',
          'Keeping one concept per scene'
        ];
        if (key.includes('image')) return [
          'Composing background + foreground assets',
          'Matching visual style to the brief',
          'Preparing draggable image assets'
        ];
        if (key.includes('voice')) return [
          'Drafting narration timing',
          'Aligning captions and speech',
          'Mixing voice with video track'
        ];
        return [
          'Generating Manim scene code',
          'Validating scene structure',
          'Rendering frames and stitching output'
        ];
      }
      function setBusyThought(phase, fallbackMessage) {
        if (!busyThoughtEl) return;
        const pool = busyThoughtPool(phase);
        if (!pool.length) {
          busyThoughtEl.textContent = String(fallbackMessage || 'Working...');
          return;
        }
        busyThoughtEl.textContent = pool[busyThoughtIndex % pool.length];
        busyThoughtIndex += 1;
      }
      function startBusyThoughts(phase, fallbackMessage) {
        if (!busyThoughtEl) return;
        if (busyThoughtTimer) clearInterval(busyThoughtTimer);
        busyThoughtIndex = 0;
        setBusyThought(phase, fallbackMessage);
        busyThoughtTimer = setInterval(() => setBusyThought(phase, fallbackMessage), 1300);
      }
      function stopBusyThoughts() {
        if (busyThoughtTimer) {
          clearInterval(busyThoughtTimer);
          busyThoughtTimer = null;
        }
      }
      function setBusy(on, message, phase) {
        isBusy = !!on;
        if (busyOverlayEl) busyOverlayEl.classList.toggle('hidden', !isBusy);
        if (previewEmptyEl && isBusy) previewEmptyEl.classList.add('hidden');
        if (previewEmptyEl && !isBusy && !videoEl?.src) previewEmptyEl.classList.remove('hidden');
        if (statusEl) statusEl.classList.toggle('status-pulse', isBusy);
        if (typeof message === 'string' && statusEl) statusEl.textContent = message;
        if (typeof message === 'string' && busySubEl) busySubEl.textContent = message || 'Working';
        if (busyTitleEl) busyTitleEl.textContent = isBusy ? (phase || 'Rendering') : 'Ready';
        if (isBusy) startBusyThoughts(phase, message);
        else stopBusyThoughts();
        if (planBtn) planBtn.disabled = isBusy;
        if (renderCodeBtn) renderCodeBtn.disabled = !!isBusy;
        if (toggleHighlightBtn) toggleHighlightBtn.disabled = isBusy;
        if (!isBusy) updateEditorMode();
      }

      function updateCrazyCountdownText() {
        if (!crazyCountdownTextEl) return;
        const secs = Math.max(0, Number(crazyCountdownRemaining || 0));
        crazyCountdownTextEl.textContent = `Crazy in ${secs}s`;
      }

      function hideCrazyCountdown() {
        if (crazyCountdownEl) crazyCountdownEl.classList.add('hidden');
        if (crazyUndoBtnEl) crazyUndoBtnEl.disabled = true;
      }

      function cancelCrazyCountdown(message = 'Crazy mode cancelled.') {
        if (crazyCountdownTimer) {
          clearInterval(crazyCountdownTimer);
          crazyCountdownTimer = null;
        }
        crazyCountdownAction = null;
        crazyCountdownRemaining = 0;
        hideCrazyCountdown();
        if (!isBusy && planBtn) planBtn.disabled = false;
        if (message) {
          statusEl.textContent = message;
          showToast(message, 'ok');
          setStepNote('approve', 'Crazy mode cancelled before launch.');
        }
      }

      function startCrazyCountdown(onDone = null) {
        if (crazyCountdownTimer) return;
        const idea = String(chatInputEl?.value || '').trim();
        if (!idea) {
          statusEl.textContent = 'Type a prompt first.';
          showToast('Type a prompt first.', 'err');
          return;
        }
        crazyCountdownAction = typeof onDone === 'function' ? onDone : null;
        crazyCountdownRemaining = 10;
        updateCrazyCountdownText();
        if (crazyCountdownEl) crazyCountdownEl.classList.remove('hidden');
        if (crazyUndoBtnEl) crazyUndoBtnEl.disabled = false;
        if (!isBusy && planBtn) planBtn.disabled = true;
        setStep('approve', 'active');
        setStepNote('approve', 'Crazy mode armed. Press Undo within 10s to cancel.');
        statusEl.textContent = 'Crazy mode armed. Launching 3 variants in 10 seconds.';
        crazyCountdownTimer = setInterval(() => {
          crazyCountdownRemaining -= 1;
          if (crazyCountdownRemaining <= 0) {
            clearInterval(crazyCountdownTimer);
            crazyCountdownTimer = null;
            hideCrazyCountdown();
            if (!isBusy && planBtn) planBtn.disabled = false;
            const run = crazyCountdownAction || createCrazyRun;
            crazyCountdownAction = null;
            void run();
            return;
          }
          updateCrazyCountdownText();
        }, 1000);
      }

      window.addEventListener('error', (e) => {
        const msg = e?.error?.stack || e?.message || String(e);
        logsEl.textContent = `JS error:\n${msg}`;
      });
      window.addEventListener('unhandledrejection', (e) => {
        const msg = e?.reason?.stack || e?.reason?.message || String(e?.reason || e);
        logsEl.textContent = `Unhandled promise rejection:\n${msg}`;
      });

      const chatMessagesEl = document.getElementById('chatMessages');
      const chatInputEl = document.getElementById('chatInput');
      const chatModelEl = document.getElementById('chatModel');
      const planBtn = document.getElementById('planBtn');
      const attachBtnEl = document.getElementById('attachBtn');
      const filePickerEl = document.getElementById('filePicker');
      const voiceBtnEl = document.getElementById('voiceBtn');
      const mentionBarEl = document.getElementById('mentionBar');
      const mentionInfoEl = document.getElementById('mentionInfo');
      const toggleMentionsBtn = document.getElementById('toggleMentions');
      const chatSessionsEl = document.getElementById('chatSessions');
      const chatCarouselEl = document.getElementById('chatCarousel');
      const sessionPrevBtn = document.getElementById('sessionPrev');
      const sessionNextBtn = document.getElementById('sessionNext');
      const statusEl = document.getElementById('status');
      const agentStepsEl = document.getElementById('agentSteps');
      const agentProgressFillEl = document.getElementById('agentProgressFill');
      const stepDetailEl = document.getElementById('stepDetail');

      const leftPanel = document.getElementById('leftPanel');
      const rightPanel = document.getElementById('rightPanel');
      const layoutRoot = document.getElementById('layoutRoot');
      const splitterLeft = document.getElementById('splitterLeft');
      const splitterRight = document.getElementById('splitterRight');
      const backBtnEl = document.getElementById('backBtn');
      const toggleLeftBtn = document.getElementById('toggleLeft');
      const toggleRightBtn = document.getElementById('toggleRight');
      const toggleTerminalBtn = document.getElementById('toggleTerminal');
      const saveProjectBtn = document.getElementById('saveProject');

      const settingsPanelEl = document.getElementById('settingsPanel');
      const closeSettingsBtn = document.getElementById('closeSettings');
      const settingsNavEl = document.getElementById('settingsNav');
      const openInstallGuideBtn = document.getElementById('openInstallGuide');
      const getStartedBtn = document.getElementById('getStarted');
      const installPromptEl = document.getElementById('installPrompt');
      const installMissingListEl = document.getElementById('installMissingList');
      const installDepsBtn = document.getElementById('installDeps');
      const cancelInstallBtn = document.getElementById('cancelInstall');
      const openSettingsBtn = document.getElementById('openSettings');
      const openInfoBtn = document.getElementById('openInfo');
      const infoModal = document.getElementById('infoModal');
      const closeInfoBtn = document.getElementById('closeInfo');
      const welcomeModal = document.getElementById('welcomeModal');
      const closeWelcomeBtn = document.getElementById('closeWelcome');
      const welcomeTourBtn = document.getElementById('welcomeTourBtn');
      const welcomeDemoBtn = document.getElementById('welcomeDemoBtn');
      const welcomeStartBtn = document.getElementById('welcomeStartBtn');
      const settingsApiKeyEl = document.getElementById('settingsApiKey');
      const settingsShowKeyBtn = document.getElementById('settingsShowKey');
      const settingsShowAllKeysBtn = document.getElementById('settingsShowAllKeys');
      const settingsTextModelEl = document.getElementById('settingsTextModel');
      const settingsImageModelEl = document.getElementById('settingsImageModel');
      const settingsManimPyEl = document.getElementById('settingsManimPy');
      const saveSettingsBtn = document.getElementById('saveSettings');
      const runHealthBtn = document.getElementById('runHealth');
      const healthEl = document.getElementById('health');
      const badgeManimEl = document.getElementById('badgeManim');
      const badgeFfmpegEl = document.getElementById('badgeFfmpeg');
      const resetLayoutBtn = document.getElementById('resetLayout');
      const replayWelcomeBtn = document.getElementById('replayWelcome');
      const settingsOutputVideoPathEl = document.getElementById('settingsOutputVideoPath');
      const settingsOutputCodePathEl = document.getElementById('settingsOutputCodePath');
      const settingsProjectRootEl = document.getElementById('settingsProjectRoot');
      const settingsWorkRootEl = document.getElementById('settingsWorkRoot');
      const settingsOutputCopyDirEl = document.getElementById('settingsOutputCopyDir');
      const copyOutputNowBtn = document.getElementById('copyOutputNow');
      const settingsElevenApiKeyEl = document.getElementById('settingsElevenApiKey');
      const settingsElevenVoiceIdEl = document.getElementById('settingsElevenVoiceId');
      const settingsElevenModelIdEl = document.getElementById('settingsElevenModelId');

      const rulesTextEl = document.getElementById('rulesText');
      const subagentsTextEl = document.getElementById('subagentsText');
      const subagentCardsEl = document.getElementById('subagentCards');

      const sourceUrlEl = document.getElementById('sourceUrl');
      const sourceNotesEl = document.getElementById('sourceNotes');
      const sourceTypeEl = document.getElementById('sourceType');
      const indexSourceBtn = document.getElementById('indexSource');
      const saveSourceBtn = document.getElementById('saveSource');
      const sourceCardsEl = document.getElementById('sourceCards');
      const sourceStatusEl = document.getElementById('sourceStatus');
      const historyListEl = document.getElementById('historyList');
      const sidebarBadgeApiEl = document.getElementById('sidebarBadgeApi');
      const sidebarBadgeManimEl = document.getElementById('sidebarBadgeManim');
      const sidebarBadgeFfmpegEl = document.getElementById('sidebarBadgeFfmpeg');
      const sidebarBadgeOutputEl = document.getElementById('sidebarBadgeOutput');
      const sidebarHealthTextEl = document.getElementById('sidebarHealthText');
      const refreshSidebarHealthBtn = document.getElementById('refreshSidebarHealth');
      const crazyModeEl = document.getElementById('crazyMode');
      const geminiAssistEl = document.getElementById('geminiAssist');
      const crazyCountdownEl = document.getElementById('crazyCountdown');
      const crazyCountdownTextEl = document.getElementById('crazyCountdownText');
      const crazyUndoBtnEl = document.getElementById('crazyUndoBtn');
      const polishPromptBtn = document.getElementById('polishPromptBtn');
      const composeModeChips = Array.from(document.querySelectorAll('.mode-chip'));
      const first60PanelEl = document.getElementById('first60Panel');
      const first60ShowBtn = document.getElementById('first60Show');
      const first60HideBtn = document.getElementById('first60Hide');
      const first60DemoBtn = document.getElementById('first60Demo');
      const first60HealthBtn = document.getElementById('first60Health');
      const first60SubEl = document.getElementById('first60Sub');
      const first60ProgressEl = document.getElementById('first60Progress');
      const first60ItemPromptEl = document.getElementById('first60ItemPrompt');
      const first60ItemPlanEl = document.getElementById('first60ItemPlan');
      const first60ItemImageEl = document.getElementById('first60ItemImage');
      const first60ItemRenderEl = document.getElementById('first60ItemRender');
      const tourIntroLineEl = document.getElementById('tourIntroLine');
      const tourStepCountEl = document.getElementById('tourStepCount');
      const tourProgressFillEl = document.getElementById('tourProgressFill');
      const tourStepIconEl = document.getElementById('tourStepIcon');
      const tourIconFallbackEl = document.getElementById('tourIconFallback');
      const tourStepTitleEl = document.getElementById('tourStepTitle');
      const tourStepBodyEl = document.getElementById('tourStepBody');
      const tourStepHintEl = document.getElementById('tourStepHint');
      const tourHurrayEl = document.getElementById('tourHurray');
      const tourRefreshBtn = document.getElementById('tourRefreshBtn');
      const tourPrevBtn = document.getElementById('tourPrevBtn');
      const tourNextBtn = document.getElementById('tourNextBtn');
      const tourHighlightEl = document.getElementById('tourHighlight');

      const videoEl = document.createElement('video');
      videoEl.controls = true;
      previewSlot.appendChild(videoEl);
      let lastVideoUrl = '';
      let lastCaptionsUrl = '';
      const renderDeck = [];
      let activeDeckIndex = -1;
      function setVideoAvailable(available) {
        const ok = !!available;
        if (downloadBtnEl) downloadBtnEl.disabled = !ok;
        if (shareBtnEl) shareBtnEl.disabled = !ok;
        if (appendBtnEl) appendBtnEl.disabled = !ok;
        if (snapshotBtnEl) snapshotBtnEl.disabled = !ok;
        if (voiceoverBtnEl) voiceoverBtnEl.disabled = !ok;
        if (scriptPackOverlayBtnEl) scriptPackOverlayBtnEl.disabled = !ok;
        if (exportBtnEl) exportBtnEl.disabled = !ok || !currentJobId;
        if (ccBtnEl) ccBtnEl.disabled = !ok || !lastCaptionsUrl;
        if (previewEmptyEl) previewEmptyEl.classList.toggle('hidden', ok);
        updateFirst60Checklist();
      }

      function setActiveDeckIndex(idx) {
        if (!renderDeck.length) {
          activeDeckIndex = -1;
          renderDeckUI();
          return;
        }
        const n = renderDeck.length;
        const raw = Number(idx || 0);
        activeDeckIndex = ((raw % n) + n) % n;
        renderDeckUI();
      }

      function addRenderToDeck(entry) {
        const jobId = String(entry?.job_id || '');
        const videoPath = String(entry?.video_path || '');
        if (!jobId || !videoPath) return;
        const existing = renderDeck.findIndex((it) => it.job_id === jobId && it.video_path === videoPath);
        const payload = {
          job_id: jobId,
          video_path: videoPath,
          url: '/' + videoPath + '?t=' + Date.now(),
          appended_from: entry?.appended_from || '',
          created_at: Date.now(),
        };
        if (existing >= 0) {
          renderDeck[existing] = { ...renderDeck[existing], ...payload };
          activeDeckIndex = existing;
        } else {
          renderDeck.push(payload);
          activeDeckIndex = renderDeck.length - 1;
        }
        renderDeckUI();
      }

      function openDeckItem(item, index) {
        if (!item) return;
        activeDeckIndex = index;
        lastVideoUrl = item.url;
        videoEl.src = item.url;
        videoEl.load();
        setVideoAvailable(true);
        if (item.job_id) {
          currentJobId = item.job_id;
          jobIdEl.textContent = item.job_id;
          updateOutputPaths();
        }
        renderDeckUI();
      }

      function renderDeckUI() {
        if (!deckCarouselEl || !deckTrackEl) return;
        deckTrackEl.innerHTML = '';
        if (renderDeck.length <= 1) {
          deckCarouselEl.classList.add('hidden');
          return;
        }
        deckCarouselEl.classList.remove('hidden');
        if (activeDeckIndex < 0 || activeDeckIndex >= renderDeck.length) {
          activeDeckIndex = renderDeck.length - 1;
        }
        renderDeck.forEach((item, idx) => {
          const card = document.createElement('button');
          card.type = 'button';
          card.className = 'deck-card' + (idx === activeDeckIndex ? ' active' : '');
          card.style.opacity = idx === activeDeckIndex ? '1' : '0.72';
          const jid = item.job_id || '';
          card.innerHTML = `
            <div class="deck-card-line1">${idx + 1}. ${jid}</div>
            <div class="deck-card-line2">${item.appended_from ? 'Stitched' : 'Single segment'}  ${item.video_path.split('/').slice(-1)[0]}</div>
          `;
          card.addEventListener('click', () => openDeckItem(item, idx));
          deckTrackEl.appendChild(card);
        });
        if (deckPrevBtn) deckPrevBtn.disabled = renderDeck.length <= 1;
        if (deckNextBtn) deckNextBtn.disabled = renderDeck.length <= 1;
        const activeCard = deckTrackEl.children[activeDeckIndex];
        if (activeCard && activeCard.scrollIntoView) {
          activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      }

      function fmtTime(s) {
        const sec = Math.max(0, Math.floor(Number(s || 0)));
        const m = Math.floor(sec / 60);
        const r = sec % 60;
        return `${m}:${String(r).padStart(2, '0')}`;
      }

      function updateTransportUI() {
        if (!timeReadoutEl) return;
        const cur = videoEl.currentTime || 0;
        const dur = videoEl.duration || 0;
        timeReadoutEl.textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`;
        highlightTimelineAt(cur);
        if (!playPauseBtn) return;
        const isPaused = videoEl.paused;
        if (playPauseLabel) playPauseLabel.textContent = isPaused ? 'Play' : 'Pause';
        if (playPauseIcon) {
          playPauseIcon.innerHTML = isPaused
            ? '<path d="M8 5v14l11-7z"/>'
            : '<path d="M6 5h4v14H6z"/><path d="M14 5h4v14h-4z"/>';
        }
      }

      function nudgeVideo(dt) {
        if (!Number.isFinite(videoEl.duration)) return;
        const next = Math.max(0, Math.min(videoEl.duration || 0, (videoEl.currentTime || 0) + dt));
        videoEl.currentTime = next;
        updateTransportUI();
      }

      async function applyVideoCutRange() {
        if (!currentJobId) {
          showToast('Render a video first.', 'err');
          return;
        }
        const start = Number(cutStartSec);
        const end = Number(cutEndSec);
        if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
          showToast('Set IN and OUT marks first.', 'err');
          return;
        }
        setBusy(true, `Cutting ${fmtTime(start)} -> ${fmtTime(end)}`, 'Editing');
        if (applyCutRangeBtn) applyCutRangeBtn.disabled = true;
        try {
          const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/cut-range`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ start_sec: start, end_sec: end }),
          });
          const data = await parseApiResponse(resp, 'Cut range failed.');
          if (!data.ok) {
            showToast(data.error || 'Cut range failed.', 'err');
            if (data.logs) logsEl.textContent = String(data.logs);
            return;
          }
          if (data.video_path) {
            const src = '/' + data.video_path + '?t=' + Date.now();
            lastVideoUrl = src;
            videoEl.src = src;
            videoEl.load();
            setVideoAvailable(true);
            addRenderToDeck({
              job_id: currentJobId,
              video_path: data.video_path,
              appended_from: currentJobId,
            });
          }
          if (data.plan && Array.isArray(data.plan.scenes)) {
            timelineMeta.title = data.plan.title || timelineMeta.title || 'Scene Plan';
            timelineState = data.plan.scenes.map((sc) => ({
              seconds: Math.max(1, Number(sc.seconds || 1)),
              goal: sc.goal || 'Scene',
              elements: Array.isArray(sc.elements) ? sc.elements : [],
              actions: Array.isArray(sc.actions) ? sc.actions : [],
              narration: sc.narration || '',
              assets: sc.assets || {},
            }));
            renderTimeline();
            currentPlanText = JSON.stringify(data.plan, null, 2);
            if (lastPlanBox) lastPlanBox.value = currentPlanText;
          }
          if (data.job_files) updateJobFiles(data.job_files);
          cutStartSec = null;
          cutEndSec = null;
          updateCutRangeLabel();
          updateOutputPaths();
          pushHistory(`Removed ${fmtTime(start)}-${fmtTime(end)} from ${currentJobId}`);
          showToast('Range removed.', 'ok');
        } catch {
          showToast('Cut request failed.', 'err');
        } finally {
          setBusy(false);
          if (applyCutRangeBtn) applyCutRangeBtn.disabled = false;
        }
      }

      if (playPauseBtn) {
        playPauseBtn.addEventListener('click', async () => {
          if (!videoEl.src) return;
          try {
            if (videoEl.paused) await videoEl.play();
            else videoEl.pause();
          } catch {}
          updateTransportUI();
        });
      }
      if (rew5Btn) rew5Btn.addEventListener('click', () => nudgeVideo(-5));
      if (ff5Btn) ff5Btn.addEventListener('click', () => nudgeVideo(5));
      if (rew10Btn) rew10Btn.addEventListener('click', () => nudgeVideo(-10));
      if (ff10Btn) ff10Btn.addEventListener('click', () => nudgeVideo(10));
      safeOn(setCutStartBtn, 'click', () => {
        cutStartSec = Number(videoEl.currentTime || 0);
        if (cutEndSec != null && cutEndSec < cutStartSec) cutEndSec = null;
        updateCutRangeLabel();
      });
      safeOn(setCutEndBtn, 'click', () => {
        cutEndSec = Number(videoEl.currentTime || 0);
        if (cutStartSec != null && cutEndSec < cutStartSec) {
          const tmp = cutStartSec;
          cutStartSec = cutEndSec;
          cutEndSec = tmp;
        }
        updateCutRangeLabel();
      });
      safeOn(clearCutRangeBtn, 'click', () => {
        cutStartSec = null;
        cutEndSec = null;
        updateCutRangeLabel();
      });
      safeOn(applyCutRangeBtn, 'click', applyVideoCutRange);
      safeOn(timelineHideBtnEl, 'click', () => setTimelineHidden(!timelineHidden));
      safeOn(toggleTimelineBtnEl, 'click', () => setTimelineHidden(!timelineHidden));
      videoEl.addEventListener('loadedmetadata', updateTransportUI);
      videoEl.addEventListener('play', updateTransportUI);
      videoEl.addEventListener('pause', updateTransportUI);

      downloadBtnEl.addEventListener('click', () => {
        if (!lastVideoUrl) return;
        const a = document.createElement('a');
        a.href = lastVideoUrl;
        a.download = currentJobId ? `${currentJobId}.mp4` : 'out.mp4';
        document.body.appendChild(a);
        a.click();
        a.remove();
        showToast('Downloading video', 'ok');
        if (currentJobId) pushHistory(`Downloaded ${currentJobId}.mp4`);
      });
      if (exportBtnEl) {
        exportBtnEl.addEventListener('click', () => {
          if (!currentJobId) {
            showToast('Nothing to export yet.', 'err');
            return;
          }
          window.open(`/api/jobs/${encodeURIComponent(currentJobId)}/download`, '_blank');
        });
      }
      if (ccBtnEl) {
        ccBtnEl.addEventListener('click', () => {
          if (!lastCaptionsUrl) {
            showToast('No captions yet.', 'err');
            return;
          }
          window.open(lastCaptionsUrl, '_blank');
        });
      }
      shareBtnEl.addEventListener('click', async () => {
        if (!lastVideoUrl) return;
        try {
          if (navigator.share) {
            await navigator.share({ title: 'NorthStar', url: lastVideoUrl });
          } else if (navigator.clipboard) {
            await navigator.clipboard.writeText(lastVideoUrl);
            statusEl.textContent = 'Copied video link to clipboard.';
            showToast('Copied video link.', 'ok');
          } else {
            statusEl.textContent = 'Sharing not supported in this browser.';
            showToast('Sharing not supported in this browser.', 'err');
          }
        } catch (e) {
          statusEl.textContent = 'Share cancelled.';
          showToast('Share cancelled.', 'err');
        }
      });
      if (snapshotBtnEl) {
        snapshotBtnEl.addEventListener('click', async () => {
          if (!videoEl.src || !currentJobId) return;
          const vw = videoEl.videoWidth || 1080;
          const vh = videoEl.videoHeight || 1920;
          if (!vw || !vh) {
            showToast('Wait until video metadata is loaded, then capture.', 'err');
            return;
          }
          const canvas = document.createElement('canvas');
          canvas.width = vw;
          canvas.height = vh;
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            showToast('Could not create canvas.', 'err');
            return;
          }
          ctx.drawImage(videoEl, 0, 0, vw, vh);
          const dataUrl = canvas.toDataURL('image/png');
          const base64 = dataUrl.split(',', 2)[1] || '';
          try {
            const resp = await fetch('/api/jobs/upload-asset', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                job_id: currentJobId,
                filename: `snapshot-${Date.now()}.png`,
                content_base64: base64,
                role: 'foreground'
              })
            });
            const out = await resp.json();
            const rel = out.ok ? out.asset_path : '';
            const src = rel ? `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}` : dataUrl;
            const bubble = document.createElement('div');
            bubble.innerHTML = `<img src=\"${src}\" alt=\"Snapshot\" style=\"max-width:240px; border-radius:12px; border:1px solid rgba(255,255,255,0.12);\" />`;
            addChat('agent', 'Snapshot', 'Captured current frame.', bubble);
            const a = document.createElement('a');
            a.href = src;
            a.download = `${currentJobId}-snapshot.png`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            showToast('Snapshot captured.', 'ok');
            pushHistory(`Captured snapshot for ${currentJobId}`);
            await loadWorkspaceFiles();
          } catch {
            showToast('Snapshot upload failed.', 'err');
          }
        });
      }
      if (voiceoverBtnEl) {
        voiceoverBtnEl.addEventListener('click', () => {
          if (!currentJobId) {
            showToast('Render a video first.', 'err');
            return;
          }
          if (!voiceoverPanelEl) return;
          const open = voiceoverPanelEl.classList.contains('hidden');
          voiceoverPanelEl.classList.toggle('hidden', !open);
          voiceoverPanelEl.setAttribute('aria-hidden', open ? 'false' : 'true');
          if (open && voiceoverScriptEl && !voiceoverScriptEl.value.trim()) {
            voiceoverScriptEl.value = '';
          }
        });
      }
      safeOn(closeVoiceoverPanelEl, 'click', () => {
        if (!voiceoverPanelEl) return;
        voiceoverPanelEl.classList.add('hidden');
        voiceoverPanelEl.setAttribute('aria-hidden', 'true');
      });
      safeOn(voiceoverApplyEl, 'click', async () => {
        if (!currentJobId) {
          showToast('Render a video first.', 'err');
          return;
        }
        if (voiceoverApplyEl) voiceoverApplyEl.disabled = true;
        setBusy(true, 'Adding voiceover', 'Voiceover');
        try {
          const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/voiceover`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              voice_id: voiceoverVoiceSelectEl ? (voiceoverVoiceSelectEl.value || null) : null,
              model_id: voiceoverModelSelectEl ? (voiceoverModelSelectEl.value || null) : null,
              script_text: voiceoverScriptEl ? (voiceoverScriptEl.value || null) : null,
              use_gemini_script: !!(voiceoverUseGeminiEl && voiceoverUseGeminiEl.checked),
              include_chat_context: !!(voiceoverUseContextEl && voiceoverUseContextEl.checked),
              chat_context: buildNarrationContext(),
            }),
          });
          const data = await resp.json();
          if (!data.ok) {
            showToast(data.error || 'Voiceover failed.', 'err');
            return;
          }
          if (data.video_path) {
            const src = '/' + data.video_path + '?t=' + Date.now();
            lastVideoUrl = src;
            videoEl.src = src;
            videoEl.load();
            setVideoAvailable(true);
          }
          if (data.job_files) updateJobFiles(data.job_files);
          if (voiceoverPanelEl) {
            voiceoverPanelEl.classList.add('hidden');
            voiceoverPanelEl.setAttribute('aria-hidden', 'true');
          }
          showToast('Voiceover added.', 'ok');
          pushHistory(`Added voiceover to ${currentJobId}`);
        } catch {
          showToast('Voiceover request failed.', 'err');
        } finally {
          setBusy(false);
          if (voiceoverApplyEl) voiceoverApplyEl.disabled = false;
          if (voiceoverBtnEl) voiceoverBtnEl.disabled = false;
        }
      });
      function selectedPackLanguages() {
        const langs = [];
        if (langEnEl && langEnEl.checked) langs.push('en');
        if (langHiEl && langHiEl.checked) langs.push('hi');
        if (langEsEl && langEsEl.checked) langs.push('es');
        if (!langs.length) langs.push('en');
        return langs;
      }
      async function generateScriptPacks() {
        if (!currentJobId) {
          showToast('Render a video first.', 'err');
          return;
        }
        if (scriptPackBtnEl) scriptPackBtnEl.disabled = true;
        if (scriptPackOverlayBtnEl) scriptPackOverlayBtnEl.disabled = true;
        if (scriptPackStatusEl) scriptPackStatusEl.textContent = 'Generating multilingual packs';
        setBusy(true, 'Generating script packs', 'Narration');
        try {
          const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/script-packs`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              languages: selectedPackLanguages(),
              model: chatModelEl ? (chatModelEl.value || null) : null,
            }),
          });
          const data = await resp.json();
          if (!data.ok) {
            showToast(data.error || 'Script pack generation failed.', 'err');
            if (scriptPackStatusEl) scriptPackStatusEl.textContent = data.error || 'Script pack generation failed.';
            return;
          }
          const packs = Array.isArray(data.packs) ? data.packs : [];
          if (scriptPackStatusEl) scriptPackStatusEl.textContent = `Ready: ${packs.length} language pack(s).`;
          if (data.job_files) updateJobFiles(data.job_files);
          const wrap = document.createElement('div');
          const ul = document.createElement('ul');
          ul.style.margin = '0';
          ul.style.paddingLeft = '18px';
          packs.forEach((p) => {
            const li = document.createElement('li');
            li.textContent = `${p.language_label || p.language}: ${p.script_path} + ${p.captions_path}`;
            ul.appendChild(li);
          });
          wrap.appendChild(ul);
          addChat('agent', 'Multilingual packs', 'Generated narration + captions.', wrap);
          pushHistory(`Generated script packs for ${currentJobId}`);
          showToast('Script packs ready.', 'ok');
        } catch {
          showToast('Script pack request failed.', 'err');
          if (scriptPackStatusEl) scriptPackStatusEl.textContent = 'Script pack request failed.';
        } finally {
          setBusy(false);
          if (scriptPackBtnEl) scriptPackBtnEl.disabled = false;
          setVideoAvailable(!!lastVideoUrl);
        }
      }
      safeOn(scriptPackBtnEl, 'click', generateScriptPacks);
      safeOn(scriptPackOverlayBtnEl, 'click', () => {
        if (voiceoverPanelEl && voiceoverPanelEl.classList.contains('hidden')) {
          voiceoverPanelEl.classList.remove('hidden');
          voiceoverPanelEl.setAttribute('aria-hidden', 'false');
        }
        generateScriptPacks();
      });
      if (appendBtnEl) {
        appendBtnEl.addEventListener('click', () => {
          if (!currentJobId || !lastVideoUrl) {
            showToast('Render a video first.', 'err');
            return;
          }
          appendFromJobId = currentJobId;
          statusEl.textContent = 'Append mode: describe the next scene, then Create plan.';
          chatInputEl.focus();
          if (!targetSecondsEl.value.trim()) targetSecondsEl.value = '20';
          if (!chatInputEl.value.trim()) {
            chatInputEl.value = 'Continue with the next scene for 20 seconds: ';
          }
          showToast('Append mode enabled. Create the next scene.', 'ok');
        });
      }
      if (deckPrevBtn) {
        deckPrevBtn.addEventListener('click', () => {
          if (!renderDeck.length) return;
          setActiveDeckIndex(activeDeckIndex - 1);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        });
      }
      if (deckNextBtn) {
        deckNextBtn.addEventListener('click', () => {
          if (!renderDeck.length) return;
          setActiveDeckIndex(activeDeckIndex + 1);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        });
      }
      if (deckTrackEl) {
        deckTrackEl.addEventListener('wheel', (e) => {
          if (!renderDeck.length) return;
          e.preventDefault();
          const dir = (Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY) > 0 ? 1 : -1;
          setActiveDeckIndex(activeDeckIndex + dir);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        }, { passive: false });
      }

      let templates = [];
      let currentJobId = null;
      let appendFromJobId = null;
      let lastHealthData = null;
      let lastPreflightData = null;
      let currentPlanText = null;
      let lastPlanBox = null;
      let timelineState = [];
      let timelineMeta = { title: 'Scene Plan' };
      let timelineHidden = false;
      let cutStartSec = null;
      let cutEndSec = null;
      let openFilePath = null;
      let openFileContent = '';
      let pendingRenameFrom = null;
      let pendingRenameKind = '';
      let lastAssets = { background: '', foreground: '' };
      const editorTabsState = [];
      let activeEditorTabId = 'generated';
      const historyActions = [];
      let terminalMode = false;
      const mqNarrow = window.matchMedia('(max-width: 1200px)');
      let jobEventSource = null;
      let didAnimateCode = false;
      let persistedSceneSignature = '';
      let lastGeneratedCodePath = '';
      let selectedTreePath = '';
      let selectedTreeKind = '';
      let skillsCache = [];
      let selectedSkillIdSet = new Set();
      let directorBriefTrimAt = 0;
      const renderNoticeByJob = new Set();
      let lastChatSignature = '';
      const SESSION_COLORS = ['#6aa9ff', '#22c55e', '#f59e0b', '#c084fc', '#fb7185', '#14b8a6'];
      const PHYSICS_IMAGE_PRESETS = [
        {
          id: 'matte_black_stage',
          name: 'Matte black explainer stage',
          prompt: 'Matte black cinematic background, soft vignette, subtle texture, high contrast, no logo watermark',
        },
        {
          id: 'photoelectric_lab',
          name: 'Photoelectric lab',
          prompt: 'Minimal quantum lab set, clean metal surface, incoming light beam setup, moody cinematic lighting',
        },
        {
          id: 'red_blue_compare',
          name: 'Red vs blue comparison',
          prompt: 'Split-frame educational background: red light low-energy side versus blue light high-energy side, clean labels area',
        },
        {
          id: 'wave_optics',
          name: 'Wave optics',
          prompt: 'Dark optical bench with lens, diffraction slits, and wavefront glow trails, scientific cinematic style',
        },
        {
          id: 'relativity_spacetime',
          name: 'Relativity spacetime',
          prompt: 'Stylized spacetime grid curvature, starfield depth, elegant educational composition, high readability',
        },
        {
          id: 'entropy_microstates',
          name: 'Entropy and microstates',
          prompt: 'Abstract particles transitioning from order to disorder, smooth gradient science backdrop, clear center space',
        },
        {
          id: 'equation_card',
          name: 'Equation card',
          prompt: 'Clean high-contrast equation card with dark matte background and crisp white typography, centered card layout',
        },
        {
          id: 'tdx_card',
          name: 'TDX concept card',
          prompt: 'Educational card layout showing term-definition-example blocks, minimal icons, readable typography, dark theme',
        },
        {
          id: 'avatar_teacher',
          name: 'Scientist explainer avatar',
          prompt: 'Waist-up scientist explainer avatar, expressive but calm, looking toward camera, studio rim lighting',
        },
        {
          id: 'graph_stage',
          name: 'Graph stage',
          prompt: 'Minimal coordinate graph stage with safe margins for overlays, clean technical look, subtle glow accents',
        },
      ];
      const PHYSICS_PROMPT_PACK = [
        'Photoelectric effect setup, matte black lab background, threshold frequency visual focus.',
        'Red light vs blue light comparison frame, one side no emission, one side electron emission.',
        'Einstein photon collision analogy, single electron release, elegant cinematic physics style.',
        'K_max = h f - phi equation card with crisp typography and strong contrast.',
        'Threshold frequency graph scene with f0 marker and linear K_max rise above threshold.',
        'Wave optics lens + diffraction apparatus, clean rays and minimal clutter.',
        'Relativity spacetime curvature visual with clear focal object and labels-safe center.',
        'Entropy order-to-disorder particle transition backdrop for teaching thermodynamics.',
        'Electromagnetic spectrum strip with UV-visible-IR emphasis and educational readability.',
        'Quantum energy level ladder card with transitions and highlighted emitted photons.',
      ];
      let chatSessions = [];
      let activeChatSessionId = '';
      const stepNotes = {
        plan: 'No plan yet.',
        approve: 'Waiting for approval.',
        code: 'Code has not started.',
        render: 'Render has not started.',
      };
      const defaultStepNotes = {
        plan: 'No plan yet.',
        approve: 'Waiting for approval.',
        code: 'Code has not started.',
        render: 'Render has not started.',
      };

      const AUTOSAVE_KEY = 'gmma_autosave_v1';
      const WELCOME_SEEN_KEY = 'northstar.welcome_seen.v1';
      const FIRST60_HIDE_KEY = 'northstar.first60_hide.v1';
      const TOUR_SEEN_KEY = 'northstar.tour_seen.v2';
      const DEFAULT_ONBOARDING = {
        intro_title: 'NorthStar quick tour',
        intro_body: 'Follow these steps to go from prompt to cinematic explainer.',
        outro_title: 'You are ready to create',
        outro_body: 'Press Create plan, generate assets, approve, and render your first video.',
        steps: [
          {
            title: 'Choose a starter template',
            body: 'Pick a template in Explorer to load style and scene defaults quickly.',
            hint: 'Left panel -> Template',
            target: '#templateSelect',
            icon_prompt: 'Template icon dark ui',
            icon_url: '',
          },
          {
            title: 'Write the core prompt',
            body: 'Describe the concept in one line so Gemini can generate a precise scene plan.',
            hint: 'Right panel -> Prompt',
            target: '#chatInput',
            icon_prompt: 'Prompt input icon dark ui',
            icon_url: '',
          },
          {
            title: 'Generate image assets',
            body: 'Create Nano Banana variants, then drag chosen assets into scene cards on timeline.',
            hint: 'Middle panel -> Images',
            target: '#imageGenDetails',
            icon_prompt: 'Image variation icon dark ui',
            icon_url: '',
          },
          {
            title: 'Refine scene timeline',
            body: 'Keep each scene focused on one idea and tune durations before rendering.',
            hint: 'Middle panel -> Timeline',
            target: '#timelineTrack',
            icon_prompt: 'Timeline scene card icon dark ui',
            icon_url: '',
          },
          {
            title: 'Approve and render',
            body: 'Run plan, code, and render. Gemini can diagnose failures and retry once.',
            hint: 'Middle panel -> Preview',
            target: '#previewSlot',
            icon_prompt: 'Render pipeline icon dark ui',
            icon_url: '',
          },
          {
            title: 'Track phases clearly',
            body: 'Use step badges to inspect Plan, Approve, Code, and Render progress in order.',
            hint: 'Right panel -> Step tracker',
            target: '#agentSteps',
            icon_prompt: 'Progress stage icon dark ui',
            icon_url: '',
          },
        ],
      };
      let autosaveTimer = null;
      let pendingRestore = null;
      let onboardingData = JSON.parse(JSON.stringify(DEFAULT_ONBOARDING));
      let onboardingIndex = 0;
      let onboardingLoading = false;
      let onboardingFetched = false;

      function updateSliderReadout(inputEl, readoutEl) {
        if (!inputEl || !readoutEl) return;
        const v = Math.max(0, Math.min(100, Number(inputEl.value || 0)));
        readoutEl.textContent = `${Math.round(v)} / 100`;
      }

      function refreshCreativeReadouts() {
        updateSliderReadout(creativeMotionEl, creativeMotionReadoutEl);
        updateSliderReadout(creativeDensityEl, creativeDensityReadoutEl);
        updateSliderReadout(creativeEnergyEl, creativeEnergyReadoutEl);
        updateSliderReadout(creativeComplexityEl, creativeComplexityReadoutEl);
        updateSliderReadout(creativePolishEl, creativePolishReadoutEl);
        updateSliderReadout(creativePrecisionEl, creativePrecisionReadoutEl);
      }

      function applyImagePreset(presetId, announce = false) {
        if (!imagePresetEl || !imagePromptEl) return;
        const preset = PHYSICS_IMAGE_PRESETS.find((p) => p.id === presetId);
        if (!preset) return;
        imagePresetEl.value = preset.id;
        imagePromptEl.value = preset.prompt;
        if (imageAssetTypeEl) {
          if (preset.id === 'equation_card') imageAssetTypeEl.value = 'equation_card';
          else if (preset.id === 'tdx_card') imageAssetTypeEl.value = 'tdx_card';
          else if (preset.id === 'avatar_teacher') imageAssetTypeEl.value = 'explanation_avatar';
          else imageAssetTypeEl.value = 'cinematic_background';
        }
        if (announce) showToast(`Loaded preset: ${preset.name}`, 'ok');
        scheduleAutosave();
      }

      function initImagePresetControls() {
        if (imagePresetEl) {
          imagePresetEl.innerHTML = '';
          PHYSICS_IMAGE_PRESETS.forEach((preset) => {
            const opt = document.createElement('option');
            opt.value = preset.id;
            opt.textContent = preset.name;
            imagePresetEl.appendChild(opt);
          });
          if (!imagePresetEl.value) imagePresetEl.value = PHYSICS_IMAGE_PRESETS[0].id;
        }
        if (imagePromptPackEl) {
          imagePromptPackEl.innerHTML = '';
          PHYSICS_PROMPT_PACK.forEach((prompt, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'prompt-chip';
            btn.textContent = `Physics ${idx + 1}`;
            btn.title = prompt;
            btn.addEventListener('click', () => {
              if (imagePromptEl) imagePromptEl.value = prompt;
              if (imagePresetEl) imagePresetEl.value = 'photoelectric_lab';
              showToast(`Loaded physics prompt ${idx + 1}.`, 'ok');
              scheduleAutosave();
            });
            imagePromptPackEl.appendChild(btn);
          });
        }
      }

      function buildImagePrompt() {
        const presetId = imagePresetEl?.value || '';
        const preset = PHYSICS_IMAGE_PRESETS.find((p) => p.id === presetId);
        const basePrompt = String(imagePromptEl?.value || '').trim() || String(preset?.prompt || '').trim();
        const minorEdit = String(imageMinorEditEl?.value || '').trim();
        const assetType = String(imageAssetTypeEl?.value || 'cinematic_background').trim();
        const styleHints = [
          'Physics education visual style.',
          'High readability, safe margins, no watermarks, no clutter.',
          'Keep composition clean for timeline overlays and captions.',
        ];
        const typeHints = {
          cinematic_background: 'Full-frame cinematic background plate. Keep center area clear for labels.',
          explanation_avatar: 'Single explainer avatar asset, clear silhouette, expressive face, educational tone.',
          equation_card: 'Render a crisp equation card with legible typography and strong contrast. Keep equation centered.',
          tdx_card: 'Render a TDX card: clear term, short definition, and one example block with readable structure.',
          concept_diagram: 'Render a concise concept diagram panel with one core mechanism and minimal text.',
        };

        const pieces = [];
        if (basePrompt) pieces.push(basePrompt);
        pieces.push(typeHints[assetType] || typeHints.cinematic_background);
        if (minorEdit) pieces.push(`Minor edits: ${minorEdit}`);
        pieces.push(styleHints.join(' '));
        return pieces.join('\n');
      }

      function snapshotProject() {
        return {
          v: 1,
          saved_at: new Date().toISOString(),
          template_id: templateSelectEl?.value || '',
          prompt: chatInputEl?.value || '',
          chat_model: chatModelEl?.value || '',
          director_brief: directorBriefEl?.value || '',
          rules_text: rulesTextEl?.value || '',
          subagents_text: subagentsTextEl?.value || '',
          controls: {
            gemini_assist: !!(geminiAssistEl && geminiAssistEl.checked),
            crazy_mode: !!(crazyModeEl && crazyModeEl.checked),
            timeline_hidden: !!timelineHidden,
            include_images: includeImagesEl?.value || 'true',
            image_prompt: imagePromptEl?.value || '',
            image_preset: imagePresetEl?.value || '',
            image_asset_type: imageAssetTypeEl?.value || 'cinematic_background',
            image_minor_edit: imageMinorEditEl?.value || '',
            image_mode: imageModeEl?.value || 'background',
            image_variants: imageVariantsEl?.value || '1',
            aspect: aspectEl?.value || '9:16',
            audience: audienceEl?.value || 'general',
            tone: toneEl?.value || 'epic',
            style: styleEl?.value || 'cinematic',
            pace: paceEl?.value || 'medium',
            palette: paletteEl?.value || 'cool',
            quality: qualityEl?.value || 'pqm',
            target_seconds: targetSecondsEl?.value || '',
            max_scenes: maxScenesEl?.value || '',
            max_objects: maxObjectsEl?.value || '',
            equations: equationsEl?.value || 'true',
            graphs: graphsEl?.value || 'true',
            narration: narrationEl?.value || 'true',
            image_model_override: imageModelOverrideEl?.value || '',
            creative_motion: creativeMotionEl?.value || '58',
            creative_density: creativeDensityEl?.value || '62',
            creative_energy: creativeEnergyEl?.value || '68',
            creative_complexity: creativeComplexityEl?.value || '54',
            creative_polish: creativePolishEl?.value || '72',
            creative_precision: creativePrecisionEl?.value || '66',
            vibe_enable: !!(vibeEnableEl && vibeEnableEl.checked),
            vibe_preset: vibePresetEl?.value || 'cinematic_science',
            orientation_guide: orientationGuideEl?.value || 'auto',
            vibe_title: vibeTitleEl?.value || '',
            vibe_caption_mode: vibeCaptionModeEl?.value || 'concise',
            vibe_text_anim: vibeTextAnimEl?.value || 'cinematic_fade',
            vibe_caption_anim: vibeCaptionAnimEl?.value || 'soft_fade',
            vibe_caption_position: vibeCaptionPositionEl?.value || 'lower_third',
            vibe_caption_density: vibeCaptionDensityEl?.value || 'balanced',
            vibe_overlay_strength: vibeOverlayStrengthEl?.value || '62',
            vibe_title_weight: vibeTitleWeightEl?.value || 'bold',
          },
          plan_text: currentPlanText || '',
          timeline: Array.isArray(timelineState) ? timelineState : [],
          code: codeEl?.value || '',
          chat_sessions: chatSessions,
          active_chat_session_id: activeChatSessionId,
        };
      }

      function saveProject(auto = false) {
        try {
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(snapshotProject()));
          if (!auto) showToast('Saved.', 'ok');
        } catch {
          if (!auto) showToast('Save failed (storage blocked).', 'err');
        }
      }

      function scheduleAutosave() {
        clearTimeout(autosaveTimer);
        autosaveTimer = setTimeout(() => saveProject(true), 500);
      }

      function restoreProject() {
        let raw = '';
        try { raw = localStorage.getItem(AUTOSAVE_KEY) || ''; } catch { raw = ''; }
        if (!raw) return false;
        let snap = null;
        try { snap = JSON.parse(raw); } catch { snap = null; }
        if (!snap || snap.v !== 1) return false;

        pendingRestore = snap;
        // Apply what we can immediately (templates load async).
        if (snap.prompt && chatInputEl) chatInputEl.value = snap.prompt;
        if (snap.chat_model && chatModelEl) chatModelEl.value = snap.chat_model;
        if (snap.director_brief && directorBriefEl) directorBriefEl.value = snap.director_brief;
        if (snap.rules_text && rulesTextEl) rulesTextEl.value = snap.rules_text;
        if (snap.subagents_text && subagentsTextEl) subagentsTextEl.value = snap.subagents_text;
        const c = snap.controls || {};
        if (geminiAssistEl && c.gemini_assist !== undefined) geminiAssistEl.checked = !!c.gemini_assist;
        if (crazyModeEl && c.crazy_mode !== undefined) crazyModeEl.checked = !!c.crazy_mode;
        if (c.timeline_hidden !== undefined) setTimelineHidden(!!c.timeline_hidden, false);
        if (includeImagesEl && c.include_images) includeImagesEl.value = c.include_images;
        if (imagePromptEl && c.image_prompt) imagePromptEl.value = c.image_prompt;
        if (imagePresetEl && c.image_preset) imagePresetEl.value = c.image_preset;
        if (imageAssetTypeEl && c.image_asset_type) imageAssetTypeEl.value = c.image_asset_type;
        if (imageMinorEditEl && c.image_minor_edit !== undefined) imageMinorEditEl.value = c.image_minor_edit;
        if (imageModeEl && c.image_mode) imageModeEl.value = c.image_mode;
        if (imageVariantsEl && c.image_variants) imageVariantsEl.value = c.image_variants;
        if (aspectEl && c.aspect) { aspectEl.value = c.aspect; setPreviewAspect(c.aspect); }
        if (audienceEl && c.audience) audienceEl.value = c.audience;
        if (toneEl && c.tone) toneEl.value = c.tone;
        if (styleEl && c.style) styleEl.value = c.style;
        if (paceEl && c.pace) paceEl.value = c.pace;
        if (paletteEl && c.palette) paletteEl.value = c.palette;
        if (qualityEl && c.quality) qualityEl.value = c.quality;
        if (targetSecondsEl && c.target_seconds !== undefined) targetSecondsEl.value = c.target_seconds;
        if (maxScenesEl && c.max_scenes !== undefined) maxScenesEl.value = c.max_scenes;
        if (maxObjectsEl && c.max_objects !== undefined) maxObjectsEl.value = c.max_objects;
        if (equationsEl && c.equations) equationsEl.value = c.equations;
        if (graphsEl && c.graphs) graphsEl.value = c.graphs;
        if (narrationEl && c.narration) narrationEl.value = c.narration;
        if (imageModelOverrideEl) imageModelOverrideEl.value = c.image_model_override || '';
        if (creativeMotionEl && c.creative_motion !== undefined) creativeMotionEl.value = c.creative_motion;
        if (creativeDensityEl && c.creative_density !== undefined) creativeDensityEl.value = c.creative_density;
        if (creativeEnergyEl && c.creative_energy !== undefined) creativeEnergyEl.value = c.creative_energy;
        if (creativeComplexityEl && c.creative_complexity !== undefined) creativeComplexityEl.value = c.creative_complexity;
        if (creativePolishEl && c.creative_polish !== undefined) creativePolishEl.value = c.creative_polish;
        if (creativePrecisionEl && c.creative_precision !== undefined) creativePrecisionEl.value = c.creative_precision;
        if (vibeEnableEl && c.vibe_enable !== undefined) vibeEnableEl.checked = !!c.vibe_enable;
        if (vibePresetEl && c.vibe_preset) vibePresetEl.value = c.vibe_preset;
        if (orientationGuideEl && c.orientation_guide) orientationGuideEl.value = c.orientation_guide;
        if (vibeTitleEl && c.vibe_title !== undefined) vibeTitleEl.value = c.vibe_title;
        if (vibeCaptionModeEl && c.vibe_caption_mode) vibeCaptionModeEl.value = c.vibe_caption_mode;
        if (vibeTextAnimEl && c.vibe_text_anim) vibeTextAnimEl.value = c.vibe_text_anim;
        if (vibeCaptionAnimEl && c.vibe_caption_anim) vibeCaptionAnimEl.value = c.vibe_caption_anim;
        if (vibeCaptionPositionEl && c.vibe_caption_position) vibeCaptionPositionEl.value = c.vibe_caption_position;
        if (vibeCaptionDensityEl && c.vibe_caption_density) vibeCaptionDensityEl.value = c.vibe_caption_density;
        if (vibeOverlayStrengthEl && c.vibe_overlay_strength !== undefined) vibeOverlayStrengthEl.value = c.vibe_overlay_strength;
        if (vibeTitleWeightEl && c.vibe_title_weight) vibeTitleWeightEl.value = c.vibe_title_weight;
        refreshCreativeReadouts();

        if (Array.isArray(snap.chat_sessions) && snap.chat_sessions.length) {
          chatSessions = snap.chat_sessions.map((s, i) => ({
            id: String(s.id || `chat-${i + 1}`),
            name: String(s.name || makeSessionName(i + 1)),
            color: String(s.color || SESSION_COLORS[i % SESSION_COLORS.length]),
            prompt: String(s.prompt || ''),
            model: String(s.model || (chatModelEl?.value || 'gemini-3-flash-preview')),
            messages_html: String(s.messages_html || ''),
            last_sig: String(s.last_sig || ''),
            context_lock: !!s.context_lock,
            job_id: String(s.job_id || ''),
            plan_text: String(s.plan_text || ''),
            timeline_state: Array.isArray(s.timeline_state) ? s.timeline_state : [],
            timeline_meta: s.timeline_meta || { title: 'Scene Plan' },
            video_url: String(s.video_url || ''),
            logs_text: String(s.logs_text || ''),
            job_files: Array.isArray(s.job_files) ? s.job_files : [],
            code_text: String(s.code_text || ''),
            step_states: s.step_states || { plan: '', approve: '', code: '', render: '' },
            step_notes: s.step_notes || { ...defaultStepNotes },
            phase: String(s.phase || 'idle'),
            created_at: Number(s.created_at || Date.now()),
            missing_checks: Number(s.missing_checks || 0),
            pending_delete: false,
          }));
          activeChatSessionId = String(snap.active_chat_session_id || chatSessions[0].id);
          if (!chatSessions.some((s) => s.id === activeChatSessionId)) {
            activeChatSessionId = chatSessions[0].id;
          }
          restoreSessionState(getActiveChatSession());
          renderChatSessions();
        }

        if (snap.plan_text) currentPlanText = snap.plan_text;
        if (Array.isArray(snap.timeline)) { timelineState = snap.timeline; renderTimeline(); }
        if (typeof snap.code === 'string') { codeEl.value = snap.code; refreshGutter(); if (highlightOn) refreshHighlight(); }
        syncComposeModeChips();
        return true;
      }

      function pushHistory(action) {
        const txt = String(action || '').trim();
        if (!txt) return;
        const stamp = new Date();
        const hh = String(stamp.getHours()).padStart(2, '0');
        const mm = String(stamp.getMinutes()).padStart(2, '0');
        historyActions.unshift(`${hh}:${mm}  ${txt}`);
        if (historyActions.length > 3) historyActions.length = 3;
        renderHistory();
      }

      function renderHistory() {
        if (!historyListEl) return;
        if (!historyActions.length) {
          historyListEl.innerHTML = '<div class="muted">No actions yet.</div>';
          return;
        }
        historyListEl.innerHTML = '';
        historyActions.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'tree-file';
          row.textContent = item;
          historyListEl.appendChild(row);
        });
      }

      function fileBaseName(path) {
        const p = String(path || '');
        const bits = p.split('/');
        return bits[bits.length - 1] || p || 'untitled.py';
      }

      function ensureGeneratedTab() {
        if (editorTabsState.some((t) => t.id === 'generated')) return;
        editorTabsState.push({
          id: 'generated',
          path: null,
          label: 'generated.py',
          content: codeEl.value || '',
          generated: true,
        });
      }

      function getActiveEditorTab() {
        return editorTabsState.find((t) => t.id === activeEditorTabId) || null;
      }

      function syncCurrentEditorIntoActiveTab() {
        const tab = getActiveEditorTab();
        if (!tab) return;
        tab.content = codeEl.value || '';
      }

      function applyActiveEditorTab() {
        const tab = getActiveEditorTab();
        if (!tab) return;
        codeEl.value = tab.content || '';
        refreshGutter();
        if (highlightOn) refreshHighlight();
        openFilePath = tab.path || null;
        openFileContent = codeEl.value || '';
        updateEditorMode();
      }

      function renderEditorTabs() {
        if (!editorTabsEl) return;
        ensureGeneratedTab();
        editorTabsEl.innerHTML = '';
        editorTabsState.forEach((tab) => {
          const el = document.createElement('div');
          el.className = `editor-tab ${tab.id === activeEditorTabId ? 'active' : ''}`;
          el.dataset.id = tab.id;

          const name = document.createElement('div');
          name.className = 'editor-tab-name';
          name.textContent = tab.label || 'untitled.py';
          name.title = tab.path || tab.label || '';
          name.addEventListener('click', () => {
            syncCurrentEditorIntoActiveTab();
            activeEditorTabId = tab.id;
            applyActiveEditorTab();
            renderEditorTabs();
          });
          el.appendChild(name);

          if (!tab.generated) {
            const close = document.createElement('button');
            close.className = 'editor-tab-close';
            close.title = 'Close tab';
            close.setAttribute('aria-label', `Close ${tab.label}`);
            close.textContent = '';
            close.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = editorTabsState.findIndex((x) => x.id === tab.id);
              if (idx >= 0) editorTabsState.splice(idx, 1);
              if (activeEditorTabId === tab.id) {
                activeEditorTabId = (editorTabsState[idx - 1] || editorTabsState[idx] || editorTabsState[0] || { id: 'generated' }).id;
              }
              ensureGeneratedTab();
              applyActiveEditorTab();
              renderEditorTabs();
            });
            el.appendChild(close);
          }

          editorTabsEl.appendChild(el);
        });
      }

      function upsertFileTab(path, content, activate = true) {
        const p = String(path || '');
        if (!p) return;
        let tab = editorTabsState.find((t) => t.path === p);
        if (!tab) {
          tab = {
            id: `file:${p}`,
            path: p,
            label: fileBaseName(p),
            content: String(content || ''),
            generated: false,
          };
          editorTabsState.push(tab);
        } else if (typeof content === 'string') {
          tab.content = content;
        }
        if (activate) {
          activeEditorTabId = tab.id;
          applyActiveEditorTab();
        }
        renderEditorTabs();
      }

      function upsertGeneratedTab(content) {
        ensureGeneratedTab();
        const tab = editorTabsState.find((t) => t.id === 'generated');
        if (!tab) return;
        tab.content = String(content || '');
        tab.label = 'generated.py';
        if (activeEditorTabId === 'generated') applyActiveEditorTab();
        renderEditorTabs();
      }

      async function createNewCodeTabFile() {
        let i = 1;
        while (i < 500) {
          const name = `notes/new_scene_${i}.py`;
          try {
            const resp = await fetch('/api/files/file', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: name, content: '' })
            });
            const data = await resp.json();
            if (data.ok && data.path) {
              await loadWorkspaceFiles();
              await openWorkspaceFile(data.path);
              startRename(data.path, 'file');
              pushHistory(`Created ${data.path}`);
              return;
            }
          } catch {}
          i += 1;
        }
        showToast('Could not create a new code file.', 'err');
      }

      function getSources() {
        try {
          const raw = JSON.parse(localStorage.getItem('sources') || '[]');
          const clean = Array.isArray(raw) ? raw.map(normalizeSourceRecord) : [];
          if (Array.isArray(raw) && raw.some((x) => !x?.id || !x?.kind || !x?.saved_at)) {
            localStorage.setItem('sources', JSON.stringify(clean));
          }
          return clean;
        } catch {
          return [];
        }
      }
      function setSources(sources) {
        const clean = (Array.isArray(sources) ? sources : []).map(normalizeSourceRecord);
        localStorage.setItem('sources', JSON.stringify(clean));
      }

      function normalizeSourceRecord(src) {
        const s = src || {};
        const kind = String(s.kind || s.source_type || (s.video_id ? 'youtube' : 'web')).toLowerCase();
        const id = String(s.id || `src-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`);
        const title = cleanInline(s.title || '') || compactLabel(s.url || 'Source', 56);
        const summary = cleanInline(s.summary || s.notes || '');
        const promptHint = cleanInline(s.prompt_hint || s.promptHint || '');
        const notes = String(s.notes || '').trim();
        const keyPoints = Array.isArray(s.key_points)
          ? s.key_points.map((x) => cleanInline(x)).filter(Boolean).slice(0, 12)
          : [];
        const filePath = String(s.file_path || '').trim();
        return {
          ...s,
          id,
          kind: kind === 'youtube' ? 'youtube' : 'web',
          title,
          summary,
          prompt_hint: promptHint,
          notes,
          key_points: keyPoints,
          file_path: filePath,
          saved_at: s.saved_at || new Date().toISOString(),
        };
      }

      function extractYouTubeIdFromUrl(url) {
        const raw = String(url || '').trim();
        if (!raw) return '';
        try {
          const u = new URL(raw);
          if (u.hostname.includes('youtu.be')) {
            return u.pathname.replace(/^\/+/, '').split('/')[0] || '';
          }
          if (u.searchParams.get('v')) return String(u.searchParams.get('v') || '');
          const m = u.pathname.match(/\/shorts\/([A-Za-z0-9_-]+)/);
          if (m) return m[1];
          return '';
        } catch {
          return '';
        }
      }

      function buildYoutubeFallbackSource(url, notes) {
        const videoId = extractYouTubeIdFromUrl(url);
        const title = videoId ? `YouTube source (${videoId})` : 'YouTube source';
        const cleanNotes = cleanInline(notes || '');
        const summary = cleanNotes || 'Transcript unavailable. Add key points in Notes and re-index for a stronger summary.';
        return normalizeSourceRecord({
          id: `src-yt-fallback-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          kind: 'youtube',
          source_type: 'youtube',
          video_id: videoId,
          url,
          title,
          summary,
          notes: String(notes || '').trim(),
          key_points: cleanNotes ? [cleanNotes] : ['Transcript unavailable; summary was created from URL and notes only.'],
          prompt_hint: 'Use this source cautiously and mark assumptions if transcript is unavailable.',
          saved_at: new Date().toISOString(),
        });
      }

      function upsertSource(source) {
        const normalized = normalizeSourceRecord(source);
        const next = [normalized];
        getSources().forEach((item) => {
          if (item.id === normalized.id) return;
          if (normalized.url && item.url && normalized.url === item.url) return;
          next.push(item);
        });
        setSources(next.slice(0, 30));
      }

      function sourceSnippet(src) {
        const s = normalizeSourceRecord(src);
        const parts = [];
        parts.push(`[Indexed source: ${s.kind}] ${s.title || s.url || 'source'}`);
        if (s.video_id) parts.push(`YouTube ID: ${s.video_id}`);
        if (s.file_path) parts.push(`Workspace file: ${s.file_path}`);
        if (s.url) parts.push(`URL: ${s.url}`);
        if (s.summary) parts.push(`Summary: ${s.summary}`);
        const points = Array.isArray(s.key_points) ? s.key_points.filter(Boolean).slice(0, 6) : [];
        if (points.length) {
          parts.push('Key points:');
          points.forEach((p) => parts.push(`- ${p}`));
        }
        if (s.prompt_hint) parts.push(`Prompt hint: ${s.prompt_hint}`);
        if (s.notes) parts.push(`Notes: ${s.notes.slice(0, 400)}`);
        return parts.join('\n');
      }

      function sourceTimelineNote(src) {
        const s = normalizeSourceRecord(src);
        const points = Array.isArray(s.key_points) ? s.key_points.slice(0, 3) : [];
        const lines = [`[Source] ${s.title || s.url || 'reference'}`];
        if (s.summary) lines.push(s.summary);
        if (points.length) {
          lines.push('Key points:');
          points.forEach((p) => lines.push(`- ${p}`));
        }
        if (s.prompt_hint) lines.push(`Prompt hint: ${s.prompt_hint}`);
        return lines.join('\n').slice(0, 1200);
      }

      function pickSceneIndexFromPlayback() {
        if (!Array.isArray(timelineState) || !timelineState.length) return -1;
        let t = 0;
        if (videoEl && Number.isFinite(Number(videoEl.currentTime || 0))) {
          t = Math.max(0, Number(videoEl.currentTime || 0));
        }
        let cursor = 0;
        for (let i = 0; i < timelineState.length; i++) {
          const dur = Math.max(1, Number(timelineState[i]?.seconds || 1));
          if (t <= cursor + dur) return i;
          cursor += dur;
        }
        return timelineState.length - 1;
      }

      function applySourceNoteToScene(sceneIdx, noteText) {
        const idx = Number(sceneIdx);
        if (!Number.isInteger(idx) || idx < 0 || idx >= timelineState.length) return false;
        const note = String(noteText || '').trim();
        if (!note) return false;
        const scene = timelineState[idx];
        scene.narration = [scene.narration || '', note].filter(Boolean).join('\n');
        renderTimeline();
        scheduleAutosave();
        return true;
      }

      async function persistSourceSummaryFile(indexed) {
        if (!indexed || !indexed.markdown) return '';
        let path = indexed.file_suggested_path || `notes/sources/source-${Date.now()}.md`;
        let saved = await tryWriteWorkspaceFile(path, indexed.markdown);
        if (!saved) {
          for (let i = 2; i < 20 && !saved; i++) {
            const cand = path.replace(/(\.[^.]*)?$/, `-${i}$1`);
            saved = await tryWriteWorkspaceFile(cand, indexed.markdown);
          }
        }
        if (saved) await loadWorkspaceFiles();
        return saved || '';
      }

      function renderSources(opts = {}) {
        const preserveStatus = !!opts.preserveStatus;
        const sources = getSources();
        const statusKind = sourceStatusEl
          ? (['loading', 'warn', 'err', 'ok', 'muted'].find((k) => sourceStatusEl.classList.contains(k)) || 'muted')
          : 'muted';
        const canOverrideStatus = !preserveStatus && (statusKind === 'muted' || statusKind === 'ok');
        if (!sources.length) {
          if (canOverrideStatus) setSourceStatus('No sources yet.', 'muted');
          if (sourceCardsEl) sourceCardsEl.innerHTML = '';
          return;
        }
        if (canOverrideStatus) {
          setSourceStatus(`${sources.length} source(s) ready. Drag into prompt, timeline, or context.`, 'ok');
        }
        if (!sourceCardsEl) return;
        sourceCardsEl.innerHTML = '';
        sources.forEach((raw, idx) => {
          const s = normalizeSourceRecord(raw);
          const card = document.createElement('div');
          card.className = 'saved-card';
          card.dataset.kind = s.kind || 'web';
          const kind = s.kind === 'youtube' ? 'YouTube' : 'Web';
          const title = compactLabel(s.title || s.url || `Source ${idx + 1}`, 64);
          const body = compactLabel(s.summary || s.notes || '', 220);
          card.innerHTML = `<div class="saved-card-title">${kind}  ${title}</div><div class="saved-card-body">${body || 'No summary yet.'}</div>`;
          card.title = 'Drag into prompt/timeline/context';
          card.draggable = true;
          card.addEventListener('dragstart', (e) => {
            const snippet = sourceSnippet(s);
            const sceneNote = sourceTimelineNote(s);
            e.dataTransfer.setData('text/plain', snippet);
            e.dataTransfer.setData('text/source-snippet', snippet);
            e.dataTransfer.setData('text/source-timeline', sceneNote);
            e.dataTransfer.setData('text/source-id', s.id);
            if (s.file_path) e.dataTransfer.setData('text/source-file', s.file_path);
            e.dataTransfer.effectAllowed = 'copy';
          });

          const actions = document.createElement('div');
          actions.className = 'row small';
          actions.style.marginTop = '6px';
          const useBtn = document.createElement('button');
          useBtn.className = 'ghost';
          useBtn.textContent = 'Use in prompt';
          useBtn.addEventListener('click', () => {
            const cur = chatInputEl.value || '';
            const sep = cur && !/\s$/.test(cur) ? '\n\n' : '';
            chatInputEl.value = `${cur}${sep}${sourceSnippet(s)}\n`;
            chatInputEl.focus();
            showToast('Indexed context inserted into prompt.', 'ok');
          });
          const sceneBtn = document.createElement('button');
          sceneBtn.className = 'ghost';
          sceneBtn.textContent = 'Use in scene';
          sceneBtn.title = 'Adds this source summary into the scene at current playback time.';
          sceneBtn.addEventListener('click', () => {
            const idxScene = pickSceneIndexFromPlayback();
            if (idxScene < 0) {
              showToast('Create a plan first, then apply source to timeline scenes.', 'err');
              return;
            }
            const ok = applySourceNoteToScene(idxScene, sourceTimelineNote(s));
            if (ok) showToast(`Source applied to scene ${idxScene + 1}.`, 'ok');
          });
          const delBtn = document.createElement('button');
          delBtn.className = 'ghost';
          delBtn.textContent = 'Remove';
          delBtn.addEventListener('click', () => {
            const next = getSources().filter((x) => x.id !== s.id);
            setSources(next);
            renderSources();
            scheduleAutosave();
          });
          actions.appendChild(useBtn);
          actions.appendChild(sceneBtn);
          actions.appendChild(delBtn);
          card.appendChild(actions);
          sourceCardsEl.appendChild(card);
        });
      }

      function clampNumber(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function getLayoutSizes() {
        let stored = {};
        try {
          stored = JSON.parse(localStorage.getItem('layoutSizes') || '{}');
        } catch {
          stored = {};
        }
        const leftNum = Number(stored.left);
        const rightNum = Number(stored.right);
        return {
          left: Number.isFinite(leftNum) ? clampNumber(leftNum, 260, 600) : 340,
          right: Number.isFinite(rightNum) ? clampNumber(rightNum, 320, 680) : 420,
        };
      }

      function saveLayoutSizes(left, right) {
        localStorage.setItem('layoutSizes', JSON.stringify({ left, right }));
      }

      function getCanvasTopSplit() {
        try {
          const raw = localStorage.getItem('canvasTopSplit');
          const n = Number(raw);
          if (Number.isFinite(n)) return clampNumber(n, 42, 86);
        } catch {}
        return 72;
      }

      function saveCanvasTopSplit(pct) {
        try {
          localStorage.setItem('canvasTopSplit', String(clampNumber(pct, 42, 86)));
        } catch {}
      }

      function applyCanvasTopSplit(pct) {
        if (!canvasGridEl) return;
        const top = clampNumber(pct, 42, 86);
        // Keep timeline compact as preview grows.
        const timeline = clampNumber(Math.round((100 - top) * 0.42), 10, 24);
        canvasGridEl.style.setProperty('--canvas-top', `${top}%`);
        canvasGridEl.style.setProperty('--canvas-timeline', `${timeline}%`);
      }

      function updateBackEnabled() {
        if (!backBtnEl) return;
        const hasJob = !!currentJobId;
        const hasChat = (chatMessagesEl && chatMessagesEl.children && chatMessagesEl.children.length > 0);
        const hasVideo = !!videoEl?.src;
        const hasOpenFile = !!openFilePath;
        const hasLogs = (logsEl?.textContent || '').trim() && logsEl.textContent.trim() !== 'Cleared.';
        backBtnEl.disabled = !(hasJob || hasChat || hasVideo || hasOpenFile || hasLogs);
      }

      function updateTopbarToggles() {
        if (toggleLeftBtn) toggleLeftBtn.classList.toggle('toggled', !leftPanel.classList.contains('hidden'));
        if (toggleRightBtn) toggleRightBtn.classList.toggle('toggled', !rightPanel.classList.contains('hidden'));
        if (toggleTerminalBtn) toggleTerminalBtn.classList.toggle('toggled', !!terminalMode);
        updateBackEnabled();
      }

      function applyLayoutColumns() {
        if (mqNarrow.matches) {
          // Let the CSS media query control the stack layout (no inline override).
          layoutRoot.style.removeProperty('grid-template-columns');
          splitterLeft.classList.add('hidden');
          splitterRight.classList.add('hidden');
          updateTopbarToggles();
          return;
        }
        const leftVisible = !leftPanel.classList.contains('hidden');
        const rightVisible = !rightPanel.classList.contains('hidden');
        const sizes = getLayoutSizes();
        const leftW = leftVisible ? sizes.left : 0;
        const rightW = rightVisible ? sizes.right : 0;
        const splitL = leftVisible ? 6 : 0;
        const splitR = rightVisible ? 6 : 0;
        splitterLeft.classList.toggle('hidden', !leftVisible);
        splitterRight.classList.toggle('hidden', !rightVisible);
        layoutRoot.style.gridTemplateColumns = `${leftW}px ${splitL}px 1fr ${splitR}px ${rightW}px`;
        updateTopbarToggles();
      }

      function resetLayout() {
        try { localStorage.removeItem('layoutSizes'); } catch {}
        leftPanel.classList.remove('hidden');
        rightPanel.classList.remove('hidden');
        applyLayoutColumns();
        showToast('Layout reset.', 'ok');
      }

      document.getElementById('toggleLeft').addEventListener('click', () => {
        leftPanel.classList.toggle('hidden');
        applyLayoutColumns();
      });
      document.getElementById('toggleRight').addEventListener('click', () => {
        rightPanel.classList.toggle('hidden');
        applyLayoutColumns();
      });
      function setTerminalMode(on) {
        terminalMode = !!on;
        if (!controlsCardEl || !terminalPanel) return;
        if (terminalPanel.parentElement !== controlsCardEl) {
          controlsCardEl.appendChild(terminalPanel);
        }
        Array.from(controlsCardEl.children).forEach((child) => {
          if (child === terminalPanel) return;
          child.classList.toggle('hidden', terminalMode);
        });
        terminalPanel.classList.toggle('hidden', !terminalMode);
        updateTopbarToggles();
        if (terminalMode) {
          setTimeout(() => termCmdEl?.focus(), 0);
        }
      }

      document.getElementById('toggleTerminal').addEventListener('click', () => {
        setTerminalMode(!terminalMode);
      });

      document.getElementById('backBtn').addEventListener('click', () => {
        cancelCrazyCountdown('');
        resetSteps();
        currentJobId = null;
        appendFromJobId = null;
        persistedSceneSignature = '';
        renderNoticeByJob.clear();
        try { if (jobEventSource) jobEventSource.close(); } catch {}
        jobEventSource = null;
        jobIdEl.textContent = '';
        jobFileListEl.innerHTML = '';
        updateOutputPaths();
        codeEl.value = '';
        refreshGutter();
        upsertGeneratedTab('');
        editorTabsState.splice(0, editorTabsState.length, {
          id: 'generated',
          path: null,
          label: 'generated.py',
          content: '',
          generated: true,
        });
        activeEditorTabId = 'generated';
        renderEditorTabs();
        openFilePath = null;
        openFileContent = '';
        pendingRenameFrom = null;
        pendingRenameKind = '';
        setSelectedTreePath('', '');
        updateEditorMode();
        logsEl.textContent = 'Cleared.';
        statusEl.textContent = 'Ready.';
        const session = getActiveChatSession();
        if (session) {
          session.messages_html = '';
          session.prompt = '';
          session.last_sig = '';
        }
        chatMessagesEl.innerHTML = '';
        if (chatInputEl) chatInputEl.value = '';
        lastChatSignature = '';
        renderChatSessions();
        videoEl.removeAttribute('src');
        videoEl.load();
        lastVideoUrl = '';
        lastCaptionsUrl = '';
        setVideoAvailable(false);
        timelineTrackEl.innerHTML = '';
        timelineState = [];
        if (timelineRulerEl) timelineRulerEl.innerHTML = '';
        if (timelineLabelEl) timelineLabelEl.textContent = 'Timeline';
        if (stepDetailEl) stepDetailEl.textContent = 'Click a step to inspect details.';
        renderDeckUI();
        setTerminalMode(false);
        updateBackEnabled();
      });

      function openSettingsTab(stab) {
        setActiveTab('settings');
        if (stab) setSettingsSubtab(stab);
      }
      openSettingsBtn.addEventListener('click', () => openSettingsTab('api'));
      if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => setActiveTab('canvas'));

      function setSettingsSubtab(id) {
        if (!settingsNavEl) return;
        const btns = Array.from(settingsNavEl.querySelectorAll('button[data-stab]'));
        btns.forEach(b => b.classList.toggle('active', b.dataset.stab === id));
        const secs = Array.from(document.querySelectorAll('.settings-section[data-stab]'));
        secs.forEach(s => s.classList.toggle('active', s.dataset.stab === id));
      }
      if (settingsNavEl) {
        settingsNavEl.addEventListener('click', (e) => {
          const t = e.target.closest('button[data-stab]');
          if (!t) return;
          setSettingsSubtab(t.dataset.stab);
        });
      }

      function cloneOnboardingDefaults() {
        return JSON.parse(JSON.stringify(DEFAULT_ONBOARDING));
      }

      function normalizeOnboardingPayload(payload) {
        const base = cloneOnboardingDefaults();
        if (!payload || typeof payload !== 'object') return base;
        const allowedTargets = new Set(base.steps.map((s) => s.target));
        const next = { ...base };
        if (payload.intro_title) next.intro_title = String(payload.intro_title).trim().slice(0, 140);
        if (payload.intro_body) next.intro_body = String(payload.intro_body).trim().slice(0, 320);
        if (payload.outro_title) next.outro_title = String(payload.outro_title).trim().slice(0, 140);
        if (payload.outro_body) next.outro_body = String(payload.outro_body).trim().slice(0, 320);
        const srcSteps = Array.isArray(payload.steps) ? payload.steps : [];
        next.steps = base.steps.map((fallback, idx) => {
          const src = srcSteps[idx];
          if (!src || typeof src !== 'object') return fallback;
          const item = { ...fallback };
          const title = String(src.title || '').trim();
          const body = String(src.body || '').trim();
          const hint = String(src.hint || '').trim();
          const iconPrompt = String(src.icon_prompt || '').trim();
          const iconUrl = String(src.icon_url || '').trim();
          const target = String(src.target || '').trim();
          if (title) item.title = title.slice(0, 140);
          if (body) item.body = body.slice(0, 360);
          if (hint) item.hint = hint.slice(0, 140);
          if (iconPrompt) item.icon_prompt = iconPrompt.slice(0, 320);
          if (iconUrl) item.icon_url = iconUrl;
          if (allowedTargets.has(target)) item.target = target;
          return item;
        });
        return next;
      }

      function clearTourHighlight() {
        if (!tourHighlightEl) return;
        tourHighlightEl.classList.add('hidden');
        tourHighlightEl.style.left = '-9999px';
        tourHighlightEl.style.top = '-9999px';
        tourHighlightEl.style.width = '0px';
        tourHighlightEl.style.height = '0px';
      }

      function positionTourHighlight(targetSelector) {
        if (!tourHighlightEl) return;
        if (!targetSelector) {
          clearTourHighlight();
          return;
        }
        const target = document.querySelector(targetSelector);
        if (!target) {
          clearTourHighlight();
          return;
        }
        const rect = target.getBoundingClientRect();
        if (!Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width < 8 || rect.height < 8) {
          clearTourHighlight();
          return;
        }
        const pad = 8;
        const left = Math.max(8, rect.left - pad);
        const top = Math.max(8, rect.top - pad);
        const maxW = Math.max(16, window.innerWidth - left - 8);
        const maxH = Math.max(16, window.innerHeight - top - 8);
        const width = Math.max(24, Math.min(maxW, rect.width + pad * 2));
        const height = Math.max(24, Math.min(maxH, rect.height + pad * 2));
        tourHighlightEl.style.left = `${left}px`;
        tourHighlightEl.style.top = `${top}px`;
        tourHighlightEl.style.width = `${width}px`;
        tourHighlightEl.style.height = `${height}px`;
        tourHighlightEl.classList.remove('hidden');
      }

      function setOnboardingLoading(on, msg = 'Preparing quick guide...') {
        onboardingLoading = !!on;
        if (tourRefreshBtn) tourRefreshBtn.disabled = onboardingLoading;
        if (tourPrevBtn) tourPrevBtn.disabled = onboardingLoading || onboardingIndex <= 0;
        if (tourNextBtn) tourNextBtn.disabled = onboardingLoading;
        if (onboardingLoading) {
          if (tourStepTitleEl) tourStepTitleEl.textContent = 'Building guide with Gemini...';
          if (tourStepBodyEl) tourStepBodyEl.textContent = msg;
          if (tourStepHintEl) tourStepHintEl.textContent = 'Generating step copy and icons';
          if (tourStepCountEl) tourStepCountEl.textContent = '...';
          if (tourProgressFillEl) tourProgressFillEl.style.width = '6%';
          if (tourStepIconEl) tourStepIconEl.classList.add('hidden');
          if (tourIconFallbackEl) {
            tourIconFallbackEl.classList.remove('hidden');
            tourIconFallbackEl.textContent = '...';
          }
        }
      }

      function getOnboardingSteps() {
        const steps = Array.isArray(onboardingData?.steps) ? onboardingData.steps : [];
        return steps.length ? steps : cloneOnboardingDefaults().steps;
      }

      function renderOnboardingStep() {
        if (!infoModal || !infoModal.classList.contains('open')) {
          clearTourHighlight();
          return;
        }
        const steps = getOnboardingSteps();
        if (!steps.length) return;
        onboardingIndex = Math.max(0, Math.min(onboardingIndex, steps.length - 1));
        const step = steps[onboardingIndex];
        const total = steps.length;
        const countLabel = `${onboardingIndex + 1} / ${total}`;
        if (tourStepCountEl) tourStepCountEl.textContent = countLabel;
        if (tourProgressFillEl) {
          const pct = Math.round(((onboardingIndex + 1) / total) * 100);
          tourProgressFillEl.style.width = `${pct}%`;
        }
        if (tourIntroLineEl) {
          tourIntroLineEl.textContent = onboardingData?.intro_body || DEFAULT_ONBOARDING.intro_body;
        }
        if (tourStepTitleEl) tourStepTitleEl.textContent = step.title || `Step ${onboardingIndex + 1}`;
        if (tourStepBodyEl) tourStepBodyEl.textContent = step.body || '';
        if (tourStepHintEl) tourStepHintEl.textContent = step.hint || '';
        if (tourPrevBtn) tourPrevBtn.disabled = onboardingLoading || onboardingIndex <= 0;
        if (tourNextBtn) {
          tourNextBtn.disabled = onboardingLoading;
          tourNextBtn.textContent = onboardingIndex >= total - 1 ? 'Finish' : 'Next';
        }
        if (tourHurrayEl) tourHurrayEl.classList.add('hidden');
        if (tourStepIconEl && tourIconFallbackEl) {
          const iconUrl = String(step.icon_url || '').trim();
          if (iconUrl) {
            tourStepIconEl.src = iconUrl;
            tourStepIconEl.classList.remove('hidden');
            tourIconFallbackEl.classList.add('hidden');
          } else {
            tourStepIconEl.removeAttribute('src');
            tourStepIconEl.classList.add('hidden');
            tourIconFallbackEl.classList.remove('hidden');
            tourIconFallbackEl.textContent = `${onboardingIndex + 1}`;
          }
        }
        positionTourHighlight(step.target || '');
      }

      async function loadOnboardingGuide(force = false) {
        if (onboardingLoading) return;
        if (onboardingFetched && !force) {
          renderOnboardingStep();
          return;
        }
        setOnboardingLoading(true, 'Generating onboarding flow...');
        const payload = {
          prompt: chatInputEl ? String(chatInputEl.value || '').trim() : '',
          audience: 'first-time creators',
          model: chatModelEl ? chatModelEl.value : '',
          image_model: settingsImageModelEl ? settingsImageModelEl.value : '',
        };
        try {
          const resp = await fetch('/api/onboarding/quickstart', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const data = await parseApiResponse(resp, 'Onboarding generation failed.');
          if (!data.ok) {
            throw new Error(data.error || 'Onboarding generation failed.');
          }
          onboardingData = normalizeOnboardingPayload(data);
          onboardingFetched = true;
          onboardingIndex = 0;
          if (Array.isArray(data.warnings) && data.warnings.length) {
            showToast(String(data.warnings[0]), 'err');
          }
        } catch (err) {
          onboardingData = cloneOnboardingDefaults();
          onboardingFetched = false;
          showToast(err?.message || 'Using default onboarding guide.', 'err');
        } finally {
          setOnboardingLoading(false);
          renderOnboardingStep();
        }
      }

      function playTourHurray() {
        if (!tourHurrayEl) return;
        const title = String(onboardingData?.outro_title || DEFAULT_ONBOARDING.outro_title).trim();
        const body = String(onboardingData?.outro_body || DEFAULT_ONBOARDING.outro_body).trim();
        tourHurrayEl.textContent = `${title}: ${body}`;
        tourHurrayEl.classList.remove('hidden');
      }

      function openInfo() {
        if (!infoModal) return;
        infoModal.classList.add('open');
        infoModal.setAttribute('aria-hidden', 'false');
        onboardingIndex = 0;
        renderOnboardingStep();
        void loadOnboardingGuide(false);
      }
      function closeInfo() {
        if (!infoModal) return;
        infoModal.classList.remove('open');
        infoModal.setAttribute('aria-hidden', 'true');
        clearTourHighlight();
        if (tourHurrayEl) tourHurrayEl.classList.add('hidden');
      }
      function openWelcome() {
        if (!welcomeModal) return;
        welcomeModal.classList.add('open');
        welcomeModal.setAttribute('aria-hidden', 'false');
      }
      function closeWelcome({ markSeen = true } = {}) {
        if (!welcomeModal) return;
        welcomeModal.classList.remove('open');
        welcomeModal.setAttribute('aria-hidden', 'true');
        if (markSeen) {
          try { localStorage.setItem(WELCOME_SEEN_KEY, '1'); } catch {}
        }
      }
      function stepTourBackward() {
        if (onboardingLoading) return;
        onboardingIndex = Math.max(0, onboardingIndex - 1);
        renderOnboardingStep();
      }
      function stepTourForward() {
        if (onboardingLoading) return;
        const steps = getOnboardingSteps();
        if (onboardingIndex < steps.length - 1) {
          onboardingIndex += 1;
          renderOnboardingStep();
          return;
        }
        playTourHurray();
        try { localStorage.setItem(TOUR_SEEN_KEY, '1'); } catch {}
        setTimeout(() => {
          closeInfo();
          showToast('Quick guide complete. Start creating.', 'ok');
        }, 900);
      }
      function maybeOpenWelcome() {
        let seen = false;
        try { seen = localStorage.getItem(WELCOME_SEEN_KEY) === '1'; } catch { seen = false; }
        if (!seen) openWelcome();
      }
      if (openInfoBtn) openInfoBtn.addEventListener('click', openInfo);
      if (closeInfoBtn) closeInfoBtn.addEventListener('click', closeInfo);
      safeOn(tourPrevBtn, 'click', stepTourBackward);
      safeOn(tourNextBtn, 'click', stepTourForward);
      safeOn(tourRefreshBtn, 'click', () => {
        onboardingIndex = 0;
        void loadOnboardingGuide(true);
      });
      if (tourStepIconEl && tourIconFallbackEl) {
        tourStepIconEl.addEventListener('error', () => {
          tourStepIconEl.classList.add('hidden');
          tourStepIconEl.removeAttribute('src');
          tourIconFallbackEl.classList.remove('hidden');
          tourIconFallbackEl.textContent = `${onboardingIndex + 1}`;
        });
      }
      if (closeWelcomeBtn) closeWelcomeBtn.addEventListener('click', () => closeWelcome());
      if (welcomeTourBtn) {
        welcomeTourBtn.addEventListener('click', () => {
          closeWelcome();
          openInfo();
        });
      }
      if (welcomeDemoBtn) {
        welcomeDemoBtn.addEventListener('click', () => {
          seedDemoDefaults();
          closeWelcome();
          showToast('Demo prompt loaded.', 'ok');
        });
      }
      if (welcomeStartBtn) welcomeStartBtn.addEventListener('click', () => closeWelcome());
      if (infoModal) {
        infoModal.addEventListener('click', (e) => {
          if (e.target === infoModal) closeInfo();
        });
      }
      if (welcomeModal) {
        welcomeModal.addEventListener('click', (e) => {
          if (e.target === welcomeModal) closeWelcome();
        });
      }
      window.addEventListener('resize', () => {
        if (infoModal && infoModal.classList.contains('open')) renderOnboardingStep();
      });
      window.addEventListener('scroll', () => {
        if (infoModal && infoModal.classList.contains('open')) renderOnboardingStep();
      }, true);
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          // Close the most "modal" thing first.
          if (welcomeModal && welcomeModal.classList.contains('open')) {
            closeWelcome();
            return;
          }
          if (infoModal && infoModal.classList.contains('open')) {
            closeInfo();
            return;
          }
          // Settings is a full-page in the middle pane; treat Escape as "close".
          const settingsIsActive = document.querySelector('.tab-panel[data-tab="settings"]')?.classList.contains('active');
          if (settingsIsActive) {
            setActiveTab('canvas');
            return;
          }
        }
      });

      safeOn(settingsShowKeyBtn, 'click', () => {
        const isHidden = settingsApiKeyEl.type === 'password';
        settingsApiKeyEl.type = isHidden ? 'text' : 'password';
      });
      safeOn(settingsShowAllKeysBtn, 'click', () => {
        const reveal = settingsApiKeyEl.type === 'password' || settingsElevenApiKeyEl.type === 'password';
        settingsApiKeyEl.type = reveal ? 'text' : 'password';
        settingsElevenApiKeyEl.type = reveal ? 'text' : 'password';
      });
      safeOn(sessionPrevBtn, 'click', () => cycleSession(-1));
      safeOn(sessionNextBtn, 'click', () => cycleSession(1));
      if (chatSessionsEl) {
        let touchStartX = 0;
        let touchActive = false;
        chatSessionsEl.addEventListener('touchstart', (e) => {
          const t = e.touches[0];
          if (!t) return;
          touchStartX = t.clientX;
          touchActive = true;
        }, { passive: true });
        chatSessionsEl.addEventListener('touchend', (e) => {
          if (!touchActive) return;
          touchActive = false;
          const t = e.changedTouches[0];
          if (!t) return;
          const dx = t.clientX - touchStartX;
          if (Math.abs(dx) > 40) {
            cycleSession(dx < 0 ? 1 : -1);
          }
        });
      }
      let mentionsCollapsed = true;
      function updateMentionVisibility() {
        if (!mentionBarEl) return;
        mentionBarEl.classList.toggle('collapsed', mentionsCollapsed);
        if (toggleMentionsBtn) toggleMentionsBtn.textContent = mentionsCollapsed ? 'Show refs' : 'Hide refs';
        if (mentionInfoEl) {
          if (mentionsCollapsed) mentionInfoEl.textContent = 'References hidden';
          else mentionInfoEl.textContent = mentionInfoEl.dataset.summary || 'Skills & agents references';
        }
      }
      safeOn(toggleMentionsBtn, 'click', () => {
        mentionsCollapsed = !mentionsCollapsed;
        updateMentionVisibility();
      });

      function snapshotStepStates() {
        const out = {};
        ['plan', 'approve', 'code', 'render'].forEach((step) => {
          const el = agentStepsEl?.querySelector(`[data-step="${step}"]`);
          if (!el) return;
          if (el.classList.contains('done')) out[step] = 'done';
          else if (el.classList.contains('active')) out[step] = 'active';
          else if (el.classList.contains('error')) out[step] = 'error';
          else out[step] = '';
        });
        return out;
      }

      function applyStepStates(states = {}) {
        ['plan', 'approve', 'code', 'render'].forEach((step) => {
          const el = agentStepsEl?.querySelector(`[data-step="${step}"]`);
          if (!el) return;
          el.classList.remove('active', 'done', 'error');
          const state = states[step] || '';
          if (state) el.classList.add(state);
        });
        updateStepProgress();
      }

      function snapshotStepNotes() {
        return {
          plan: stepNotes.plan,
          approve: stepNotes.approve,
          code: stepNotes.code,
          render: stepNotes.render,
        };
      }

      function applyStepNotes(notes) {
        const next = notes || {};
        stepNotes.plan = next.plan || defaultStepNotes.plan;
        stepNotes.approve = next.approve || defaultStepNotes.approve;
        stepNotes.code = next.code || defaultStepNotes.code;
        stepNotes.render = next.render || defaultStepNotes.render;
        const selected = agentStepsEl?.querySelector('.agent-step.selected');
        const key = selected?.dataset.step || 'plan';
        if (stepDetailEl) stepDetailEl.textContent = stepNotes[key] || 'No details yet.';
      }

      function refreshPlanBoxFromChat() {
        if (!chatMessagesEl) return;
        const boxes = Array.from(chatMessagesEl.querySelectorAll('textarea.plan-editor'));
        lastPlanBox = boxes.length ? boxes[boxes.length - 1] : null;
      }

      function updateSessionPhase(session) {
        if (!session) return;
        const states = session.step_states || {};
        const hasJob = !!String(session.job_id || '').trim();
        if (!hasJob) {
          let cleaned = false;
          ['plan', 'approve', 'code', 'render'].forEach((k) => {
            if (states[k] === 'active') {
              states[k] = '';
              cleaned = true;
            }
          });
          if (cleaned) session.step_states = { ...states };
          if (states.plan === 'done') session.phase = 'planned';
          else session.phase = 'idle';
          return;
        }
        if (states.render === 'error' || states.code === 'error') {
          session.phase = 'failed';
          return;
        }
        if (states.render === 'done') session.phase = 'rendered';
        else if (states.render === 'active') session.phase = 'rendering';
        else if (states.code === 'active') session.phase = 'coding';
        else if (states.approve === 'active') session.phase = 'approve';
        else if (states.plan === 'active') session.phase = 'planning';
        else if (states.plan === 'done') session.phase = 'planned';
        else session.phase = 'idle';
      }

      function getActiveChatSession() {
        return chatSessions.find((s) => s.id === activeChatSessionId) || null;
      }

      function saveActiveSessionState() {
        const session = getActiveChatSession();
        if (!session) return;
        session.messages_html = chatMessagesEl ? chatMessagesEl.innerHTML : '';
        session.prompt = chatInputEl ? chatInputEl.value : '';
        session.model = chatModelEl ? chatModelEl.value : '';
        session.last_sig = lastChatSignature || '';
        session.job_id = currentJobId || '';
        session.plan_text = currentPlanText || '';
        session.timeline_state = Array.isArray(timelineState) ? timelineState : [];
        session.timeline_meta = { ...(timelineMeta || {}) };
        session.video_url = lastVideoUrl || '';
        session.logs_text = logsEl ? logsEl.textContent : '';
        session.code_text = codeEl ? codeEl.value : '';
        session.diagnosis = session.diagnosis || '';
        session.code_diff = session.code_diff || '';
        session.retry_result = session.retry_result || '';
        session.step_states = snapshotStepStates();
        session.step_notes = snapshotStepNotes();
        session.job_files = session.job_files || [];
        updateSessionPhase(session);
      }

      function restoreSessionState(session) {
        if (!session) return;
        updateSessionPhase(session);
        if (chatMessagesEl) chatMessagesEl.innerHTML = session.messages_html || '';
        if (chatInputEl) chatInputEl.value = session.prompt || '';
        if (chatModelEl && session.model) chatModelEl.value = session.model;
        lastChatSignature = session.last_sig || '';
        currentJobId = session.job_id || '';
        currentPlanText = session.plan_text || '';
        timelineState = Array.isArray(session.timeline_state) ? session.timeline_state : [];
        timelineMeta = session.timeline_meta || { title: 'Scene Plan' };
        renderTimeline();
        lastVideoUrl = session.video_url || '';
        if (videoEl && lastVideoUrl) {
          videoEl.src = lastVideoUrl;
          videoEl.load();
          setVideoAvailable(true);
        } else {
          setVideoAvailable(false);
        }
        if (logsEl) logsEl.textContent = session.logs_text || '';
        if (Array.isArray(session.job_files) && session.job_files.length) {
          updateJobFiles(session.job_files);
        } else {
          updateJobFiles([]);
        }
        if (session.code_text) {
          upsertGeneratedTab(session.code_text);
          if (activeEditorTabId === 'generated') applyActiveEditorTab();
        }
        applyStepStates(session.step_states || {});
        applyStepNotes(session.step_notes || {});
        syncBusyFromSession(session);
        updateOutputPaths();
        refreshPlanBoxFromChat();
      }

      function syncBusyFromSession(session) {
        if (!session) return;
        const hasJob = !!String(session.job_id || '').trim();
        if (!hasJob) {
          setBusy(false);
          if (statusEl) statusEl.textContent = 'Ready.';
          return;
        }
        const phase = session.phase || '';
        if (phase === 'rendering') {
          setBusy(true, 'Rendering', 'Rendering');
          return;
        }
        if (phase === 'coding') {
          setBusy(true, 'Generating code', 'Rendering');
          return;
        }
        if (phase === 'planning') {
          setBusy(true, 'Planning', 'Planning');
          return;
        }
        setBusy(false);
      }

      function makeSessionName(idx) {
        return `Session ${idx}`;
      }

      function normalizeSessionName(name, fallbackName) {
        const raw = String(name || '').trim().replace(/\s+/g, ' ');
        if (!raw) return String(fallbackName || '').trim() || 'Session';
        return raw.slice(0, 48);
      }

      function startSessionRename(session, labelEl) {
        if (!session || !labelEl) return;
        if (labelEl.dataset.renaming === '1') return;
        labelEl.dataset.renaming = '1';
        const oldName = String(session.name || '');
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'chat-session-name-input';
        input.value = oldName;
        input.setAttribute('aria-label', 'Rename session');
        labelEl.replaceWith(input);
        input.focus();
        input.select();

        let done = false;
        const finish = (commit) => {
          if (done) return;
          done = true;
          if (commit) {
            const nextName = normalizeSessionName(input.value, oldName);
            if (nextName !== oldName) {
              session.name = nextName;
              scheduleAutosave();
              showToast(`Renamed: ${nextName}`, 'ok');
            }
          }
          renderChatSessions();
        };

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            finish(true);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            finish(false);
          }
        });
        input.addEventListener('blur', () => finish(true));
      }

      function switchToSession(session) {
        if (!session) return;
        if (session.id === activeChatSessionId) return;
        saveActiveSessionState();
        try { if (jobEventSource) jobEventSource.close(); } catch {}
        jobEventSource = null;
        setBusy(false);
        activeChatSessionId = session.id;
        restoreSessionState(session);
        renderChatSessions();
      }

      function deleteSessionById(sessionId) {
        const idx = chatSessions.findIndex((s) => s.id === sessionId);
        if (idx < 0) return;
        const wasActive = chatSessions[idx].id === activeChatSessionId;
        if (wasActive) {
          try { if (jobEventSource) jobEventSource.close(); } catch {}
          jobEventSource = null;
          setBusy(false);
          cancelCrazyCountdown('');
        }
        chatSessions.splice(idx, 1);
        if (!chatSessions.length) {
          const fallback = createSessionRecord(makeSessionName(1));
          fallback.id = `chat-${Date.now()}`;
          chatSessions.push(fallback);
        }
        if (wasActive) {
          const next = chatSessions[Math.max(0, idx - 1)] || chatSessions[0];
          activeChatSessionId = next.id;
          restoreSessionState(next);
        }
        scheduleAutosave();
        renderChatSessions();
      }

      function sessionPhaseLabel(session) {
        const phase = session?.phase || 'idle';
        if (phase === 'rendered') return 'Rendered';
        if (phase === 'rendering') return 'Rendering';
        if (phase === 'coding') return 'Coding';
        if (phase === 'approve') return 'Awaiting approval';
        if (phase === 'planning') return 'Planning';
        if (phase === 'queued') return 'Queued';
        if (phase === 'planned') return 'Planned';
        if (phase === 'stale') return 'Missing';
        return 'Idle';
      }

      function bindTouchDoubleTap(el, handler) {
        if (!el || typeof handler !== 'function') return;
        let lastTapAt = 0;
        let lastX = 0;
        let lastY = 0;
        el.addEventListener('pointerup', (e) => {
          if (e.pointerType !== 'touch') return;
          const now = Date.now();
          const dt = now - lastTapAt;
          const dx = Math.abs((e.clientX || 0) - lastX);
          const dy = Math.abs((e.clientY || 0) - lastY);
          if (dt > 0 && dt < 340 && dx < 18 && dy < 18) {
            e.preventDefault();
            e.stopPropagation();
            handler(e);
            lastTapAt = 0;
            return;
          }
          lastTapAt = now;
          lastX = e.clientX || 0;
          lastY = e.clientY || 0;
        });
      }

      function renderChatSessions() {
        if (!chatSessionsEl) return;
        chatSessionsEl.innerHTML = '';
        chatSessions.forEach((session) => {
          updateSessionPhase(session);
          if (session.pending_delete !== true) session.pending_delete = false;
          const card = document.createElement('div');
          card.className = `chat-session-card ${session.id === activeChatSessionId ? 'active' : ''}`;
          card.title = `${session.name}. Double tap name to rename. Use lock icon for pinned context.`;
          const head = document.createElement('div');
          head.className = 'chat-session-card-head';
          const name = document.createElement('div');
          name.className = 'chat-session-name';
          name.innerHTML = `<span class="chat-session-swatch" style="background:${session.color};"></span>`;
          const nameLabel = document.createElement('span');
          nameLabel.className = 'chat-session-name-label';
          nameLabel.textContent = session.name || 'Session';
          nameLabel.title = 'Double click or double tap to rename session';
          nameLabel.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startSessionRename(session, nameLabel);
          });
          bindTouchDoubleTap(nameLabel, () => startSessionRename(session, nameLabel));
          head.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startSessionRename(session, nameLabel);
          });
          bindTouchDoubleTap(head, () => startSessionRename(session, nameLabel));
          name.appendChild(nameLabel);
          const phase = document.createElement('div');
          phase.className = 'chat-session-phase';
          phase.textContent = sessionPhaseLabel(session);
          const headRight = document.createElement('div');
          headRight.className = 'chat-session-head-right';
          const lockBtn = document.createElement('button');
          lockBtn.type = 'button';
          lockBtn.className = `chat-session-lock ${session.context_lock ? 'on' : ''}`;
          lockBtn.innerHTML = session.context_lock
            ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="11" width="14" height="10" rx="2"/><path d="M8 11V7a4 4 0 1 1 8 0v4"/></svg>'
            : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="11" width="14" height="10" rx="2"/><path d="M8 11V7a4 4 0 0 1 7.6-1.8"/></svg>';
          lockBtn.title = session.context_lock
            ? 'Context lock on: memory + skills pinned to this session'
            : 'Context lock off: session uses global context';
          lockBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            session.context_lock = !session.context_lock;
            renderChatSessions();
            scheduleAutosave();
            showToast(session.context_lock ? `${session.name}: context lock on` : `${session.name}: context lock off`, 'ok');
          });
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'chat-session-edit';
          editBtn.title = `Rename ${session.name}`;
          editBtn.setAttribute('aria-label', `Rename ${session.name}`);
          editBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg>';
          editBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startSessionRename(session, nameLabel);
          });
          head.appendChild(name);
          headRight.appendChild(phase);
          headRight.appendChild(editBtn);
          headRight.appendChild(lockBtn);
          card.appendChild(head);
          head.appendChild(headRight);
          const meta = document.createElement('div');
          meta.className = 'muted';
          if (session.phase === 'stale') meta.textContent = 'Missing job state (stale session)';
          else meta.textContent = session.job_id ? `Job ${session.job_id}` : 'No job yet';
          card.appendChild(meta);

          meta.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startSessionRename(session, nameLabel);
          });
          bindTouchDoubleTap(meta, () => startSessionRename(session, nameLabel));

          card.addEventListener('click', () => switchToSession(session));
          card.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startSessionRename(session, nameLabel);
          });
          bindTouchDoubleTap(card, () => startSessionRename(session, nameLabel));

          if (chatSessions.length > 1) {
            if (session.pending_delete) {
              const yesBtn = document.createElement('button');
              yesBtn.type = 'button';
              yesBtn.className = 'chat-session-close confirm';
              yesBtn.title = `Confirm delete ${session.name}`;
              yesBtn.textContent = '';
              yesBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                deleteSessionById(session.id);
                showToast(`Deleted ${session.name}`, 'ok');
              });
              const noBtn = document.createElement('button');
              noBtn.type = 'button';
              noBtn.className = 'chat-session-close cancel';
              noBtn.title = 'Cancel delete';
              noBtn.textContent = '';
              noBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                session.pending_delete = false;
                renderChatSessions();
              });
              headRight.appendChild(yesBtn);
              headRight.appendChild(noBtn);
            } else {
              const close = document.createElement('button');
              close.type = 'button';
              close.className = 'chat-session-close';
              close.title = `Delete ${session.name}`;
              close.setAttribute('aria-label', `Delete ${session.name}`);
              close.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M8 6v14h8V6"/><path d="M10 10v7"/><path d="M14 10v7"/></svg>';
              close.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                session.pending_delete = true;
                renderChatSessions();
              });
              headRight.appendChild(close);
            }
          }
          chatSessionsEl.appendChild(card);
        });

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'chat-session-add';
        addBtn.textContent = '+';
        addBtn.title = 'New chat session';
        addBtn.addEventListener('click', () => {
          saveActiveSessionState();
          const s = createSessionRecord();
          chatSessions.push(s);
          activeChatSessionId = s.id;
          restoreSessionState(s);
          renderChatSessions();
          showToast(`Started ${s.name}.`, 'ok');
        });
        chatSessionsEl.appendChild(addBtn);

        const activeIdx = chatSessions.findIndex((s) => s.id === activeChatSessionId);
        const activeCard = chatSessionsEl.children[activeIdx];
        if (activeCard && activeCard.scrollIntoView) {
          activeCard.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
        }
      }

      function cycleSession(delta) {
        if (!chatSessions.length) return;
        const idx = Math.max(0, chatSessions.findIndex((s) => s.id === activeChatSessionId));
        const next = (idx + delta + chatSessions.length) % chatSessions.length;
        switchToSession(chatSessions[next]);
      }

      function applyJobStateToSession(session, st) {
        if (!session || !st) return;
        if (st.job_files) session.job_files = st.job_files;
        if (st.plan && Array.isArray(st.plan.scenes)) {
          session.timeline_meta = { title: st.plan.title || 'Scene Plan' };
          session.timeline_state = st.plan.scenes.map((sc) => ({
            seconds: sc.seconds || 3,
            goal: sc.goal,
            elements: sc.elements,
            actions: sc.actions,
            narration: sc.narration,
            assets: sc.assets || {}
          }));
          session.plan_text = JSON.stringify(st.plan, null, 2);
        }
        if (st.code) {
          session.code_text = st.code;
        }
        if (st.video_path) {
          session.video_url = '/' + st.video_path + '?t=' + Date.now();
        }
        if (st.logs_tail) {
          session.logs_text = st.logs_tail;
        }
        if (typeof st.diagnosis === 'string') session.diagnosis = st.diagnosis;
        if (typeof st.code_diff === 'string') session.code_diff = st.code_diff;
        if (typeof st.retry_result === 'string') session.retry_result = st.retry_result;
        const states = { ...(session.step_states || {}) };
        if (st.status === 'failed') {
          states.code = states.code || 'done';
          states.render = 'error';
        } else if (st.status === 'done') {
          states.code = 'done';
          states.render = 'done';
        } else if (st.step === 'code') {
          states.code = 'active';
          states.render = '';
        } else if (st.step === 'render' || st.step === 'repair') {
          states.code = 'done';
          states.render = 'active';
        }
        if (!states.plan) states.plan = 'done';
        if (!states.approve) states.approve = 'done';
        session.step_states = states;
        session.step_notes = {
          plan: session.step_notes?.plan || defaultStepNotes.plan,
          approve: session.step_notes?.approve || defaultStepNotes.approve,
          code: st.step === 'code' ? (st.message || 'Generating code') : (session.step_notes?.code || defaultStepNotes.code),
          render: st.step === 'render' || st.step === 'repair' ? (st.message || 'Rendering') : (session.step_notes?.render || defaultStepNotes.render),
        };
        updateSessionPhase(session);
      }

      function applySessionToUI(session) {
        if (!session) return;
        updateSessionPhase(session);
        currentJobId = session.job_id || '';
        currentPlanText = session.plan_text || '';
        timelineMeta = session.timeline_meta || { title: 'Scene Plan' };
        timelineState = Array.isArray(session.timeline_state) ? session.timeline_state : [];
        renderTimeline();
        applyStepStates(session.step_states || {});
        applyStepNotes(session.step_notes || {});
        syncBusyFromSession(session);
        if (logsEl) logsEl.textContent = session.logs_text || '';
        if (session.diagnosis && logsEl && !logsEl.textContent.trim()) {
          logsEl.textContent = session.diagnosis;
        }
        if (session.video_url) {
          lastVideoUrl = session.video_url;
          videoEl.src = session.video_url;
          videoEl.load();
          setVideoAvailable(true);
        } else {
          setVideoAvailable(false);
        }
        if (session.code_text) {
          upsertGeneratedTab(session.code_text);
        }
        if (Array.isArray(session.job_files)) {
          updateJobFiles(session.job_files);
        }
        updateOutputPaths();
      }

      let sessionPoller = null;
      function markSessionStale(session, message) {
        if (!session) return;
        session.job_id = '';
        session.phase = 'stale';
        session.missing_checks = 0;
        session.pending_delete = false;
        session.step_states = { plan: '', approve: '', code: '', render: '' };
        session.step_notes = {
          plan: message || 'Linked job is no longer available.',
          approve: defaultStepNotes.approve,
          code: defaultStepNotes.code,
          render: defaultStepNotes.render,
        };
      }
      async function pollSessionStatuses() {
        if (!chatSessions.length) return;
        let changed = false;
        const now = Date.now();
        for (const session of chatSessions) {
          if (!session.job_id) continue;
          if (session.phase === 'rendered' || session.phase === 'failed') continue;
          try {
            const resp = await fetch(`/api/jobs/${encodeURIComponent(session.job_id)}`);
            if (resp.status === 404) {
              session.missing_checks = Number(session.missing_checks || 0) + 1;
              const ageMs = now - Number(session.created_at || 0);
              if (ageMs < 12000 && session.missing_checks < 4) {
                if (session.id === activeChatSessionId) {
                  statusEl.textContent = 'Waiting for job registration...';
                }
                continue;
              }
              markSessionStale(session, 'Job not found. This session can be deleted or reused.');
              changed = true;
              if (session.id === activeChatSessionId) {
                statusEl.textContent = 'Active session job not found. Keeping session shell for reuse.';
              }
              continue;
            }
            const st = await resp.json();
            if (!st.ok) {
              const maybeUnknown = String(st.error || '').toLowerCase();
              if (resp.status === 404 || maybeUnknown.includes('unknown job')) {
                session.missing_checks = Number(session.missing_checks || 0) + 1;
                const ageMs = now - Number(session.created_at || 0);
                if (ageMs < 12000 && session.missing_checks < 4) {
                  continue;
                }
                markSessionStale(session, 'Job not found. This session can be deleted or reused.');
                changed = true;
              }
              continue;
            }
            session.missing_checks = 0;
            applyJobStateToSession(session, st);
            if (session.id === activeChatSessionId) {
              applySessionToUI(session);
            }
          } catch {}
        }
        renderChatSessions();
        if (changed) scheduleAutosave();
      }

      function startSessionPoller() {
        if (sessionPoller) return;
        sessionPoller = setInterval(pollSessionStatuses, 3500);
      }

      function initChatSessions() {
        if (!chatSessions.length) {
          const first = createSessionRecord(makeSessionName(1));
          first.id = 'chat-1';
          first.color = SESSION_COLORS[0];
          first.step_states = { plan: '', approve: '', code: '', render: '' };
          chatSessions.push(first);
        }
        if (!activeChatSessionId) activeChatSessionId = chatSessions[0].id;
        restoreSessionState(getActiveChatSession());
        renderChatSessions();
      }

      const tabs = Array.from(document.querySelectorAll('.tab'));
      const panels = Array.from(document.querySelectorAll('.tab-panel'));
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const target = tab.dataset.tab;
          panels.forEach(p => p.classList.toggle('active', p.dataset.tab === target));
        });
      });

      function initSplitter(splitter, side) {
        let startX = 0;
        let startLeft = 0;
        let startRight = 0;

        splitter.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startX = e.clientX;
          const sizes = getLayoutSizes();
          startLeft = Number(sizes.left) || 280;
          startRight = Number(sizes.right) || 360;
          const prevUserSelect = document.body.style.userSelect;
          const prevCursor = document.body.style.cursor;
          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'col-resize';

          function onMove(ev) {
            const dx = ev.clientX - startX;
            if (side === 'left') {
              const next = Math.max(220, Math.min(520, startLeft + dx));
              saveLayoutSizes(next, startRight);
            } else {
              const next = Math.max(260, Math.min(560, startRight - dx));
              saveLayoutSizes(startLeft, next);
            }
            applyLayoutColumns();
          }

          function onUp() {
            window.removeEventListener('mousemove', onMove);
            window.removeEventListener('mouseup', onUp);
            document.body.style.userSelect = prevUserSelect;
            document.body.style.cursor = prevCursor;
          }

          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
        });
      }
      initSplitter(splitterLeft, 'left');
      initSplitter(splitterRight, 'right');

      function initCanvasSplitter() {
        if (!canvasSplitterEl || !canvasGridEl) return;
        applyCanvasTopSplit(getCanvasTopSplit());
        let dragging = false;
        let startY = 0;
        let startTopPct = getCanvasTopSplit();
        let rect = canvasGridEl.getBoundingClientRect();
        let prevUserSelect = '';
        let prevCursor = '';

        function onMove(ev) {
          if (!dragging) return;
          const dy = ev.clientY - startY;
          const deltaPct = (dy / Math.max(1, rect.height)) * 100;
          const next = clampNumber(startTopPct + deltaPct, 42, 86);
          applyCanvasTopSplit(next);
        }
        function onUp() {
          if (!dragging) return;
          dragging = false;
          const topNow = parseFloat((canvasGridEl.style.getPropertyValue('--canvas-top') || '').replace('%', '')) || startTopPct;
          saveCanvasTopSplit(topNow);
          document.body.style.userSelect = prevUserSelect;
          document.body.style.cursor = prevCursor;
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
        }
        function onDown(e) {
          e.preventDefault();
          dragging = true;
          startY = e.clientY;
          rect = canvasGridEl.getBoundingClientRect();
          const curTop = parseFloat((canvasGridEl.style.getPropertyValue('--canvas-top') || '').replace('%', ''));
          startTopPct = Number.isFinite(curTop) ? curTop : getCanvasTopSplit();
          prevUserSelect = document.body.style.userSelect;
          prevCursor = document.body.style.cursor;
          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'row-resize';
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', onUp);
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
        }

        canvasSplitterEl.addEventListener('pointerdown', onDown);
      }
      initCanvasSplitter();
      // Keep layout sane across resizes and avoid "panels disappeared" glitches.
      try {
        mqNarrow.addEventListener('change', applyLayoutColumns);
      } catch {
        try { mqNarrow.addListener(applyLayoutColumns); } catch {}
      }
      window.addEventListener('resize', applyLayoutColumns);

      function parseAspectRatioValue(ratio) {
        const m = String(ratio || '').trim().match(/^(\d+(?:\.\d+)?)\s*[:/]\s*(\d+(?:\.\d+)?)$/);
        if (!m) return null;
        const w = Number(m[1]);
        const h = Number(m[2]);
        if (!Number.isFinite(w) || !Number.isFinite(h) || w <= 0 || h <= 0) return null;
        return { w, h };
      }

      function setPreviewAspect(ratio) {
        const parsed = parseAspectRatioValue(ratio);
        const safe = parsed ? `${parsed.w} / ${parsed.h}` : '9 / 16';
        previewSlot.style.setProperty('--preview-aspect', safe);
        const val = parsed ? `${parsed.w}:${parsed.h}` : '9:16';
        if (aspectEl && aspectEl.value !== val) aspectEl.value = val;
        if (aspectQuickEl && aspectQuickEl.value !== val) aspectQuickEl.value = val;
      }

      function syncComposeModeChips() {
        composeModeChips.forEach((chip) => {
          const input = chip.querySelector('input[type="checkbox"]');
          chip.classList.toggle('checked', !!(input && input.checked));
        });
      }

      function refreshTimelineVisibility() {
        if (!canvasGridEl) return;
        canvasGridEl.classList.toggle('timeline-hidden', !!timelineHidden);
        if (timelineHideBtnEl) timelineHideBtnEl.textContent = timelineHidden ? 'Show' : 'Hide';
        if (toggleTimelineBtnEl) toggleTimelineBtnEl.title = timelineHidden ? 'Show timeline' : 'Hide timeline';
      }

      function setTimelineHidden(hidden, persist = true) {
        timelineHidden = !!hidden;
        refreshTimelineVisibility();
        if (persist) scheduleAutosave();
      }

      function updateCutRangeLabel() {
        if (!cutRangeLabelEl) return;
        if (cutStartSec == null && cutEndSec == null) {
          cutRangeLabelEl.textContent = 'Cut range: not set';
          return;
        }
        const left = cutStartSec == null ? '--:--' : fmtTime(cutStartSec);
        const right = cutEndSec == null ? '--:--' : fmtTime(cutEndSec);
        cutRangeLabelEl.textContent = `Cut range: ${left} -> ${right}`;
      }

      function applyVibePreset(preset, announce = false) {
        const p = String(preset || 'cinematic_science');
        if (p === 'cinematic_science') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'concise';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'cinematic_fade';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'soft_fade';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'balanced';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'bold';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '62';
        } else if (p === 'clean_education') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'callout';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'kinetic_slide';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'line_slide';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'light';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'medium';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '44';
        } else if (p === 'dramatic_docu') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'narrative';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'parallax_float';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'soft_fade';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'balanced';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'bold';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '74';
        } else if (p === 'neon_explainer') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'keyword';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'glow_pop';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'pulse_highlight';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'dense';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'bold';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '80';
        } else if (p === 'minimal_elegant') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'concise';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'typewriter';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'word_by_word';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'light';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'light';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '34';
        } else if (p === 'chalkboard_classic') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'callout';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'chalk_draw';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'line_slide';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'balanced';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'medium';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '28';
        } else if (p === 'shortform_punchy') {
          if (vibeCaptionModeEl) vibeCaptionModeEl.value = 'keyword';
          if (vibeTextAnimEl) vibeTextAnimEl.value = 'flash_cut';
          if (vibeCaptionAnimEl) vibeCaptionAnimEl.value = 'pop_stagger';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'dense';
          if (vibeTitleWeightEl) vibeTitleWeightEl.value = 'bold';
          if (vibeOverlayStrengthEl) vibeOverlayStrengthEl.value = '78';
        }
        scheduleAutosave();
        if (announce) showToast(`Applied vibe preset: ${p.replaceAll('_', ' ')}`, 'ok');
      }

      function applyOrientationGuidePreset(preset, announce = true) {
        let p = String(preset || 'auto');
        if (p === 'auto') {
          const ar = aspectEl ? aspectEl.value : '9:16';
          if (ar === '16:9') p = 'landscape_16_9';
          else if (ar === '1:1') p = 'square_1_1';
          else p = 'portrait_9_16';
        }
        if (p === 'portrait_9_16') {
          if (aspectEl) aspectEl.value = '9:16';
          if (vibeCaptionPositionEl) vibeCaptionPositionEl.value = 'lower_third';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'balanced';
          if (maxObjectsEl && !maxObjectsEl.value.trim()) maxObjectsEl.value = '5';
        } else if (p === 'landscape_16_9') {
          if (aspectEl) aspectEl.value = '16:9';
          if (vibeCaptionPositionEl) vibeCaptionPositionEl.value = 'top';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'light';
          if (maxObjectsEl && !maxObjectsEl.value.trim()) maxObjectsEl.value = '7';
        } else if (p === 'square_1_1') {
          if (aspectEl) aspectEl.value = '1:1';
          if (vibeCaptionPositionEl) vibeCaptionPositionEl.value = 'center';
          if (vibeCaptionDensityEl) vibeCaptionDensityEl.value = 'light';
          if (maxObjectsEl && !maxObjectsEl.value.trim()) maxObjectsEl.value = '5';
        }
        if (aspectEl) setPreviewAspect(aspectEl.value);
        scheduleAutosave();
        if (announce) showToast(`Applied orientation: ${p.replaceAll('_', ' ')}`, 'ok');
      }

      function setStep(step, state) {
        const el = agentStepsEl.querySelector(`[data-step="${step}"]`);
        if (!el) return;
        el.classList.remove('active','done','error');
        if (state) el.classList.add(state);
        updateStepProgress();
        const session = getActiveChatSession();
        if (session) {
          session.step_states = session.step_states || {};
          session.step_states[step] = state || '';
          updateSessionPhase(session);
        }
      }
      function setStepNote(step, message) {
        if (!step || !message) return;
        stepNotes[step] = String(message);
        const session = getActiveChatSession();
        if (session) {
          session.step_notes = session.step_notes || {};
          session.step_notes[step] = String(message);
        }
        const active = agentStepsEl.querySelector('.agent-step.active');
        if (!active && stepDetailEl) {
          stepDetailEl.textContent = stepNotes[step] || '';
          return;
        }
        if (active && active.dataset.step === step && stepDetailEl) {
          stepDetailEl.textContent = stepNotes[step] || '';
        }
      }
      function showStepDetail(step) {
        if (!stepDetailEl) return;
        stepDetailEl.textContent = stepNotes[step] || 'No details yet.';
      }
      function resetSteps() {
        ['plan','approve','code','render'].forEach(s => setStep(s, ''));
        stepNotes.plan = 'No plan yet.';
        stepNotes.approve = 'Waiting for approval.';
        stepNotes.code = 'Code has not started.';
        stepNotes.render = 'Render has not started.';
        const session = getActiveChatSession();
        if (session) {
          session.step_notes = snapshotStepNotes();
          session.step_states = snapshotStepStates();
          updateSessionPhase(session);
        }
        Array.from(agentStepsEl.querySelectorAll('.agent-step')).forEach((el) => el.classList.remove('selected'));
        const planEl = agentStepsEl.querySelector('[data-step="plan"]');
        if (planEl) planEl.classList.add('selected');
        showStepDetail('plan');
        updateStepProgress();
      }

      function updateStepProgress() {
        if (!agentProgressFillEl || !agentStepsEl) return;
        const stepEls = ['plan', 'approve', 'code', 'render'].map((s) => agentStepsEl.querySelector(`[data-step="${s}"]`));
        let pct = 0;
        if (stepEls[0]?.classList.contains('done')) pct = 25;
        else if (stepEls[0]?.classList.contains('active')) pct = 12;
        if (stepEls[1]?.classList.contains('done')) pct = 50;
        else if (stepEls[1]?.classList.contains('active')) pct = Math.max(pct, 38);
        if (stepEls[2]?.classList.contains('done')) pct = 75;
        else if (stepEls[2]?.classList.contains('active')) pct = Math.max(pct, 62);
        if (stepEls[3]?.classList.contains('done')) pct = 100;
        else if (stepEls[3]?.classList.contains('active')) pct = Math.max(pct, 88);

        const hasError = stepEls.some((el) => el?.classList.contains('error'));
        agentProgressFillEl.style.background = hasError
          ? 'linear-gradient(90deg, #ef4444, #f59e0b)'
          : 'linear-gradient(90deg, #6aa9ff, #22c55e)';
        agentProgressFillEl.style.width = `${pct}%`;
      }
      if (agentStepsEl) {
        agentStepsEl.addEventListener('click', (e) => {
          const stepEl = e.target.closest('.agent-step');
          if (!stepEl) return;
          Array.from(agentStepsEl.querySelectorAll('.agent-step')).forEach((el) => el.classList.remove('selected'));
          stepEl.classList.add('selected');
          showStepDetail(stepEl.dataset.step || 'plan');
        });
      }

      function setFirst60Visible(visible, persist = false) {
        if (!first60PanelEl || !first60ShowBtn) return;
        first60PanelEl.classList.toggle('hidden', !visible);
        first60ShowBtn.classList.toggle('hidden', visible);
        if (persist) {
          try {
            localStorage.setItem(FIRST60_HIDE_KEY, visible ? '0' : '1');
          } catch {}
        }
      }

      function setFirst60Item(el, state, label) {
        if (!el) return;
        el.classList.remove('done', 'active');
        if (state === 'done' || state === 'active') el.classList.add(state);
        const stateEl = el.querySelector('.first60-state');
        if (stateEl) stateEl.textContent = label || 'pending';
      }

      function updateFirst60Checklist() {
        if (!first60PanelEl) return;
        const hasPrompt = !!(chatInputEl && String(chatInputEl.value || '').trim());
        const hasPlan = !!(currentJobId && currentPlanText);
        const needsImages = !!(includeImagesEl && includeImagesEl.value === 'true');
        const hasImages = !!(getThumbAsset('background') || getThumbAsset('foreground'));
        const hasRender = !!(lastVideoUrl || (videoEl && videoEl.src));

        setFirst60Item(first60ItemPromptEl, hasPrompt ? 'done' : 'active', hasPrompt ? 'done' : 'type');
        setFirst60Item(
          first60ItemPlanEl,
          hasPlan ? 'done' : (hasPrompt ? 'active' : ''),
          hasPlan ? 'done' : (hasPrompt ? 'click plan' : 'pending')
        );
        if (!needsImages) {
          setFirst60Item(first60ItemImageEl, 'done', 'optional off');
        } else {
          setFirst60Item(
            first60ItemImageEl,
            hasImages ? 'done' : (hasPlan ? 'active' : ''),
            hasImages ? 'done' : (hasPlan ? 'generate' : 'wait')
          );
        }
        const renderReady = hasPlan && (!needsImages || hasImages);
        setFirst60Item(
          first60ItemRenderEl,
          hasRender ? 'done' : (renderReady ? 'active' : ''),
          hasRender ? 'done' : (renderReady ? 'approve' : 'pending')
        );

        const total = needsImages ? 4 : 3;
        let done = 0;
        if (hasPrompt) done += 1;
        if (hasPlan) done += 1;
        if (needsImages && hasImages) done += 1;
        if (hasRender) done += 1;
        done = Math.min(done, total);
        const pct = total > 0 ? Math.round((done / total) * 100) : 0;
        if (first60ProgressEl) first60ProgressEl.style.width = `${pct}%`;
        if (first60SubEl) first60SubEl.textContent = `${done}/${total} complete`;
      }

      function addChat(role, title, content, extraNode) {
        const session = getActiveChatSession();
        const sig = `${role}|${title}|${String(content || '').slice(0, 1200)}`;
        const lastSig = session ? (session.last_sig || '') : lastChatSignature;
        if (sig === lastSig) return;
        lastChatSignature = sig;
        if (session) session.last_sig = sig;
        const bubble = document.createElement('div');
        bubble.className = `bubble ${role}`;
        bubble.innerHTML = `<div class="bubble-title">${title}</div><div>${content}</div>`;
        if (extraNode) bubble.appendChild(extraNode);
        chatMessagesEl.appendChild(bubble);
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        if (session) session.messages_html = chatMessagesEl.innerHTML;
      }

      function buildNarrationContext() {
        const bubbles = Array.from(chatMessagesEl.querySelectorAll('.bubble')).slice(-10);
        const lines = bubbles.map((el) => cleanInline(el.innerText || '')).filter(Boolean);
        return lines.join('\n').slice(0, 2500);
      }

      function jsonHtml(obj) {
        const raw = JSON.stringify(obj, null, 2);
        let esc = escapeHtml(raw);
        esc = esc.replace(/(&quot;[^&]+&quot;)(\s*:)/g, '<span style="color:#93c5fd;">$1</span>$2');
        esc = esc.replace(/:\s(&quot;[^&]*&quot;)/g, ': <span style="color:#22c55e;">$1</span>');
        esc = esc.replace(/:\s(-?\d+(?:\.\d+)?)/g, ': <span style="color:#f59e0b;">$1</span>');
        esc = esc.replace(/:\s(true|false|null)/g, ': <span style="color:#c084fc;">$1</span>');
        return esc;
      }

      function timelineSummary(planObj) {
        const plan = planObj || {};
        const scenes = Array.isArray(plan.scenes) ? plan.scenes : [];
        let cursor = 0;
        return scenes.map((sc, idx) => {
          const sec = Math.max(1, Number(sc.seconds || 1));
          const start = cursor;
          const end = cursor + sec;
          cursor = end;
          return `${idx + 1}. ${start}s-${end}s: ${compactLabel(sc.goal || 'Scene', 86)}`;
        });
      }

      function buildPlanInspector(planObj, planBox) {
        const wrap = document.createElement('div');
        const plan = planObj || {};
        const scenes = Array.isArray(plan.scenes) ? plan.scenes : [];

        const tldr = document.createElement('div');
        tldr.className = 'drawer-section';
        const lines = timelineSummary(plan);
        tldr.innerHTML = `
          <div class="drawer-title">TL;DR timeline</div>
          <div class="muted" style="margin-bottom:6px;">${escapeHtml(plan.title || 'Scene Plan')}  ${Number(plan.total_seconds || 0)}s  ${scenes.length} scenes</div>
          <pre style="margin:0; white-space:pre-wrap; max-height:140px; overflow:auto;">${escapeHtml(lines.join('\n') || 'No scenes')}</pre>
        `;

        const details = document.createElement('details');
        details.className = 'drawer-section';
        details.open = false;
        details.innerHTML = `
          <summary style="cursor:pointer; color:var(--muted);">Colorized JSON</summary>
          <pre style="margin-top:8px; max-height:220px; overflow:auto;">${jsonHtml(plan)}</pre>
        `;

        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'ghost';
        refreshBtn.textContent = 'Refresh TL;DR from edited JSON';
        refreshBtn.style.marginBottom = '8px';
        refreshBtn.addEventListener('click', () => {
          let parsed = null;
          try {
            parsed = JSON.parse(planBox.value || '{}');
          } catch {
            showToast('Plan JSON is invalid.', 'err');
            return;
          }
          const lines2 = timelineSummary(parsed);
          const scenes2 = Array.isArray(parsed.scenes) ? parsed.scenes : [];
          const titleEl = tldr.querySelector('.muted');
          if (titleEl) titleEl.textContent = `${parsed.title || 'Scene Plan'}  ${Number(parsed.total_seconds || 0)}s  ${scenes2.length} scenes`;
          const preEl = tldr.querySelector('pre');
          if (preEl) preEl.textContent = lines2.join('\n') || 'No scenes';
          const preJson = details.querySelector('pre');
          if (preJson) preJson.innerHTML = jsonHtml(parsed);
          timelineMeta.title = parsed.title || 'Scene Plan';
          timelineState = scenes2.map(sc => ({
            seconds: sc.seconds || 3,
            goal: sc.goal,
            elements: sc.elements,
            actions: sc.actions,
            narration: sc.narration,
            assets: sc.assets || {}
          }));
          renderTimeline();
          showToast('TL;DR refreshed.', 'ok');
        });

        wrap.appendChild(tldr);
        wrap.appendChild(details);
        wrap.appendChild(refreshBtn);
        return wrap;
      }

      function updateJobFiles(files) {
        jobFileListEl.innerHTML = '';
        const session = getActiveChatSession();
        if (session) session.job_files = Array.isArray(files) ? files : [];
        if (!files || !files.length) {
          jobFileListEl.innerHTML = '<div class="muted">No files yet.</div>';
          return;
        }
        files.forEach(f => {
          const item = document.createElement('div');
          item.className = 'tree-file';
          item.textContent = f;
          jobFileListEl.appendChild(item);
        });
      }

      function updateOutputPaths() {
        if (!outputPathsEl) return;
        const codePath = lastGeneratedCodePath || (currentJobId ? `notes/generated/${currentJobId}/scene.py` : 'notes/generated/<job_id>/scene.py');
        if (!currentJobId) {
          outputPathsEl.innerHTML = 'Current output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code><br><span class="muted">Project root: <code>Gemini-Hack-Manim/</code></span>';
          if (templateOutputPathEl) templateOutputPathEl.innerHTML = 'Output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code>';
          if (settingsOutputVideoPathEl) settingsOutputVideoPathEl.textContent = 'work/jobs/<job_id>/out.mp4';
          if (settingsOutputCodePathEl) settingsOutputCodePathEl.textContent = codePath;
          updateFirst60Checklist();
          return;
        }
        outputPathsEl.innerHTML = `Current output: <code>work/jobs/${currentJobId}/out.mp4</code><br><span class="muted">Scene code: <code>${codePath}</code></span>`;
        if (templateOutputPathEl) templateOutputPathEl.innerHTML = `Output: <code>work/jobs/${currentJobId}/out.mp4</code>`;
        if (settingsOutputVideoPathEl) settingsOutputVideoPathEl.textContent = `work/jobs/${currentJobId}/out.mp4`;
        if (settingsOutputCodePathEl) settingsOutputCodePathEl.textContent = codePath;
        updateFirst60Checklist();
      }

      function markTreeSelection() {
        const rows = workspaceTreeEl ? Array.from(workspaceTreeEl.querySelectorAll('.tree-row')) : [];
        rows.forEach((row) => {
          const isSel = row.dataset.path === selectedTreePath && row.dataset.kind === selectedTreeKind;
          row.classList.toggle('selected', !!isSel);
        });
      }

      function setSelectedTreePath(path, kind) {
        selectedTreePath = path || '';
        selectedTreeKind = kind || '';
        markTreeSelection();
      }

      function renderTree(node, container) {
        if (!node) return;
        if (node.type === 'dir') {
          const details = document.createElement('details');
          details.open = true;
          const summary = document.createElement('summary');
          const row = document.createElement('div');
          row.className = 'tree-row';
          row.dataset.path = node.path || '';
          row.dataset.kind = 'folder';
          if ((node.path || '') && selectedTreePath === node.path && selectedTreeKind === 'folder') {
            row.classList.add('selected');
          }
          if (node.path) {
            row.draggable = true;
            row.addEventListener('dragstart', (e) => {
              e.dataTransfer.setData('text/plain', node.path);
              e.dataTransfer.setData('text/path-kind', 'folder');
              e.dataTransfer.effectAllowed = 'copy';
            });
            row.addEventListener('click', (e) => {
              setSelectedTreePath(node.path, 'folder');
            });
            row.addEventListener('dblclick', (e) => {
              e.preventDefault();
              e.stopPropagation();
              startInlineRename(row, node.path, 'dir');
            });
            row.addEventListener('dragover', (e) => {
              const kind = e.dataTransfer.getData('text/path-kind');
              if (kind === 'file' || kind === 'folder') {
                e.preventDefault();
                row.classList.add('drop-target');
              }
            });
            row.addEventListener('dragleave', () => {
              row.classList.remove('drop-target');
            });
            row.addEventListener('drop', async (e) => {
              e.preventDefault();
              row.classList.remove('drop-target');
              const kind = e.dataTransfer.getData('text/path-kind');
              const src = e.dataTransfer.getData('text/plain');
              if (!src || !node.path) return;
              if (kind !== 'file' && kind !== 'folder') return;
              await moveWorkspacePath(src, node.path);
            });
          }
          const name = document.createElement('div');
          name.className = 'tree-row-name';
          name.textContent = node.name || 'folder';
          row.appendChild(name);
          if (node.path) {
            const actions = document.createElement('div');
            actions.className = 'tree-row-actions';
            const renameBtn = document.createElement('button');
            renameBtn.className = 'tree-act';
            renameBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 1 1 3 3L7 19l-4 1 1-4z"/></svg>';
            renameBtn.title = 'Rename';
            renameBtn.setAttribute('aria-label', 'Rename');
            renameBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              startRename(node.path, 'dir');
            });
            const delBtn = document.createElement('button');
            delBtn.className = 'tree-act danger';
            delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 14H6L5 6"/></svg>';
            delBtn.title = 'Delete folder';
            delBtn.setAttribute('aria-label', 'Delete folder');
            delBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              armInlineDelete(actions, node.path, 'folder');
            });
            actions.appendChild(renameBtn);
            actions.appendChild(delBtn);
            row.appendChild(actions);
          }
          summary.appendChild(row);
          details.appendChild(summary);
          const childrenWrap = document.createElement('div');
          childrenWrap.className = 'tree-children';
          (node.children || []).forEach(child => renderTree(child, childrenWrap));
          details.appendChild(childrenWrap);
          container.appendChild(details);
        } else {
          const item = document.createElement('div');
          item.className = 'tree-file';
          const row = document.createElement('div');
          row.className = 'tree-row';
          row.dataset.path = node.path || '';
          row.dataset.kind = 'file';
          if ((node.path || '') && selectedTreePath === node.path && selectedTreeKind === 'file') {
            row.classList.add('selected');
          }
          const name = document.createElement('div');
          name.className = 'tree-row-name';
          name.textContent = node.name;
          const actions = document.createElement('div');
          actions.className = 'tree-row-actions';
          const renameBtn = document.createElement('button');
          renameBtn.className = 'tree-act';
          renameBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 1 1 3 3L7 19l-4 1 1-4z"/></svg>';
          renameBtn.title = 'Rename';
          renameBtn.setAttribute('aria-label', 'Rename');
          renameBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startRename(node.path, 'file');
          });
          const delBtn = document.createElement('button');
          delBtn.className = 'tree-act danger';
          delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 14H6L5 6"/></svg>';
          delBtn.title = 'Delete file';
          delBtn.setAttribute('aria-label', 'Delete file');
          delBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            armInlineDelete(actions, node.path, 'file');
          });
          actions.appendChild(renameBtn);
          actions.appendChild(delBtn);
          row.appendChild(name);
          row.appendChild(actions);
          item.appendChild(row);
          item.draggable = true;
          item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', node.path);
            e.dataTransfer.setData('text/path-kind', 'file');
            e.dataTransfer.effectAllowed = 'copy';
          });
          item.addEventListener('click', () => {
            setSelectedTreePath(node.path, 'file');
            openWorkspaceFile(node.path);
          });
          row.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startInlineRename(row, node.path, 'file');
          });
          container.appendChild(item);
        }
      }

      async function deleteWorkspacePath(path) {
        if (!path) return;
        fileStatusEl.textContent = `Deleting ${path}...`;
        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`, { method: 'DELETE' });
          const data = await resp.json();
          if (!data.ok) {
            fileStatusEl.textContent = data.error || 'Delete failed.';
            return;
          }
          if (openFilePath && (openFilePath === path || openFilePath.startsWith(`${path}/`))) {
            openFilePath = null;
            codeEl.value = '';
            refreshGutter();
            if (highlightOn) refreshHighlight();
            updateEditorMode();
          }
          for (let i = editorTabsState.length - 1; i >= 0; i--) {
            const t = editorTabsState[i];
            if (!t.path) continue;
            if (t.path === path || t.path.startsWith(`${path}/`)) editorTabsState.splice(i, 1);
          }
          if (!editorTabsState.some((t) => t.id === activeEditorTabId)) {
            activeEditorTabId = 'generated';
            ensureGeneratedTab();
            applyActiveEditorTab();
          }
          renderEditorTabs();
          if (selectedTreePath && (selectedTreePath === path || selectedTreePath.startsWith(`${path}/`))) {
            setSelectedTreePath('', '');
          }
          fileStatusEl.textContent = `Deleted: ${path}`;
          await loadWorkspaceFiles();
          showToast('Deleted.', 'ok');
          pushHistory(`Deleted ${path}`);
        } catch {
          fileStatusEl.textContent = 'Failed to reach backend.';
        }
      }

      async function moveWorkspacePath(srcPath, destDir) {
        if (!srcPath || !destDir) return;
        if (srcPath === destDir || destDir.startsWith(`${srcPath}/`)) return;
        const base = srcPath.split('/').pop() || srcPath;
        const target = `${destDir}/${base}`;
        fileStatusEl.textContent = `Moving ${srcPath}  ${target}...`;
        try {
          const resp = await fetch('/api/files/rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ from_path: srcPath, to_path: target, overwrite: false })
          });
          const data = await resp.json();
          if (!data.ok) {
            fileStatusEl.textContent = data.error || 'Move failed.';
            return;
          }
          await loadWorkspaceFiles();
          if (openFilePath === srcPath) {
            openFilePath = target;
            updateEditorMode();
          }
          pushHistory(`Moved ${srcPath}  ${target}`);
          fileStatusEl.textContent = `Moved: ${target}`;
        } catch {
          fileStatusEl.textContent = 'Failed to reach backend.';
        }
      }

      function armInlineDelete(actionsEl, path, kind) {
        if (!actionsEl || !path) return;
        actionsEl.innerHTML = '';
        const yesBtn = document.createElement('button');
        yesBtn.className = 'tree-act confirm';
        yesBtn.title = `Confirm delete ${kind}`;
        yesBtn.setAttribute('aria-label', `Confirm delete ${kind}`);
        yesBtn.textContent = '';
        yesBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await deleteWorkspacePath(path);
        });
        const noBtn = document.createElement('button');
        noBtn.className = 'tree-act reject';
        noBtn.title = 'Cancel';
        noBtn.setAttribute('aria-label', 'Cancel delete');
        noBtn.textContent = '';
        noBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          loadWorkspaceFiles();
          fileStatusEl.textContent = 'Delete cancelled.';
        });
        actionsEl.appendChild(yesBtn);
        actionsEl.appendChild(noBtn);
      }

      function setActiveTab(tabId) {
        const tabs = Array.from(document.querySelectorAll('.tab'));
        const panels = Array.from(document.querySelectorAll('.tab-panel'));
        tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabId));
        panels.forEach(p => p.classList.toggle('active', p.dataset.tab === tabId));
      }

      function contextPanelHeightForTab(id) {
        return 168;
      }

      function applyContextPanelHeight(id) {
        if (!contextPanelShellEl) return;
        const px = contextPanelHeightForTab(id || 'memory');
        contextPanelShellEl.style.setProperty('--context-panel-height', `${px}px`);
      }

      function setSourceStatus(message, kind = 'muted') {
        if (!sourceStatusEl) return;
        sourceStatusEl.textContent = String(message || '');
        sourceStatusEl.classList.remove('loading', 'ok', 'warn', 'err', 'muted');
        sourceStatusEl.classList.add(kind || 'muted');
      }

      function setContextTab(id) {
        ctxTabs.forEach(b => {
          const on = b.dataset.ctx === id;
          b.classList.toggle('active', on);
          b.setAttribute('aria-selected', on ? 'true' : 'false');
        });
        ctxPanels.forEach(p => p.classList.toggle('active', p.dataset.ctx === id));
        applyContextPanelHeight(id);
      }
      ctxTabs.forEach(b => b.addEventListener('click', () => setContextTab(b.dataset.ctx)));
      applyContextPanelHeight('memory');

      if (saveProjectBtn) saveProjectBtn.addEventListener('click', () => saveProject(false));
      function safeOn(el, eventName, handler) {
        if (el) el.addEventListener(eventName, handler);
      }

      function bindAutosave(el, ev = 'input') {
        if (!el) return;
        el.addEventListener(ev, () => scheduleAutosave());
      }
      bindAutosave(chatInputEl, 'input');
      bindAutosave(chatModelEl, 'change');
      bindAutosave(geminiAssistEl, 'change');
      safeOn(chatInputEl, 'input', () => {
        const session = getActiveChatSession();
        if (session) session.prompt = chatInputEl.value || '';
        updateFirst60Checklist();
      });
      safeOn(chatModelEl, 'change', () => {
        const session = getActiveChatSession();
        if (session) session.model = chatModelEl.value || '';
      });
      bindAutosave(directorBriefEl, 'input');
      bindAutosave(rulesTextEl, 'input');
      bindAutosave(subagentsTextEl, 'input');
      bindAutosave(templateSelectEl, 'change');
      bindAutosave(imagePresetEl, 'change');
      bindAutosave(imageAssetTypeEl, 'change');
      bindAutosave(imagePromptEl, 'input');
      bindAutosave(imageMinorEditEl, 'input');
      bindAutosave(imageModeEl, 'change');
      bindAutosave(imageVariantsEl, 'change');
      bindAutosave(includeImagesEl, 'change');
      safeOn(includeImagesEl, 'change', updateFirst60Checklist);
      bindAutosave(aspectEl, 'change');
      bindAutosave(audienceEl, 'change');
      bindAutosave(toneEl, 'change');
      bindAutosave(styleEl, 'change');
      bindAutosave(paceEl, 'change');
      bindAutosave(paletteEl, 'change');
      bindAutosave(qualityEl, 'change');
      bindAutosave(targetSecondsEl, 'input');
      bindAutosave(maxScenesEl, 'input');
      bindAutosave(maxObjectsEl, 'input');
      bindAutosave(equationsEl, 'change');
      bindAutosave(graphsEl, 'change');
      bindAutosave(narrationEl, 'change');
      bindAutosave(imageModelOverrideEl, 'change');
      bindAutosave(creativeMotionEl, 'input');
      bindAutosave(creativeDensityEl, 'input');
      bindAutosave(creativeEnergyEl, 'input');
      bindAutosave(creativeComplexityEl, 'input');
      bindAutosave(creativePolishEl, 'input');
      bindAutosave(creativePrecisionEl, 'input');
      bindAutosave(vibeEnableEl, 'change');
      bindAutosave(vibePresetEl, 'change');
      bindAutosave(orientationGuideEl, 'change');
      bindAutosave(vibeTitleEl, 'input');
      bindAutosave(vibeCaptionModeEl, 'change');
      bindAutosave(vibeTextAnimEl, 'change');
      bindAutosave(vibeCaptionAnimEl, 'change');
      bindAutosave(vibeCaptionPositionEl, 'change');
      bindAutosave(vibeCaptionDensityEl, 'change');
      bindAutosave(vibeOverlayStrengthEl, 'input');
      bindAutosave(vibeTitleWeightEl, 'change');
      [creativeMotionEl, creativeDensityEl, creativeEnergyEl, creativeComplexityEl, creativePolishEl, creativePrecisionEl]
        .forEach((el) => safeOn(el, 'input', refreshCreativeReadouts));

      function updateEditorMode() {
        if (!openFilePath) {
          editorLabelEl.textContent = 'Editor  generated code';
          saveFileBtn.disabled = true;
          renderCodeBtn.disabled = false;
          addSelectionBtn.disabled = false;
          return;
        }
        editorLabelEl.textContent = `Editor  ${openFilePath}`;
        saveFileBtn.disabled = false;
        const canRender = openFilePath.endsWith('.py');
        renderCodeBtn.disabled = !canRender;
        addSelectionBtn.disabled = false;
      }

      function lineOfIndex(text, idx) {
        if (idx <= 0) return 1;
        let n = 1;
        for (let i = 0; i < idx && i < text.length; i++) {
          if (text[i] === '\\n') n += 1;
        }
        return n;
      }

      function addSelectionToPrompt() {
        const text = codeEl.value || '';
        const a = codeEl.selectionStart ?? 0;
        const b = codeEl.selectionEnd ?? 0;
        if (a === b) {
          statusEl.textContent = 'Select some text in the editor first.';
          return;
        }
        const sel = text.slice(a, b);
        const l1 = lineOfIndex(text, a);
        const l2 = lineOfIndex(text, b);
        const label = openFilePath ? `${openFilePath}:${l1}-${l2}` : `generated_scene.py:${l1}-${l2}`;
        chatInputEl.value += `\n\n[@ref ${label}]\n${sel}\n`;
        statusEl.textContent = `Added selection to prompt: ${label}`;
      }

      addSelectionBtn.addEventListener('click', addSelectionToPrompt);

      function animateCodeIntoEditor(code, opts) {
        const immediate = !!(opts && opts.immediate);
        const target = String(code || '');
        if (immediate || target.length < 400) {
          codeEl.value = target;
          refreshGutter();
          if (highlightOn) refreshHighlight();
          return;
        }
        // Fast "typing" illusion: chunk in quickly without freezing the UI.
        codeEl.value = '';
        refreshGutter();
        const chunk = 220;
        let i = 0;
        function tick() {
          i = Math.min(target.length, i + chunk);
          codeEl.value = target.slice(0, i);
          refreshGutter();
          if (highlightOn) refreshHighlight();
          if (i < target.length) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      function resolvePreferredCodePath(preferredPath = '') {
        const raw = String(preferredPath || '').trim();
        if (raw && raw.toLowerCase().endsWith('.py')) return raw;
        const active = getActiveEditorTab();
        const activePath = String(active?.path || '').trim();
        if (activePath && activePath.toLowerCase().endsWith('.py')) return activePath;
        const openPath = String(openFilePath || '').trim();
        if (openPath && openPath.toLowerCase().endsWith('.py')) return openPath;
        if (selectedTreeKind === 'file') {
          const sel = String(selectedTreePath || '').trim();
          if (sel && sel.toLowerCase().endsWith('.py')) return sel;
        }
        return '';
      }

      function ensureHighlightMode() {
        if (!highlightOn) {
          highlightOn = true;
          if (codePrettyWrapEl) codePrettyWrapEl.classList.remove('hidden');
          if (codeEditorEl) codeEditorEl.classList.add('hidden');
          if (toggleHighlightBtn) toggleHighlightBtn.textContent = 'Edit';
        }
        refreshHighlight();
      }

      async function persistGeneratedSceneFile(code, focusEditor = false, preferredPath = '') {
        if (!currentJobId || !code) return;
        const path = resolvePreferredCodePath(preferredPath) || `notes/generated/${currentJobId}/scene.py`;
        const signature = `${currentJobId}:${path}:${code.length}:${String(code).slice(0, 128)}`;
        if (persistedSceneSignature === signature) return;
        upsertGeneratedTab(code);
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: code, overwrite: true })
          });
          const data = await resp.json();
          if (data.ok) {
            persistedSceneSignature = signature;
            lastGeneratedCodePath = data.path || path;
            updateOutputPaths();
            upsertFileTab(data.path, code, !!focusEditor);
            if (focusEditor) {
              activeEditorTabId = `file:${data.path}`;
              applyActiveEditorTab();
              renderEditorTabs();
            }
            setSelectedTreePath(data.path, 'file');
            await loadWorkspaceFiles();
            pushHistory(`Generated ${data.path}`);
          }
        } catch {}
      }

      async function tryWriteWorkspaceFile(path, content) {
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: content || '' })
          });
          const data = await resp.json();
          if (data.ok) return data.path;
          return null;
        } catch {
          return null;
        }
      }

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error('read failed'));
          reader.onload = () => {
            const out = String(reader.result || '');
            const base64 = out.includes(',') ? out.split(',', 2)[1] : out;
            resolve(base64 || '');
          };
          reader.readAsDataURL(file);
        });
      }

      async function uploadImageToCurrentJob(file, role) {
        if (!currentJobId) {
          showToast('Create plan first to upload image assets.', 'err');
          return null;
        }
        const base64 = await fileToBase64(file);
        const resp = await fetch('/api/jobs/upload-asset', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            job_id: currentJobId,
            filename: file.name || 'image.png',
            content_base64: base64,
            role: role || 'background'
          })
        });
        const data = await resp.json();
        if (!data.ok) {
          showToast(data.error || 'Image upload failed.', 'err');
          return null;
        }
        return data.asset_path || null;
      }

      // Override attach handler to support image uploads as assets.
      async function attachFilesFromPicker(files) {
        const list = Array.from(files || []);
        if (!list.length) return;
        for (const f of list) {
          const isImage = (f.type || '').startsWith('image/');
          if (f.size > 800_000) {
            showToast(`Skipped ${f.name}: file too large for inline attach.`, 'err');
            continue;
          }
          if (isImage) {
            const role = imageModeEl.value === 'foreground' ? 'foreground' : 'background';
            const rel = await uploadImageToCurrentJob(f, role);
            if (rel) {
              chatInputEl.value += `\\n\\n[Image asset]\\nPath: ${rel}\\nUse as ${role}.\\n`;
              showToast(`Attached image: ${f.name}`, 'ok');
              if (role === 'foreground') {
                setThumb(fgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'foreground', relPath: rel });
              } else {
                setThumb(bgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'background', relPath: rel });
              }
            }
            continue;
          }
          const isText = /^text\//.test(f.type) || /\.(md|txt|py|json|yaml|yml|csv)$/i.test(f.name);
          if (!isText) {
            showToast(`Skipped ${f.name}: only text/image files are supported.`, 'err');
            continue;
          }
          const text = await f.text();
          chatInputEl.value += `\\n\\n[File: ${f.name}]\\n${text}\\n`;
          const base = `notes/uploads/${f.name}`;
          let saved = await tryWriteWorkspaceFile(base, text);
          if (!saved) {
            for (let i = 2; i < 20 && !saved; i++) {
              const cand = `notes/uploads/${f.name.replace(/(\.[^.]*)?$/, `-${i}$1`)}`;
              saved = await tryWriteWorkspaceFile(cand, text);
            }
          }
          if (saved) {
            loadWorkspaceFiles();
            showToast(`Attached + saved: ${saved}`, 'ok');
          } else {
            showToast(`Attached: ${f.name}`, 'ok');
          }
        }
      }

      if (attachBtnEl && filePickerEl) {
        attachBtnEl.addEventListener('click', () => filePickerEl.click());
        filePickerEl.addEventListener('change', (e) => {
          attachFilesFromPicker(e.target.files);
          e.target.value = '';
        });
      }

      if (chatInputEl) {
        chatInputEl.addEventListener('dragover', (e) => {
          e.preventDefault();
          chatInputEl.classList.add('drop-target');
        });
        chatInputEl.addEventListener('dragleave', () => {
          chatInputEl.classList.remove('drop-target');
        });
        chatInputEl.addEventListener('drop', (e) => {
          e.preventDefault();
          chatInputEl.classList.remove('drop-target');
          if (e.dataTransfer?.files?.length) {
            attachFilesFromPicker(e.dataTransfer.files);
          }
        });
      }

      // Voice input (Chrome Web Speech). This is a best-effort enhancement.
      let recognition = null;
      let voiceOn = false;
      function setVoiceOn(on) {
        voiceOn = !!on;
        if (voiceBtnEl) voiceBtnEl.style.borderColor = voiceOn ? 'rgba(34,197,94,0.7)' : 'var(--border)';
      }
      if (voiceBtnEl) {
        voiceBtnEl.addEventListener('click', () => {
          const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!Rec) {
            showToast('Voice input not supported in this browser.', 'err');
            return;
          }
          if (!recognition) {
            recognition = new Rec();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            recognition.onresult = (event) => {
              let finalText = '';
              let interim = '';
              for (let i = event.resultIndex; i < event.results.length; i++) {
                const res = event.results[i];
                const t = res[0]?.transcript || '';
                if (res.isFinal) finalText += t;
                else interim += t;
              }
              if (finalText) chatInputEl.value += (chatInputEl.value.endsWith(' ') ? '' : ' ') + finalText.trim() + ' ';
              if (interim) statusEl.textContent = `Listening ${interim.trim()}`;
            };
            recognition.onerror = () => {
              setVoiceOn(false);
              statusEl.textContent = 'Voice stopped.';
            };
            recognition.onend = () => {
              setVoiceOn(false);
              statusEl.textContent = 'Ready.';
            };
          }
          if (!voiceOn) {
            try {
              recognition.start();
              setVoiceOn(true);
              statusEl.textContent = 'Listening';
            } catch {
              // Ignore repeated start errors.
            }
          } else {
            try { recognition.stop(); } catch {}
            setVoiceOn(false);
          }
        });
      }

      function escapeHtml(s) {
        return String(s || '')
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }

      function refreshGutter() {
        if (!codeGutterEl) return;
        const lineCount = Math.max(1, String(codeEl.value || '').split('\\n').length);
        let out = '';
        for (let i = 1; i <= lineCount; i++) out += i + '\\n';
        codeGutterEl.textContent = out;
        // Keep gutter scroll aligned.
        codeGutterEl.scrollTop = codeEl.scrollTop;
      }

      let highlightOn = true;
      function refreshHighlight() {
        const src = codeEl.value || '';
        let html = '';
        if (window.hljs && window.hljs.highlight) {
          try {
            html = window.hljs.highlight(src, { language: 'python' }).value || '';
          } catch {
            html = escapeHtml(src);
          }
        } else {
          html = escapeHtml(src);
        }
        const lines = html.split('\\n');
        codePrettyEl.innerHTML = lines.map((line) => {
          // Preserve empty lines so counters stay correct.
          const safe = (line && line.length) ? line : '&nbsp;';
          return `<span class=\"code-line\"><span>${safe}</span></span>`;
        }).join('\\n');
      }

      // Default to colorized code view; click "Edit" to switch to raw editor.
      if (codePrettyWrapEl) codePrettyWrapEl.classList.remove('hidden');
      if (codeEditorEl) codeEditorEl.classList.add('hidden');
      if (toggleHighlightBtn) toggleHighlightBtn.textContent = 'Edit';

      safeOn(toggleHighlightBtn, 'click', () => {
        highlightOn = !highlightOn;
        codePrettyWrapEl.classList.toggle('hidden', !highlightOn);
        if (codeEditorEl) codeEditorEl.classList.toggle('hidden', highlightOn);
        toggleHighlightBtn.textContent = highlightOn ? 'Edit' : 'Highlight';
        if (highlightOn) refreshHighlight();
        else codeEl.focus();
      });

      codeEl.addEventListener('scroll', () => refreshGutter());
      codeEl.addEventListener('input', () => {
        syncCurrentEditorIntoActiveTab();
        refreshGutter();
        if (highlightOn) refreshHighlight();
        scheduleAutosave();
      });
      function sceneIndexSummary(indexes, totalScenes = 0) {
        if (!Array.isArray(indexes) || !indexes.length) return 'none';
        const sorted = Array.from(new Set(indexes)).sort((a, b) => a - b);
        if (totalScenes > 0 && sorted.length === totalScenes) return 'all scenes';
        const out = [];
        let start = sorted[0];
        let prev = sorted[0];
        for (let i = 1; i < sorted.length; i++) {
          const cur = sorted[i];
          if (cur === prev + 1) {
            prev = cur;
            continue;
          }
          out.push(start === prev ? `S${start + 1}` : `S${start + 1}-S${prev + 1}`);
          start = cur;
          prev = cur;
        }
        out.push(start === prev ? `S${start + 1}` : `S${start + 1}-S${prev + 1}`);
        return out.join(', ');
      }

      function refreshAppliedAssetInfo() {
        if (bgAppliedInfoEl) {
          const bgIdx = [];
          timelineState.forEach((sc, i) => {
            if (sc?.assets?.background) bgIdx.push(i);
          });
          bgAppliedInfoEl.textContent = `Applied to: ${sceneIndexSummary(bgIdx, timelineState.length)}`;
        }
        if (fgAppliedInfoEl) {
          const fgIdx = [];
          timelineState.forEach((sc, i) => {
            if (sc?.assets?.foreground) fgIdx.push(i);
          });
          fgAppliedInfoEl.textContent = `Applied to: ${sceneIndexSummary(fgIdx, timelineState.length)}`;
        }
      }

      function getThumbAsset(role) {
        const el = role === 'foreground' ? fgThumbEl : bgThumbEl;
        if (!el) return '';
        return String(el.dataset.assetPath || '').trim();
      }

      function parseSceneTargetIndex(raw) {
        const text = String(raw || '').trim();
        if (!text) return -1;
        const m = text.match(/\d+/);
        if (!m) return -1;
        const idx = Number(m[0]) - 1;
        if (!Number.isFinite(idx)) return -1;
        if (idx < 0 || idx >= timelineState.length) return -1;
        return idx;
      }

      function refreshSceneTargetPlaceholders() {
        const hint = timelineState.length > 0 ? `1-${timelineState.length}` : 'Scene #';
        if (bgSceneTargetEl && !String(bgSceneTargetEl.value || '').trim()) bgSceneTargetEl.placeholder = hint;
        if (fgSceneTargetEl && !String(fgSceneTargetEl.value || '').trim()) fgSceneTargetEl.placeholder = hint;
      }

      function notifyImageChangeNeedsRerender() {
        if (!lastVideoUrl) return;
        statusEl.textContent = 'Image mapping updated. Re-render to apply changes to the MP4.';
        showToast('Image mapping changed. Approve & Render to update the video.', 'ok');
      }

      function applyAssetToScene(role, idx) {
        const assetPath = getThumbAsset(role);
        if (!assetPath) {
          showToast(`Generate a ${role} image first.`, 'err');
          return;
        }
        if (!timelineState.length) {
          showToast('Create plan first.', 'err');
          return;
        }
        if (idx < 0 || idx >= timelineState.length) {
          showToast(`Pick a valid scene number (1-${timelineState.length}).`, 'err');
          return;
        }
        const sc = timelineState[idx];
        sc.assets = sc.assets || {};
        sc.assets[role] = assetPath;
        renderTimeline();
        showToast(`${role === 'background' ? 'BG' : 'FG'} applied to scene ${idx + 1}.`, 'ok');
        notifyImageChangeNeedsRerender();
      }

      function applyAssetToSceneFromInput(role, inputEl) {
        if (!timelineState.length) {
          showToast('Create plan first.', 'err');
          return;
        }
        const idx = parseSceneTargetIndex(inputEl ? inputEl.value : '');
        if (idx < 0) {
          showToast(`Enter a valid scene number (1-${timelineState.length}).`, 'err');
          return;
        }
        applyAssetToScene(role, idx);
      }

      function applyAssetToAllScenes(role) {
        const assetPath = getThumbAsset(role);
        if (!assetPath) {
          showToast(`Generate a ${role} image first.`, 'err');
          return;
        }
        if (!timelineState.length) {
          showToast('Create plan first.', 'err');
          return;
        }
        timelineState.forEach((sc) => {
          sc.assets = sc.assets || {};
          sc.assets[role] = assetPath;
        });
        renderTimeline();
        showToast(`${role === 'background' ? 'BG' : 'FG'} applied to all scenes.`, 'ok');
        notifyImageChangeNeedsRerender();
      }

      function clearAssetFromAllScenes(role) {
        if (!timelineState.length) return;
        timelineState.forEach((sc) => {
          if (!sc.assets) return;
          delete sc.assets[role];
        });
        renderTimeline();
        showToast(`${role === 'background' ? 'BG' : 'FG'} cleared from scenes.`, 'ok');
        notifyImageChangeNeedsRerender();
      }

      function resetSceneAssetAssignments() {
        if (!timelineState.length) {
          showToast('Create plan first.', 'err');
          return;
        }
        timelineState.forEach((sc) => {
          if (!sc.assets) return;
          delete sc.assets.background;
          delete sc.assets.foreground;
        });
        renderTimeline();
        showToast('Cleared BG/FG mapping for all scenes.', 'ok');
        notifyImageChangeNeedsRerender();
      }

      function setThumb(el, opts) {
        const url = opts?.url || '';
        const type = opts?.type || '';
        const relPath = opts?.relPath || '';
        const items = Array.isArray(opts?.items) ? opts.items : [];
        const list = items.length ? items : (url ? [{ url, relPath }] : []);
        const statusEl = type === 'foreground' ? fgVariantStatusEl : bgVariantStatusEl;
        el.innerHTML = '';
        el.dataset.assetType = type;
        el.dataset.assetPath = relPath || (list[0]?.relPath || '');
        if (!list.length) {
          el.textContent = 'No image yet';
          el.classList.remove('draggable');
          el.removeAttribute('draggable');
          if (statusEl) statusEl.textContent = 'Selected variant: none';
          refreshAppliedAssetInfo();
          updateFirst60Checklist();
          return;
        }
        const grid = document.createElement('div');
        grid.className = 'asset-grid';
        list.forEach((item, idx) => {
          const cell = document.createElement('div');
          cell.className = 'asset-item';
          if (idx === 0) cell.classList.add('selected');
          cell.draggable = true;
          cell.title = `Drag into a scene (${type})`;
          const img = document.createElement('img');
          img.src = item.url || '';
          img.alt = type;
          cell.appendChild(img);
          const label = document.createElement('div');
          label.className = 'asset-item-label';
          label.textContent = `${idx + 1}`;
          cell.appendChild(label);
          cell.addEventListener('click', () => {
            Array.from(grid.querySelectorAll('.asset-item')).forEach((el2) => el2.classList.remove('selected'));
            cell.classList.add('selected');
            el.dataset.assetPath = item.relPath || '';
            if (type === 'background') lastAssets.background = item.relPath || '';
            if (type === 'foreground') lastAssets.foreground = item.relPath || '';
            if (statusEl) statusEl.textContent = `Selected variant: ${idx + 1} / ${list.length}`;
            refreshAppliedAssetInfo();
          });
          cell.ondragstart = (e) => {
            e.dataTransfer.setData('text/asset-type', type);
            e.dataTransfer.setData('text/asset-path', item.relPath || '');
            e.dataTransfer.effectAllowed = 'copy';
          };
          grid.appendChild(cell);
        });
        el.appendChild(grid);
        el.classList.add('draggable');
        if (statusEl) statusEl.textContent = `Selected variant: 1 / ${list.length}`;
        refreshAppliedAssetInfo();
        updateFirst60Checklist();
      }

      async function generateImages() {
        if (!currentJobId) {
          showToast('Create plan first so images can be stored under a job folder.', 'err');
          statusEl.textContent = 'Create plan first, then click Generate images.';
          return;
        }
        const prompt = buildImagePrompt().trim();
        if (!prompt) {
          showToast('Add an image prompt first.', 'err');
          return;
        }
        if (genImagesBtn) genImagesBtn.disabled = true;
        try {
          setBusy(true, 'Generating images', 'Images');
          await new Promise(requestAnimationFrame);
          const resp = await fetch('/api/images/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              job_id: currentJobId,
              image_prompt: prompt,
              image_mode: imageModeEl.value,
              image_model: imageModelOverrideEl.value || null,
              variants: imageVariantsEl ? Number(imageVariantsEl.value || 1) : 1
            })
          });
          const data = await parseApiResponse(resp, 'Image generation failed.');
          if (!data.ok) {
            showToast(data.error || 'Image generation failed.', 'err');
            return;
          }
          const bgList = Array.isArray(data.assets?.backgrounds)
            ? data.assets.backgrounds
            : (data.assets?.background ? [data.assets.background] : []);
          const fgList = Array.isArray(data.assets?.foregrounds)
            ? data.assets.foregrounds
            : (data.assets?.foreground ? [data.assets.foreground] : []);
          if (bgList.length) {
            setThumb(bgThumbEl, {
              type: 'background',
              items: bgList.map((rel) => ({ url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, relPath: rel }))
            });
          } else {
            setThumb(bgThumbEl, { url: '', type: 'background', relPath: '' });
          }
          if (fgList.length) {
            setThumb(fgThumbEl, {
              type: 'foreground',
              items: fgList.map((rel) => ({ url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, relPath: rel }))
            });
          } else {
            setThumb(fgThumbEl, { url: '', type: 'foreground', relPath: '' });
          }
          if (data.warning) {
            logsEl.textContent = data.warning;
            showToast('Images: partial failure (see logs).', 'err');
          } else {
            showToast('Images generated. Drag BG/FG into scenes.', 'ok');
            pushHistory(`Generated images for ${currentJobId}`);
            if (lastVideoUrl) {
              statusEl.textContent = 'New images generated. Drop onto scenes, then re-render to apply.';
            } else {
              statusEl.textContent = 'Images ready. Apply to scenes before Approve & Render (or re-render later).';
            }
          }
          scheduleAutosave();
        } catch (e) {
          showToast('Backend not reachable.', 'err');
        } finally {
          setBusy(false);
          if (genImagesBtn) genImagesBtn.disabled = false;
        }
      }

      async function openWorkspaceFile(path) {
        if (!path) return;
        setSelectedTreePath(path, 'file');
        syncCurrentEditorIntoActiveTab();
        let data = null;
        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`);
          data = await resp.json();
        } catch (e) {
          logsEl.textContent = 'Failed to reach backend.';
          return;
        }
        if (!data.ok) {
          logsEl.textContent = data.error || 'Failed to open file.';
          return;
        }
        upsertFileTab(data.path, data.content || '');
        openFileContent = data.content || '';
        pushHistory(`Opened ${data.path}`);
        setActiveTab('code');
        codeEl.focus();
      }

      async function saveWorkspaceFile() {
        if (!openFilePath) return;
        syncCurrentEditorIntoActiveTab();
        let data = null;
        try {
          const resp = await fetch('/api/files/file', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: openFilePath, content: codeEl.value })
          });
          data = await resp.json();
        } catch (e) {
          logsEl.textContent = 'Failed to reach backend.';
          return;
        }
        if (!data.ok) {
          logsEl.textContent = data.error || 'Failed to save file.';
          return;
        }
        const tab = getActiveEditorTab();
        if (tab) tab.content = codeEl.value || '';
        openFileContent = codeEl.value || '';
        logsEl.textContent = `Saved: ${openFilePath}`;
        showToast(`Saved: ${openFilePath}`, 'ok');
        pushHistory(`Saved ${openFilePath}`);
      }

      function startRename(fromPath, kind = '') {
        pendingRenameFrom = fromPath;
        pendingRenameKind = kind || '';
        newPathEl.value = fromPath;
        newPathEl.focus();
        const lastSlash = fromPath.lastIndexOf('/');
        const dot = fromPath.lastIndexOf('.');
        const selStart = lastSlash >= 0 ? lastSlash + 1 : 0;
        const selEnd = (dot > selStart) ? dot : fromPath.length;
        try {
          newPathEl.setSelectionRange(selStart, selEnd);
        } catch {}
        fileStatusEl.textContent = 'Rename: edit the path above and press Enter (or click ).';
        applyRenameBtn.classList.remove('hidden');
      }

      function looksLikeFileName(path) {
        const leaf = String(path || '').split('/').filter(Boolean).pop() || '';
        return /\.[A-Za-z0-9]{1,8}$/.test(leaf);
      }

      async function doRenamePath(fromPath, toPath, kind = '') {
        if (!fromPath || !toPath) return { ok: false, error: 'Invalid rename path.' };
        if (kind === 'dir' && looksLikeFileName(toPath)) {
          return { ok: false, error: 'Folder names cannot look like files (example: folder.py).' };
        }
        let data = null;
        try {
          const resp = await fetch('/api/files/rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ from_path: fromPath, to_path: toPath })
          });
          data = await resp.json();
        } catch (e) {
          return { ok: false, error: 'Failed to reach backend.' };
        }
        if (!data.ok) {
          return { ok: false, error: data.error || 'Rename failed.' };
        }

        editorTabsState.forEach((t) => {
          if (!t.path) return;
          if (t.path === fromPath || t.path.startsWith(`${fromPath}/`)) {
            t.path = t.path === fromPath ? toPath : `${toPath}${t.path.slice(fromPath.length)}`;
            t.id = `file:${t.path}`;
            t.label = fileBaseName(t.path);
          }
        });
        if (openFilePath === fromPath) {
          openFilePath = toPath;
          updateEditorMode();
        }
        renderEditorTabs();
        await loadWorkspaceFiles();
        pushHistory(`Renamed ${fromPath}  ${toPath}`);
        return { ok: true };
      }

      async function renamePending() {
        const toPath = newPathEl.value.trim();
        const fromPath = pendingRenameFrom;
        if (!fromPath) return;
        if (!toPath) {
          fileStatusEl.textContent = 'Rename cancelled: empty path.';
          pendingRenameFrom = null;
          pendingRenameKind = '';
          applyRenameBtn.classList.add('hidden');
          return;
        }
        fileStatusEl.textContent = 'Renaming...';
        const out = await doRenamePath(fromPath, toPath, pendingRenameKind);
        if (!out.ok) {
          fileStatusEl.textContent = out.error || 'Rename failed.';
          return;
        }
        pendingRenameFrom = null;
        pendingRenameKind = '';
        applyRenameBtn.classList.add('hidden');
        newPathEl.value = '';
        fileStatusEl.textContent = `Renamed: ${fromPath}  ${toPath}`;
      }

      function startInlineRename(rowEl, fromPath, kind = '') {
        if (!rowEl || !fromPath) return;
        const nameWrap = rowEl.querySelector('.tree-row-name');
        const actions = rowEl.querySelector('.tree-row-actions');
        if (!nameWrap || !actions) return;
        const oldLeaf = String(fromPath).split('/').filter(Boolean).pop() || fromPath;
        const parent = fromPath.includes('/') ? fromPath.slice(0, fromPath.lastIndexOf('/')) : '';
        const input = document.createElement('input');
        input.value = oldLeaf;
        input.placeholder = kind === 'dir' ? 'folder-name' : 'file-name.ext';
        nameWrap.innerHTML = '';
        nameWrap.appendChild(input);
        actions.innerHTML = '';
        const okBtn = document.createElement('button');
        okBtn.className = 'tree-act confirm';
        okBtn.title = 'Confirm rename';
        okBtn.textContent = '';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'tree-act reject';
        cancelBtn.title = 'Cancel rename';
        cancelBtn.textContent = '';
        actions.appendChild(okBtn);
        actions.appendChild(cancelBtn);

        const submit = async () => {
          const newLeaf = (input.value || '').trim();
          if (!newLeaf) {
            fileStatusEl.textContent = 'Rename cancelled: empty name.';
            await loadWorkspaceFiles();
            return;
          }
          const toPath = parent ? `${parent}/${newLeaf}` : newLeaf;
          fileStatusEl.textContent = 'Renaming...';
          const out = await doRenamePath(fromPath, toPath, kind);
          if (!out.ok) {
            fileStatusEl.textContent = out.error || 'Rename failed.';
            await loadWorkspaceFiles();
            return;
          }
          fileStatusEl.textContent = `Renamed: ${fromPath}  ${toPath}`;
        };
        const cancel = async () => {
          await loadWorkspaceFiles();
        };
        okBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          submit();
        });
        cancelBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          cancel();
        });
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            submit();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancel();
          }
        });
        setTimeout(() => {
          input.focus();
          input.setSelectionRange(0, oldLeaf.length);
        }, 0);
      }

      async function loadWorkspaceFiles() {
        try {
          const resp = await fetch('/api/files');
          const data = await resp.json();
          workspaceTreeEl.innerHTML = '';
          renderTree(data.tree, workspaceTreeEl);
          markTreeSelection();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
        }
      }

      async function createFolder() {
        const path = newPathEl.value.trim();
        if (!path) {
          // Quick-create a unique folder, then prompt rename.
          const stamp = Date.now().toString().slice(-6);
          const candidate = `New Folder ${stamp}`;
          try {
            const resp = await fetch('/api/files/folder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: candidate })
            });
            const data = await resp.json();
            if (!data.ok) {
              fileStatusEl.textContent = data.error || 'Failed to create a new folder.';
              return;
            }
            loadWorkspaceFiles();
            startRename(data.path, 'dir');
            pushHistory(`Created folder ${data.path}`);
            return;
          } catch (e) {
            fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
            return;
          }
        }
        if (looksLikeFileName(path)) {
          fileStatusEl.textContent = 'Folder names cannot look like files (example: folder.py).';
          return;
        }
        fileStatusEl.textContent = 'Creating folder...';
        let data = null;
        try {
          const resp = await fetch('/api/files/folder', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path })
          });
          data = await resp.json();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
          return;
        }
        if (!data.ok) {
          fileStatusEl.textContent = data.error || 'Failed to create folder.';
          return;
        }
        fileStatusEl.textContent = `Folder created: ${data.path}`;
        startRename(data.path, 'dir');
        loadWorkspaceFiles();
        pushHistory(`Created folder ${data.path}`);
      }

      async function createFile() {
        const path = newPathEl.value.trim();
        if (!path) {
          // Quick-create a unique file, then prompt rename.
          const stamp = Date.now().toString().slice(-6);
          const candidate = `untitled-${stamp}.md`;
          try {
            const resp = await fetch('/api/files/file', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: candidate, content: '' })
            });
            const data = await resp.json();
            if (!data.ok) {
              fileStatusEl.textContent = data.error || 'Failed to create a new file.';
              return;
            }
            loadWorkspaceFiles();
            startRename(data.path, 'file');
            await openWorkspaceFile(data.path);
            pushHistory(`Created file ${data.path}`);
            return;
          } catch (e) {
            fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
            return;
          }
        }
        fileStatusEl.textContent = 'Creating file...';
        let data = null;
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: '' })
          });
          data = await resp.json();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
          return;
        }
        if (!data.ok) {
          fileStatusEl.textContent = data.error || 'Failed to create file.';
          return;
        }
        fileStatusEl.textContent = `File created: ${data.path}`;
        startRename(data.path, 'file');
        loadWorkspaceFiles();
        await openWorkspaceFile(data.path);
        pushHistory(`Created file ${data.path}`);
      }

      chatInputEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        chatInputEl.classList.add('drop-target');
      });
      chatInputEl.addEventListener('dragleave', () => {
        chatInputEl.classList.remove('drop-target');
      });
      chatInputEl.addEventListener('drop', async (e) => {
        e.preventDefault();
        chatInputEl.classList.remove('drop-target');
        const dt = e.dataTransfer;
        const indexedSnippet = (dt.getData('text/source-snippet') || '').trim();
        if (indexedSnippet) {
          chatInputEl.value += `\n\n${indexedSnippet}\n`;
          statusEl.textContent = 'Attached indexed source to prompt.';
          return;
        }
        const indexedFile = (dt.getData('text/source-file') || '').trim();
        if (indexedFile) {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(indexedFile)}`);
            const data = await resp.json();
            if (data.ok) {
              chatInputEl.value += `\n\n[File: ${data.path}]\n${data.content}\n`;
            } else {
              chatInputEl.value += `\n\n[File: ${indexedFile}]\n`;
            }
          } catch {
            chatInputEl.value += `\n\n[File: ${indexedFile}]\n`;
          }
          statusEl.textContent = 'Attached source file to prompt.';
          return;
        }
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetPath) {
          chatInputEl.value += `\n\n[Asset: ${assetType || 'image'}]\nPath: ${assetPath}\n`;
          statusEl.textContent = 'Attached asset reference to prompt.';
          return;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          for (const file of droppedFiles) {
            if (file.type && file.type.startsWith('image/')) {
              let attached = null;
              try {
                attached = await uploadImageToCurrentJob(file, 'background');
              } catch {}
              if (attached) {
                chatInputEl.value += `\n\n[Asset: background]\nPath: ${attached}\n`;
              } else {
                chatInputEl.value += `\n\n[Image file dropped]\nName: ${file.name}\nType: ${file.type}\n`;
              }
              continue;
            }
            try {
              const text = await file.text();
              chatInputEl.value += `\n\n[File: ${file.name}]\n${text}\n`;
            } catch {
              chatInputEl.value += `\n\n[File dropped]\nName: ${file.name}\n`;
            }
          }
          statusEl.textContent = 'Attached dropped files to prompt.';
          return;
        }

        const raw = (dt.getData('text/plain') || '').trim();
        if (!raw) return;

        const droppedPathKind = dt.getData('text/path-kind');
        const looksLikePath = !!droppedPathKind || /[\/\\]|\.md$|\.txt$|\.py$|\.json$|\.csv$|\.ya?ml$|\.png$|\.jpe?g$|\.gif$|\.webp$/i.test(raw);
        if (!looksLikePath || raw.includes('\n')) {
          chatInputEl.value += `\n\n[Snippet]\n${raw}\n`;
          statusEl.textContent = 'Attached dropped snippet to prompt.';
          return;
        }
        if (droppedPathKind === 'folder') {
          chatInputEl.value += `\n\n[Folder: ${raw}]\n`;
          statusEl.textContent = 'Attached folder reference to prompt.';
          return;
        }

        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
          const data = await resp.json();
          if (data.ok) {
            chatInputEl.value += `\n\n[File: ${data.path}]\n${data.content}\n`;
            statusEl.textContent = `Attached ${data.path}`;
            return;
          }
          const kind = droppedPathKind || 'path';
          chatInputEl.value += `\n\n[${kind === 'folder' ? 'Folder' : 'Path'}: ${raw}]\n`;
          statusEl.textContent = 'Attached path reference to prompt.';
        } catch {
          chatInputEl.value += `\n\n[Path: ${raw}]\n`;
          statusEl.textContent = 'Backend unreachable. Path attached as reference only.';
        }
      });

      async function resolveDroppedContent(dt) {
        const indexedSnippet = (dt.getData('text/source-snippet') || '').trim();
        if (indexedSnippet) return indexedSnippet;
        const indexedFile = (dt.getData('text/source-file') || '').trim();
        if (indexedFile) {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(indexedFile)}`);
            const data = await resp.json();
            if (data.ok) return `[File: ${data.path}]\n${data.content}`;
          } catch {}
          return `[File: ${indexedFile}]`;
        }
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetPath) {
          return `[Asset: ${assetType || 'image'}]\nPath: ${assetPath}`;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          const parts = [];
          for (const file of droppedFiles) {
            if (file.type && file.type.startsWith('image/')) {
              let rel = null;
              try { rel = await uploadImageToCurrentJob(file, 'background'); } catch { rel = null; }
              if (rel) parts.push(`[Asset: background]\nPath: ${rel}`);
              else parts.push(`[Image]\nName: ${file.name}`);
              continue;
            }
            try {
              parts.push(`[File: ${file.name}]\n${await file.text()}`);
            } catch {
              parts.push(`[File]\nName: ${file.name}`);
            }
          }
          return parts.join('\n\n');
        }

        const raw = (dt.getData('text/plain') || '').trim();
        if (!raw) return '';
        const droppedPathKind = dt.getData('text/path-kind');
        const looksLikePath = !!droppedPathKind || /[\/\\]|\.md$|\.txt$|\.py$|\.json$|\.csv$|\.ya?ml$/i.test(raw);
        if (droppedPathKind === 'folder') return `[Folder: ${raw}]`;
        if (looksLikePath && droppedPathKind !== 'folder') {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
            const data = await resp.json();
            if (data.ok) return `[File: ${data.path}]\n${data.content}`;
          } catch {}
          return `[Path: ${raw}]`;
        }
        return raw;
      }

      function enableContextDrop(inputEl, label) {
        if (!inputEl) return;
        inputEl.addEventListener('dragover', (e) => {
          e.preventDefault();
          inputEl.classList.add('context-drop');
        });
        inputEl.addEventListener('dragleave', () => inputEl.classList.remove('context-drop'));
        inputEl.addEventListener('drop', async (e) => {
          e.preventDefault();
          inputEl.classList.remove('context-drop');
          const text = await resolveDroppedContent(e.dataTransfer);
          if (!text) return;
          const cur = String(inputEl.value || '').trim();
          inputEl.value = cur ? `${cur}\n\n${text}` : text;
          showToast(`Attached to ${label}.`, 'ok');
          scheduleAutosave();
        });
      }

      enableContextDrop(memoryContentEl, 'memory');
      enableContextDrop(sourceNotesEl, 'docs');
      enableContextDrop(skillContentEl, 'skill');
      enableContextDrop(subagentsTextEl, 'subagents');

      async function loadTemplates() {
        const resp = await fetch('/api/templates');
        const data = await resp.json();
        templates = data.templates || [];
        templateSelectEl.innerHTML = '';
        templates.forEach((t, idx) => {
          const opt = document.createElement('option');
          opt.value = t.id;
          opt.textContent = `${t.name} (${t.category})`;
          if (idx === 0) opt.selected = true;
          templateSelectEl.appendChild(opt);
        });
        // If we have an autosave snapshot, respect its template selection without
        // re-applying template defaults (which would overwrite restored fields).
        if (pendingRestore && pendingRestore.template_id) {
          const wanted = String(pendingRestore.template_id);
          const exists = templates.some(t => t.id === wanted);
          if (exists) templateSelectEl.value = wanted;
          showToast('Restored last session.', 'ok');
          return;
        }
        if (templates[0]) applyTemplate(templates[0]);
      }

      function applyTemplate(tpl) {
        if (!tpl) return;
        templateDescriptionEl.value = tpl.description;
        if (tpl.example_prompt) chatInputEl.value = tpl.example_prompt;
        if (tpl.director_brief) directorBriefEl.value = tpl.director_brief;
        const d = tpl.defaults || {};
        if (d.audience) audienceEl.value = d.audience;
        if (d.tone) toneEl.value = d.tone;
        if (d.style) styleEl.value = d.style;
        if (d.pace) paceEl.value = d.pace;
        if (d.color_palette) paletteEl.value = d.color_palette;
        if (d.aspect_ratio) { aspectEl.value = d.aspect_ratio; setPreviewAspect(d.aspect_ratio); }
        if (d.quality) qualityEl.value = d.quality;
        if (typeof d.include_equations === 'boolean') equationsEl.value = d.include_equations ? 'true' : 'false';
        if (typeof d.include_graphs === 'boolean') graphsEl.value = d.include_graphs ? 'true' : 'false';
        if (typeof d.include_narration === 'boolean') narrationEl.value = d.include_narration ? 'true' : 'false';
        if (d.target_seconds) targetSecondsEl.value = d.target_seconds;
      }

      templateSelectEl.addEventListener('change', () => {
        const tpl = templates.find(t => t.id === templateSelectEl.value);
        applyTemplate(tpl);
      });
      if (resetToTemplateBtn) {
        resetToTemplateBtn.addEventListener('click', () => {
          const tpl = templates.find(t => t.id === templateSelectEl.value);
          if (!tpl) return;
          applyTemplate(tpl);
          showToast('Reset to template defaults.', 'ok');
        });
      }

      const SETTINGS_SAVED_MASK = '******';

      async function loadSettings() {
        const resp = await fetch('/api/settings');
        const data = await resp.json();
        if (data.text_model) {
          settingsTextModelEl.value = data.text_model;
          chatModelEl.value = data.text_model;
        }
        if (data.image_model) settingsImageModelEl.value = data.image_model;
        if (data.manim_py) settingsManimPyEl.value = data.manim_py;
        if (settingsProjectRootEl) settingsProjectRootEl.textContent = data.project_root || '';
        if (settingsWorkRootEl) settingsWorkRootEl.textContent = data.work_root || '';
        if (settingsOutputCopyDirEl) settingsOutputCopyDirEl.value = data.output_copy_dir || '';
        if (settingsElevenVoiceIdEl) settingsElevenVoiceIdEl.value = data.elevenlabs_voice_id || '';
        if (settingsElevenModelIdEl) settingsElevenModelIdEl.value = data.elevenlabs_model_id || '';
        if (voiceoverVoiceSelectEl && data.elevenlabs_voice_id) {
          const hasVoice = Array.from(voiceoverVoiceSelectEl.options || []).some((o) => o.value === data.elevenlabs_voice_id);
          voiceoverVoiceSelectEl.value = hasVoice ? data.elevenlabs_voice_id : '';
        }
        if (voiceoverModelSelectEl && data.elevenlabs_model_id) {
          const hasModel = Array.from(voiceoverModelSelectEl.options || []).some((o) => o.value === data.elevenlabs_model_id);
          voiceoverModelSelectEl.value = hasModel ? data.elevenlabs_model_id : '';
        }
        if (settingsApiKeyEl) {
          settingsApiKeyEl.placeholder = data.has_api_key ? 'Saved (hidden)' : 'Paste key';
          settingsApiKeyEl.value = data.has_api_key ? SETTINGS_SAVED_MASK : '';
        }
        if (settingsElevenApiKeyEl) {
          settingsElevenApiKeyEl.placeholder = data.has_elevenlabs_key ? 'Saved (hidden)' : 'Paste key';
          settingsElevenApiKeyEl.value = data.has_elevenlabs_key ? SETTINGS_SAVED_MASK : '';
        }
        if (!data.has_api_key) {
          statusEl.textContent = 'Hackathon tip: open Settings and paste your Gemini API key.';
          try {
            const seen = localStorage.getItem('seenApiKeyHint');
            if (!seen) {
              openSettingsTab('api');
              localStorage.setItem('seenApiKeyHint', '1');
            }
          } catch {}
        }
      }

      async function saveSettings() {
        const apiKeyValue = settingsApiKeyEl ? settingsApiKeyEl.value.trim() : '';
        const elevenKeyValue = settingsElevenApiKeyEl ? settingsElevenApiKeyEl.value.trim() : '';
        const apiKey = apiKeyValue && apiKeyValue !== SETTINGS_SAVED_MASK ? apiKeyValue : null;
        const elevenKey = elevenKeyValue && elevenKeyValue !== SETTINGS_SAVED_MASK ? elevenKeyValue : null;
        const resp = await fetch('/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            api_key: apiKey,
            text_model: settingsTextModelEl.value || null,
            image_model: settingsImageModelEl.value || null,
            manim_py: settingsManimPyEl.value || null,
            output_copy_dir: settingsOutputCopyDirEl ? (settingsOutputCopyDirEl.value || null) : null,
            elevenlabs_api_key: elevenKey,
            elevenlabs_voice_id: settingsElevenVoiceIdEl ? (settingsElevenVoiceIdEl.value || null) : null,
            elevenlabs_model_id: settingsElevenModelIdEl ? (settingsElevenModelIdEl.value || null) : null
          })
        });
        const data = await resp.json();
        if (data.ok) {
          statusEl.textContent = 'Settings saved.';
          if (settingsApiKeyEl && data.has_api_key) {
            settingsApiKeyEl.placeholder = 'Saved (hidden)';
            settingsApiKeyEl.value = SETTINGS_SAVED_MASK;
          }
          if (settingsElevenApiKeyEl && data.has_elevenlabs_key) {
            settingsElevenApiKeyEl.placeholder = 'Saved (hidden)';
            settingsElevenApiKeyEl.value = SETTINGS_SAVED_MASK;
          }
          if (data.text_model) chatModelEl.value = data.text_model;
          showToast('Settings saved.', 'ok');
          pushHistory('Saved settings');
        }
      }

      function setSidebarHealthBadge(el, label, ok) {
        if (!el) return;
        el.textContent = `${label}: ${ok ? 'OK' : 'Missing'}`;
        el.classList.toggle('ok', !!ok);
        el.classList.toggle('bad', !ok);
      }

      function renderSidebarHealth(healthData, preflightData) {
        const checks = preflightData?.checks || {};
        const apiOk = typeof checks.api_key === 'boolean' ? checks.api_key : !!(preflightData?.ok);
        const outputOk = typeof checks.output_writable === 'boolean' ? checks.output_writable : !!(preflightData?.ok);
        setSidebarHealthBadge(sidebarBadgeApiEl, 'API', apiOk);
        setSidebarHealthBadge(sidebarBadgeManimEl, 'Manim', !!healthData?.manim_ok);
        setSidebarHealthBadge(sidebarBadgeFfmpegEl, 'ffmpeg', !!healthData?.ffmpeg_ok);
        setSidebarHealthBadge(sidebarBadgeOutputEl, 'Output', outputOk);

        if (!sidebarHealthTextEl) return;
        if (!healthData && !preflightData) {
          sidebarHealthTextEl.textContent = 'No checks yet.';
          return;
        }
        const lines = [];
        if (healthData?.manim_version) lines.push(healthData.manim_version);
        if (healthData?.ffmpeg_version) lines.push(healthData.ffmpeg_version);
        if (preflightData?.output_root) lines.push(`Output root: ${preflightData.output_root}`);
        if (Array.isArray(preflightData?.missing) && preflightData.missing.length) {
          lines.push(`Missing: ${preflightData.missing.join(', ')}`);
        } else {
          lines.push('Preflight: all checks passed.');
        }
        sidebarHealthTextEl.textContent = lines.join('\n');
      }

      async function refreshSidebarHealth() {
        let healthData = null;
        let preflightData = null;
        try {
          const resp = await fetch('/api/health');
          healthData = await resp.json();
          lastHealthData = healthData;
        } catch {}
        try {
          const resp = await fetch('/api/preflight');
          preflightData = await resp.json();
          lastPreflightData = preflightData;
        } catch {}
        renderSidebarHealth(healthData || lastHealthData, preflightData || lastPreflightData);
      }

      async function runHealth() {
        healthEl.textContent = 'Checking...';
        let data = null;
        try {
          const resp = await fetch('/api/health');
          data = await resp.json();
        } catch (e) {
          healthEl.textContent = 'Failed to reach backend. Is the server running?';
          return null;
        }
        const manimStatus = data.manim_ok ? 'OK' : 'Missing';
        const ffmpegStatus = data.ffmpeg_ok ? 'OK' : 'Missing';
        const py = data.manim_py || 'python3';
        if (badgeManimEl) {
          badgeManimEl.textContent = `Manim: ${manimStatus}`;
          badgeManimEl.classList.toggle('ok', !!data.manim_ok);
          badgeManimEl.classList.toggle('bad', !data.manim_ok);
        }
        if (badgeFfmpegEl) {
          badgeFfmpegEl.textContent = `ffmpeg: ${ffmpegStatus}`;
          badgeFfmpegEl.classList.toggle('ok', !!data.ffmpeg_ok);
          badgeFfmpegEl.classList.toggle('bad', !data.ffmpeg_ok);
        }
        const cands = (data.python_candidates || []).join(', ');
        const ffmpegPath = data.ffmpeg_path || '';
        const voiceReady = !!data.elevenlabs_ready;
        const voiceId = data.elevenlabs_voice_id || '';
        const voiceModel = data.elevenlabs_model_id || '';
        const lines = [
          `Manim: ${manimStatus}`,
          `ffmpeg: ${ffmpegStatus}`,
          `ElevenLabs narrator: ${voiceReady ? 'Ready' : 'Not configured'}`,
          `python: ${py}`,
        ];
        if (data.manim_version) lines.push(data.manim_version);
        if (cands) lines.push(`python candidates: ${cands}`);
        if (ffmpegPath) lines.push(`ffmpeg path: ${ffmpegPath}`);
        if (voiceId) lines.push(`voice id: ${voiceId}`);
        if (voiceModel) lines.push(`voice model: ${voiceModel}`);
        if (!voiceReady) {
          lines.push('');
          lines.push('Narrator setup: Settings -> API & Models -> Voiceover (ElevenLabs).');
          lines.push('- Set ElevenLabs API key');
          lines.push('- Set Voice ID');
          lines.push('- Optional model id (default: eleven_multilingual_v2)');
        }
        if (!data.manim_ok) {
          lines.push('');
          lines.push('Fix: choose a Python that has Manim installed (or leave blank to auto-detect).');
          lines.push('macOS quickstart (from repo root):');
          lines.push('- source .venv/bin/activate');
          lines.push('- python -m pip install manim');
        }
        if (!data.ffmpeg_ok) {
          lines.push('');
          lines.push('Fix (macOS): brew install ffmpeg');
        }
        healthEl.textContent = lines.join('\n');
        lastHealthData = data;
        renderSidebarHealth(data, lastPreflightData);
        return data;
      }

      function showInstallPrompt(missingList) {
        if (!installPromptEl || !installMissingListEl) return;
        if (!missingList.length) {
          installPromptEl.classList.add('hidden');
          return;
        }
        installMissingListEl.textContent = missingList.join(', ');
        installPromptEl.classList.remove('hidden');
      }

      async function installMissingDeps() {
        const data = lastHealthData || await runHealth();
        if (!data) return;
        const missing = [];
        if (!data.manim_ok) missing.push('manim');
        if (!data.ffmpeg_ok) missing.push('ffmpeg');
        if (!missing.length) {
          showInstallPrompt([]);
          showToast('All dependencies already installed.', 'ok');
          return;
        }
        setTerminalMode(true);
        showToast('Installing missing dependencies', 'ok');
        const py = (settingsManimPyEl.value || data.manim_py || 'python3').trim() || 'python3';
        if (missing.includes('manim')) {
          await execTerminalCommand(`${py} -m pip install -U pip`, { append: true });
          await execTerminalCommand(`${py} -m pip install manim`, { append: true });
        }
        if (missing.includes('ffmpeg')) {
          const brewCheck = await execTerminalCommand('command -v brew', { append: true, silent: true });
          if (brewCheck && !brewCheck.startsWith('(exit')) {
            await execTerminalCommand('brew install ffmpeg', { append: true });
          } else {
            logsEl.textContent += '\nBrew not found. Install ffmpeg manually or use: apt-get install ffmpeg\n';
          }
        }
        lastHealthData = await runHealth();
        showInstallPrompt([]);
      }

      async function loadMemories() {
        const resp = await fetch('/api/memories');
        const data = await resp.json();
        memoryListEl.innerHTML = '';
        const memories = Array.isArray(data.memories) ? data.memories : [];
        if (!memories.length) {
          const empty = document.createElement('div');
          empty.className = 'memory-empty';
          empty.textContent = 'No memory yet. Add one above.';
          memoryListEl.appendChild(empty);
          return;
        }
        memories.forEach((mem, idx) => {
          const row = document.createElement('label');
          row.className = 'memory-entry';
          row.title = 'Select memory for the next plan/render';
          const title = cleanInline(mem?.title || '').trim() || `Memory ${idx + 1}`;
          const body = cleanInline(mem?.content || '').trim();
          row.innerHTML = `
            <div class="memory-row">
              <input type="checkbox" data-id="${mem.id}" />
              <div style="min-width:0;">
                <div class="memory-entry-title">${escapeHtml(compactLabel(title, 56))}</div>
                <div class="memory-entry-body">${escapeHtml(compactLabel(body || 'No details provided.', 140))}</div>
              </div>
              <button class="ghost" type="button" data-memory-del="${mem.id}" title="Remove memory">Remove</button>
            </div>`;
          memoryListEl.appendChild(row);
        });
        memoryListEl.querySelectorAll('[data-memory-del]').forEach((btn) => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const id = btn.getAttribute('data-memory-del');
            if (!id) return;
            try {
              await fetch(`/api/memories/${encodeURIComponent(id)}`, { method: 'DELETE' });
            } catch {}
            await loadMemories();
            showToast('Memory removed.', 'ok');
            scheduleAutosave();
          });
        });
      }

      async function addMemory() {
        await fetch('/api/memories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: memoryTitleEl.value, content: memoryContentEl.value })
        });
        memoryTitleEl.value = '';
        memoryContentEl.value = '';
        loadMemories();
      }

      function selectedMemoryIds() {
        return Array.from(memoryListEl.querySelectorAll('input[type="checkbox"]')).filter(cb => cb.checked).map(cb => cb.dataset.id);
      }

      function normalizeMentionName(value) {
        return String(value || '').toLowerCase().replace(/[^a-z0-9]/g, '');
      }

      function cleanInline(value) {
        return String(value || '')
          .replace(/\\n/g, ' ')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      }

      function compactLabel(value, maxLen = 28) {
        return cleanInline(value).slice(0, maxLen);
      }

      function makeHandle(value, fallback = 'item') {
        const clean = cleanInline(value)
          .replace(/[:|]/g, ' ')
          .replace(/[^A-Za-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .replace(/_+/g, '_');
        const out = clean.slice(0, 16);
        return out || fallback;
      }

      function pickTitle(name, content, fallback) {
        const fromName = compactLabel(name, 52);
        if (fromName) return fromName;
        const firstLine = String(content || '').split(/\r?\n/g)[0];
        const fromContent = compactLabel(firstLine, 52);
        if (fromContent) return fromContent;
        return fallback;
      }

      function parseSubagentLines() {
        const raw = (subagentsTextEl?.value || '').split('\n');
        const items = [];
        raw.forEach((line) => {
          const txt = String(line || '').trim();
          if (!txt) return;
          const idx = txt.indexOf(':');
          const n = items.length + 1;
          if (idx > 0) {
            const name = compactLabel(txt.slice(0, idx).trim(), 42);
            const content = compactLabel(txt.slice(idx + 1).trim(), 180);
            items.push({
              name,
              content,
              nick: makeHandle(name || content, `agent_${n}`),
            });
          } else {
            const name = compactLabel(txt, 42);
            items.push({ name, content: '', nick: makeHandle(name, `agent_${n}`) });
          }
        });
        return items;
      }

      function renderMentionBar() {
        if (!mentionBarEl) return;
        mentionBarEl.innerHTML = '';
        const chips = [];
        const maxMentionsVisible = 4;

        function insertMentionToken(token) {
          const cur = chatInputEl.value || '';
          const sep = cur && !/\s$/.test(cur) ? ' ' : '';
          chatInputEl.value = `${cur}${sep}${token} `;
          chatInputEl.focus();
        }

        (skillsCache || []).forEach((s) => {
          const nick = s._nick || makeHandle(s.name, 'skill');
          const token = `@${nick}`;
          chips.push({ token, label: nick, tip: 'Skill', kind: 'skill' });
        });
        parseSubagentLines().forEach((a) => {
          const nick = a.nick || makeHandle(a.name, 'agent');
          const token = `@${nick}`;
          chips.push({ token, label: nick, tip: 'Subagent', kind: 'agent' });
        });

        if (!chips.length) {
          mentionBarEl.classList.add('hidden');
          if (mentionInfoEl) {
            mentionInfoEl.dataset.summary = 'No references yet';
            mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
          }
          updateMentionVisibility();
          return;
        }
        mentionBarEl.classList.remove('hidden');
        const visible = chips.slice(0, maxMentionsVisible);
        visible.forEach((c) => {
          const btn = document.createElement('button');
          btn.className = `mention-chip ${c.kind === 'agent' ? 'agent' : ''}`;
          btn.title = `${c.tip} reference: click to insert ${c.token}`;
          btn.innerHTML = `<span class="mention-icon">${c.kind === 'agent' ? 'A' : 'S'}</span><span class="mention-text">@${c.label}</span>`;
          btn.addEventListener('click', () => insertMentionToken(c.token));
          mentionBarEl.appendChild(btn);
        });
        if (chips.length > visible.length) {
          const more = chips.length - visible.length;
          if (mentionInfoEl) {
            mentionInfoEl.dataset.summary = `${visible.length}/${chips.length} refs shown (+${more} hidden)`;
            mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
          }
        } else if (mentionInfoEl) {
          mentionInfoEl.dataset.summary = `${chips.length} refs`;
          mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
        }
        updateMentionVisibility();
      }

      function renderSubagentCards() {
        if (!subagentCardsEl) return;
        subagentCardsEl.innerHTML = '';
        const items = parseSubagentLines();
        items.forEach((item) => {
          const card = document.createElement('div');
          card.className = 'saved-card';
          const nick = item.nick || makeHandle(item.name, 'agent');
          card.innerHTML = `<div class="saved-card-title">A  ${compactLabel(item.name, 42)}</div><div class="saved-card-body">@${nick} ${item.content || 'No details yet.'}</div>`;
          card.title = `Insert @${nick} into prompt`;
          card.style.cursor = 'pointer';
          card.addEventListener('click', () => {
            const cur = chatInputEl.value || '';
            const sep = cur && !/\s$/.test(cur) ? ' ' : '';
            chatInputEl.value = `${cur}${sep}@${nick} `;
            chatInputEl.focus();
          });
          subagentCardsEl.appendChild(card);
        });
        renderMentionBar();
      }

      async function loadSkills() {
        const resp = await fetch('/api/skills');
        const data = await resp.json();
        const skills = data.skills || [];
        const seeded = await seedDefaultSkills(skills);
        if (!skills.length || seeded) {
          const resp2 = await fetch('/api/skills');
          const data2 = await resp2.json();
          return renderSkills(data2.skills || []);
        }
        renderSkills(skills);
      }

      function updateSkillRailMeta() {
        if (!skillRailMetaEl) return;
        const selected = selectedSkillIdSet.size;
        const total = (skillsCache || []).length;
        skillRailMetaEl.textContent = `${selected} selected / ${total}`;
      }

      function scrollSkillRail(deltaPx) {
        if (!skillListEl) return;
        skillListEl.scrollBy({ left: deltaPx, behavior: 'smooth' });
      }

      let skillTooltipTimer = null;
      function hideSkillTooltip(immediate = false) {
        if (!skillTooltipEl) return;
        const run = () => {
          skillTooltipEl.classList.remove('show');
          skillTooltipEl.classList.add('hidden');
          skillTooltipEl.setAttribute('aria-hidden', 'true');
        };
        if (immediate) {
          clearTimeout(skillTooltipTimer);
          run();
          return;
        }
        clearTimeout(skillTooltipTimer);
        skillTooltipTimer = setTimeout(run, 100);
      }

      function positionSkillTooltip(x, y) {
        if (!skillTooltipEl) return;
        const pad = 10;
        const rect = skillTooltipEl.getBoundingClientRect();
        let left = x + 14;
        let top = y + 14;
        if (left + rect.width > window.innerWidth - pad) {
          left = Math.max(pad, x - rect.width - 14);
        }
        if (top + rect.height > window.innerHeight - pad) {
          top = Math.max(pad, y - rect.height - 14);
        }
        skillTooltipEl.style.left = `${left}px`;
        skillTooltipEl.style.top = `${top}px`;
      }

      function showSkillTooltip(skill, anchorEl, x, y) {
        if (!skillTooltipEl || !skill) return;
        clearTimeout(skillTooltipTimer);
        const name = compactLabel(skill._display || skill.name || 'Skill', 52);
        const nick = skill._nick || makeHandle(name, 'skill');
        const body = compactLabel((skill.content || '').replace(/\\n/g, ' '), 190) || 'Reusable instruction block';
        skillTooltipEl.innerHTML = `<div class="skill-tooltip-title">${escapeHtml(name)}</div><div class="skill-tooltip-handle">@${escapeHtml(nick)}</div><div class="skill-tooltip-body">${escapeHtml(body)}</div>`;
        skillTooltipEl.classList.remove('hidden');
        skillTooltipEl.setAttribute('aria-hidden', 'false');
        const px = Number.isFinite(x) ? x : ((anchorEl?.getBoundingClientRect?.().left || 0) + (anchorEl?.getBoundingClientRect?.().width || 0) / 2);
        const py = Number.isFinite(y) ? y : ((anchorEl?.getBoundingClientRect?.().top || 0) + 8);
        positionSkillTooltip(px, py);
        requestAnimationFrame(() => {
          skillTooltipEl.classList.add('show');
          positionSkillTooltip(px, py);
        });
      }

      function renderSkills(skills) {
        const prevSelected = new Set(selectedSkillIdSet);
        skillsCache = (skills || []).map((skill, idx) => {
          const rawName = String(skill.name || '').replace(/\\n/g, '\n');
          const firstNameLine = cleanInline(rawName.split('\n')[0] || '');
          const rawContent = cleanInline(String(skill.content || '').replace(/\\n/g, ' ').replace(/\n/g, ' '));
          let display = firstNameLine || pickTitle('', rawContent, `Skill ${idx + 1}`);
          if (display.startsWith('@')) {
            const token = display.split(/\s+/g)[0].replace(/^@+/, '');
            if (token) display = token;
          }
          display = display.replace(/^@+/, '').replace(/_+/g, '_').replace(/[^\w -]/g, ' ').replace(/\s+/g, ' ').trim();
          if (display.includes(':')) display = compactLabel(display.split(':')[0], 42);
          if (display.split(' ').length > 4) display = display.split(' ').slice(0, 4).join(' ');
          display = compactLabel(display, 32);
          if (!display) display = `Skill ${idx + 1}`;
          const nick = makeHandle(display, `skill_${idx + 1}`);
          return {
            ...skill,
            name: display,
            content: rawContent,
            _display: display,
            _nick: nick,
          };
        });
        selectedSkillIdSet = new Set(
          (skillsCache || [])
            .map((s) => String(s.id || ''))
            .filter((id) => id && prevSelected.has(id))
        );
        skillListEl.innerHTML = '';
        if (savedSkillCardsEl) savedSkillCardsEl.innerHTML = '';
        (skillsCache || []).forEach(skill => {
          const displayName = skill._display || 'Skill';
          const nick = skill._nick || makeHandle(displayName, 'skill');
          const icon = String(displayName || 'S')
            .split(/[\s_-]+/)
            .filter(Boolean)
            .slice(0, 2)
            .map((s) => s.charAt(0).toUpperCase())
            .join('') || 'S';
          const desc = compactLabel((skill.content || '').replace(/\\n/g, ' '), 120) || 'Reusable instruction skill';
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'skill-pill';
          btn.dataset.id = String(skill.id || '');
          btn.dataset.nick = nick;
          btn.dataset.name = displayName;
          btn.setAttribute('aria-label', `${displayName} @${nick}`);
          if (selectedSkillIdSet.has(String(skill.id || ''))) {
            btn.classList.add('is-selected');
          }
          btn.innerHTML = `<span class="skill-pill-icon">${icon}</span><span class="skill-pill-name">${displayName}</span>`;
          btn.addEventListener('click', () => {
            const sid = String(skill.id || '');
            if (!sid) return;
            if (selectedSkillIdSet.has(sid)) selectedSkillIdSet.delete(sid);
            else selectedSkillIdSet.add(sid);
            btn.classList.toggle('is-selected', selectedSkillIdSet.has(sid));
            updateSkillRailMeta();
            scheduleAutosave();
          });
          btn.addEventListener('mouseenter', (e) => {
            showSkillTooltip(skill, btn, e.clientX, e.clientY);
          });
          btn.addEventListener('mousemove', (e) => {
            positionSkillTooltip(e.clientX, e.clientY);
          });
          btn.addEventListener('mouseleave', () => hideSkillTooltip());
          btn.addEventListener('focus', () => showSkillTooltip(skill, btn));
          btn.addEventListener('blur', () => hideSkillTooltip(true));
          btn.addEventListener('touchstart', (e) => {
            const t = e.touches && e.touches[0];
            showSkillTooltip(skill, btn, t?.clientX, t?.clientY);
            setTimeout(() => hideSkillTooltip(), 1200);
          }, { passive: true });
          btn.draggable = true;
          btn.addEventListener('dragstart', (e) => {
            const token = `@${nick}`;
            const snippet = `[Skill ${displayName}] ${skill.content || ''}`.slice(0, 600);
            e.dataTransfer.setData('text/plain', `${token}\n${snippet}`);
            e.dataTransfer.setData('text/skill-token', token);
            e.dataTransfer.setData('text/skill-id', String(skill.id || ''));
            e.dataTransfer.effectAllowed = 'copy';
          });
          skillListEl.appendChild(btn);

          if (savedSkillCardsEl) {
            const card = document.createElement('div');
            card.className = 'saved-card';
            card.innerHTML = `<div class="saved-card-title">S  ${displayName}</div><div class="saved-card-body">@${nick} ${(skill.content || '').replace(/\\n/g, ' ').slice(0, 140)}</div>`;
            card.title = `Insert @${nick} into prompt`;
            card.style.cursor = 'pointer';
            card.addEventListener('click', () => {
              const cur = chatInputEl.value || '';
              const sep = cur && !/\s$/.test(cur) ? ' ' : '';
              chatInputEl.value = `${cur}${sep}@${nick} `;
              chatInputEl.focus();
            });
            savedSkillCardsEl.appendChild(card);
          }
        });
        updateSkillRailMeta();
        renderMentionBar();
      }

      document.addEventListener('scroll', () => hideSkillTooltip(true), true);
      window.addEventListener('resize', () => hideSkillTooltip(true));
      document.addEventListener('pointerdown', (e) => {
        const t = e.target;
        if (!t || !(t instanceof Element)) return;
        if (t.closest('.skill-pill')) return;
        hideSkillTooltip(true);
      });

      async function seedDefaultSkills(existingSkills = []) {
        const existingNormalized = new Set(
          (existingSkills || []).map((s) => normalizeMentionName(s?.name || s?.id || '')).filter(Boolean)
        );
        const defaults = [
          {
            name: 'Photoelectric Director',
            content: 'For photoelectric scenes: compare low-frequency high-intensity vs high-frequency low-intensity. Always label threshold f0, work function phi, and K_max.'
          },
          {
            name: 'EM Wave Animator',
            content: 'Animate wavelength/frequency with clean sinusoid or packets. Keep arrows short, centered, and color-code red vs blue with legend.'
          },
          {
            name: 'Equation Builder',
            content: 'Introduce equations term-by-term: K_max = h f - phi and e V_s = K_max. Highlight one term at a time with matching narration.'
          },
          {
            name: 'Graph Interpreter',
            content: 'When plotting K_max vs frequency, show x-intercept at f0, slope h, and no emission below threshold. Keep axes labels large and centered.'
          },
          {
            name: 'Lab Apparatus Designer',
            content: 'Build clear experimental setup visuals: metal plate, incident light arrow, emitted e- dots, collector, and stopping potential battery icon.'
          },
          {
            name: 'Optics Visualizer',
            content: 'Use clean rays, lenses, and wavefronts to explain optics. Keep beams short, labels large, and show refraction or diffraction clearly.'
          },
          {
            name: 'Quantum Story Beat',
            content: 'Use sequence: hook -> failed classical expectation -> Einstein photon model -> equation -> graph -> recap takeaway.'
          },
          {
            name: 'Clarity QA',
            content: 'Check overlap, safe margins for 9:16 and 16:9, and one concept per scene. Reject tiny labels or overlapping equations.'
          },
          {
            name: 'Narration Sync',
            content: 'Keep narration aligned to visible action. No narration-only spans longer than 2 seconds; each line should map to one visual change.'
          },
          {
            name: 'Caption Choreographer',
            content: 'Design subtitle rhythm with readable 1-2 line chunks, synchronized pop-ins, and strong contrast over moving backgrounds.'
          },
          {
            name: 'Title Overlay Designer',
            content: 'Create opening and section title overlays that animate in cleanly, stay inside safe margins, and avoid blocking key visuals.'
          },
          {
            name: 'Orientation Composer',
            content: 'Adapt scene composition for 9:16, 16:9, and 1:1. Keep focal objects centered and avoid edge clipping in portrait mode.'
          },
          {
            name: 'Color Mood Director',
            content: 'Map concept phases to palette shifts (hook, mechanism, equation, recap) while preserving contrast and educational clarity.'
          },
          {
            name: 'Hook Builder',
            content: 'Start with a strong 2-5 second hook visual + text line that sets the question before showing derivations or graphs.'
          },
          {
            name: 'Timeline Sculptor',
            content: 'Balance scene lengths so each beat lands clearly. Keep transitions smooth and avoid overcrowding any single 5-second window.'
          },
          {
            name: 'Narrative Bridge',
            content: 'Write transition captions that connect one scene to the next in plain language so viewers never lose context.'
          },
          {
            name: 'Thumbnail Framer',
            content: 'Frame one key moment per scene that can work as a still image for social previews with readable center-weighted labels.'
          }
        ];
        let createdAny = false;
        for (const item of defaults) {
          const key = normalizeMentionName(item.name);
          if (existingNormalized.has(key)) continue;
          try {
            await fetch('/api/skills', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(item)
            });
            existingNormalized.add(key);
            createdAny = true;
          } catch {}
        }
        return createdAny;
      }

      function ensurePhysicsSubagentsForDemo() {
        const existing = (subagentsTextEl?.value || '')
          .split('\n')
          .map((x) => String(x || '').trim())
          .filter(Boolean);
        const existingMap = new Set(existing.map((line) => normalizeMentionName(line.split(':')[0] || line)));
        const physicsDefaults = [
          'PhotonCoach: drives photon-vs-wave framing and keeps threshold intuition clear.',
          'LabDesigner: builds emitter plate, collector, stopping-potential layout with clean labels.',
          'EquationTutor: introduces K_max = h f - phi and eV_s = K_max one symbol at a time.',
          'GraphAnalyst: ensures K_max vs f graph shows f0 intercept and slope meaning.',
          'VisualPacer: enforces one concept at a time and smooth transitions for short-form video.',
          'SafetyQA: validates spacing, overlap, and readability for 9:16 and 16:9 exports.',
          'CaptionConductor: controls subtitle timing, line breaks, and on-screen emphasis words.',
          'OrientationDirector: adapts framing and text-safe zones for portrait, landscape, and square exports.',
          'HookEngineer: strengthens first 3 seconds with a surprising visual and clear headline.',
          'MoodStylist: coordinates palette and glow intensity to fit the selected vibe preset.',
          'TimelineConductor: balances pacing across scenes and prevents abrupt rhythm breaks.',
          'CaptionEditor: keeps captions concise, high-contrast, and synchronized with visible actions.'
        ];
        const merged = [...existing];
        physicsDefaults.forEach((line) => {
          const name = normalizeMentionName(line.split(':')[0] || line);
          if (!existingMap.has(name)) {
            merged.push(line);
            existingMap.add(name);
          }
        });
        if (subagentsTextEl) subagentsTextEl.value = merged.join('\n');
      }

      async function saveSkill() {
        await fetch('/api/skills', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: skillNameEl.value, content: skillContentEl.value })
        });
        skillNameEl.value = '';
        skillContentEl.value = '';
        loadSkills();
      }

      async function generateSkill() {
        await fetch('/api/skills/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ idea: skillIdeaEl.value, name: skillGenerateNameEl.value })
        });
        skillIdeaEl.value = '';
        skillGenerateNameEl.value = '';
        loadSkills();
      }

      function selectedSkillIds() {
        return Array.from(selectedSkillIdSet);
      }

      function selectedSkillIdsWithMentions(promptText) {
        const out = new Set(selectedSkillIds());
        const tags = Array.from(String(promptText || '').matchAll(/@([A-Za-z0-9_-]+)/g))
          .map((m) => normalizeMentionName(m[1]));
        if (!tags.length) return Array.from(out);
        (skillsCache || []).forEach((s) => {
          const byName = normalizeMentionName(s._nick || makeHandle(s.name, 'skill'));
          if (tags.includes(byName) && s.id) out.add(s.id);
        });
        return Array.from(out);
      }

      function sceneIndexFromClientX(clientX) {
        if (!timelineTrackEl || !timelineState.length) return -1;
        const rect = timelineTrackEl.getBoundingClientRect();
        const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
        const total = timelineState.reduce((s, sc) => s + Math.max(1, Number(sc.seconds || 1)), 0) || 1;
        let cursor = 0;
        const target = pct * total;
        for (let i = 0; i < timelineState.length; i++) {
          const dur = Math.max(1, Number(timelineState[i]?.seconds || 1));
          if (target <= cursor + dur) return i;
          cursor += dur;
        }
        return timelineState.length - 1;
      }

      async function applyDropToSceneIndex(idx, dataTransfer) {
        const sc = timelineState[idx];
        if (!sc) return false;
        const dt = dataTransfer;
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetType && assetPath) {
          sc.assets = sc.assets || {};
          sc.assets[assetType] = assetPath;
          renderTimeline();
          showToast(`Attached ${assetType.toUpperCase()} to scene ${idx + 1}.`, 'ok');
          notifyImageChangeNeedsRerender();
          return true;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          const img = droppedFiles.find((f) => (f.type || '').startsWith('image/'));
          if (!img) {
            showToast('Drop an image file to attach to a scene.', 'err');
            return true;
          }
          const role = imageModeEl.value === 'foreground' ? 'foreground' : 'background';
          let rel = null;
          try {
            rel = await uploadImageToCurrentJob(img, role);
          } catch {
            rel = null;
          }
          if (!rel) return true;
          sc.assets = sc.assets || {};
          sc.assets[role] = rel;
          if (role === 'background') {
            setThumb(bgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'background', relPath: rel });
          } else {
            setThumb(fgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'foreground', relPath: rel });
          }
          renderTimeline();
          showToast(`Attached ${img.name} to scene ${idx + 1}.`, 'ok');
          notifyImageChangeNeedsRerender();
          return true;
        }

        const sourceTimeline = (dt.getData('text/source-timeline') || '').trim();
        const sourceSnippet = (dt.getData('text/source-snippet') || '').trim();
        const raw = sourceTimeline || sourceSnippet || (dt.getData('text/plain') || '').trim();
        const kind = dt.getData('text/path-kind');
        if (!raw) return false;
        let snippet = '';
        if (kind === 'folder') {
          snippet = `[Folder ref: ${raw}]`;
        } else if (kind === 'file') {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
            const data = await resp.json();
            snippet = data.ok ? `[File ref: ${raw}]\n${String(data.content || '').slice(0, 600)}` : `[File ref: ${raw}]`;
          } catch {
            snippet = `[File ref: ${raw}]`;
          }
        } else {
          snippet = raw.slice(0, 600);
        }
        sc.narration = [sc.narration || '', snippet].filter(Boolean).join('\n');
        renderTimeline();
        showToast(`Added note to scene ${idx + 1}.`, 'ok');
        return true;
      }

      function renderTimelineRuler(totalSeconds, scenes) {
        if (!timelineRulerEl) return;
        timelineRulerEl.innerHTML = '';
        const total = Math.max(1, Math.floor(Number(totalSeconds || 1)));

        let minor = 1;
        let major = 5;
        if (total > 30 && total <= 120) { minor = 5; major = 10; }
        else if (total > 120 && total <= 300) { minor = 10; major = 30; }
        else if (total > 300) { minor = 30; major = 60; }

        function addTick(t, isMajor) {
          const pct = (t / total) * 100;
          const tick = document.createElement('div');
          tick.className = 'tick' + (isMajor ? ' major' : '');
          tick.style.left = `${pct}%`;
          timelineRulerEl.appendChild(tick);
          if (isMajor) {
            const label = document.createElement('div');
            label.className = 'tick-label';
            label.style.left = `${pct}%`;
            label.textContent = `${t}s`;
            timelineRulerEl.appendChild(label);
          }
        }

        for (let t = 0; t <= total; t += minor) {
          addTick(t, t % major === 0);
        }
        if (total % minor !== 0) addTick(total, true);
        const rows = Array.isArray(scenes) ? scenes : [];
        let cursor = 0;
        rows.forEach((sc, idx) => {
          const dur = Math.max(1, Number(sc?.seconds || 1));
          const mid = cursor + Math.max(0.5, dur / 2);
          const pct = (mid / total) * 100;
          const marker = document.createElement('div');
          marker.className = 'timeline-marker';
          marker.style.left = `${pct}%`;
          marker.title = `Scene ${idx + 1}: ${String(sc?.goal || 'Scene').slice(0, 120)}`;
          const dot = document.createElement('div');
          dot.className = 'timeline-marker-dot';
          const label = document.createElement('div');
          label.className = 'timeline-marker-label';
          label.textContent = `S${idx + 1}`;
          marker.appendChild(dot);
          marker.appendChild(label);
          timelineRulerEl.appendChild(marker);
          cursor += dur;
        });
      }

      function resolveAssetPreviewSrc(relPath) {
        const rel = String(relPath || '').trim();
        if (!rel) return '';
        if (/^(https?:)?\/\//i.test(rel)) return rel;
        if (rel.startsWith('/work/')) return rel;
        if (!currentJobId) return '';
        return `/work/jobs/${currentJobId}/${rel}`;
      }

      function buildTimelineAssetBadge(role, relPath) {
        const badge = document.createElement('div');
        badge.className = 'timeline-badge timeline-asset-badge';
        const src = resolveAssetPreviewSrc(relPath);
        if (src) {
          const img = document.createElement('img');
          img.src = src;
          img.alt = role;
          badge.appendChild(img);
        }
        const label = document.createElement('span');
        label.className = 'asset-label';
        label.textContent = role === 'background' ? 'BG' : 'FG';
        badge.appendChild(label);
        return badge;
      }

      function buildTimelineAssetDot(role, relPath) {
        const dot = document.createElement('span');
        dot.className = `timeline-asset-dot ${role === 'background' ? 'bg' : 'fg'}`;
        const name = role === 'background' ? 'Background' : 'Foreground';
        dot.title = `${name} asset\n${relPath || ''}`.trim();
        return dot;
      }

      function renderTimeline() {
        timelineTrackEl.innerHTML = '';
        if (!timelineState.length) {
          timelineLabelEl.textContent = 'Timeline';
          if (timelineRulerEl) timelineRulerEl.innerHTML = '';
          refreshAppliedAssetInfo();
          refreshSceneTargetPlaceholders();
          updateFirst60Checklist();
          return;
        }
        const total = timelineState.reduce((s, sc) => s + sc.seconds, 0);
        timelineLabelEl.textContent = `Total ${total}s  ${timelineState.length} scenes`;
        renderTimelineRuler(total, timelineState);

        let cursor = 0;
        timelineState.forEach((scene, idx) => {
          const start = cursor;
          const end = start + Number(scene.seconds || 0);
          cursor = end;
          const block = document.createElement('div');
          block.className = 'timeline-block';
          block.draggable = true;
          block.dataset.index = idx;
          block.style.flex = `0 0 ${Math.max(120, Number(scene.seconds || 1) * 14)}px`;
          block.classList.toggle('has-bg', !!scene.assets?.background);
          block.classList.toggle('has-fg', !!scene.assets?.foreground);
          block.title = [
            `Scene ${idx + 1}  ${start}s${end}s`,
            (scene.goal || 'Scene'),
            (scene.narration || '').trim() ? `Narration: ${(scene.narration || '').trim()}` : '',
            scene.assets?.background ? `BG: ${scene.assets.background}` : '',
            scene.assets?.foreground ? `FG: ${scene.assets.foreground}` : '',
          ].filter(Boolean).join('\n');

          const header = document.createElement('div');
          header.className = 'timeline-block-header';
          const headerLabel = document.createElement('div');
          headerLabel.textContent = `Scene ${idx + 1}  ${start}s${end}s`;
          const headerMeta = document.createElement('div');
          headerMeta.className = 'timeline-block-meta';
          if (scene.assets?.background) headerMeta.appendChild(buildTimelineAssetDot('background', scene.assets.background));
          if (scene.assets?.foreground) headerMeta.appendChild(buildTimelineAssetDot('foreground', scene.assets.foreground));
          const delSceneBtn = document.createElement('button');
          delSceneBtn.type = 'button';
          delSceneBtn.className = 'timeline-scene-delete';
          delSceneBtn.title = `Delete scene ${idx + 1}`;
          delSceneBtn.setAttribute('aria-label', `Delete scene ${idx + 1}`);
          delSceneBtn.innerHTML = '';
          delSceneBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const removed = timelineState.splice(idx, 1);
            if (!removed.length) return;
            if (!timelineState.length) {
              timelineState.push({
                seconds: 4,
                goal: 'New scene',
                elements: [],
                actions: [],
                narration: '',
                assets: {},
              });
            }
            renderTimeline();
            syncPlanFromTimeline();
            setStepNote('approve', 'Plan updated after scene deletion. Approve & Render to apply.');
            statusEl.textContent = `Deleted scene ${idx + 1}.`;
            showToast(`Deleted scene ${idx + 1}.`, 'ok');
            pushHistory(`Deleted scene ${idx + 1}`);
          });
          header.appendChild(headerLabel);
          header.appendChild(headerMeta);
          header.appendChild(delSceneBtn);

          const editRow = document.createElement('div');
          editRow.className = 'timeline-edit-row';
          const goalInput = document.createElement('input');
          goalInput.className = 'timeline-edit-input timeline-goal-input';
          goalInput.value = scene.goal || '';
          goalInput.placeholder = 'Scene focus (one clear idea)';
          goalInput.title = 'Inline edit: scene focus';
          goalInput.addEventListener('mousedown', (e) => e.stopPropagation());
          goalInput.addEventListener('keydown', (e) => e.stopPropagation());
          goalInput.addEventListener('input', () => {
            timelineState[idx].goal = goalInput.value;
            scheduleAutosave();
          });

          const durInput = document.createElement('input');
          durInput.className = 'timeline-dur-input';
          durInput.type = 'number';
          durInput.min = '1';
          durInput.step = '1';
          durInput.value = String(Math.max(1, Number(scene.seconds || 1)));
          durInput.title = 'Scene duration in seconds';
          durInput.addEventListener('mousedown', (e) => e.stopPropagation());
          durInput.addEventListener('keydown', (e) => e.stopPropagation());
          durInput.addEventListener('change', () => {
            const next = Math.max(1, Math.round(Number(durInput.value || scene.seconds || 1)));
            timelineState[idx].seconds = next;
            renderTimeline();
          });
          editRow.appendChild(goalInput);
          editRow.appendChild(durInput);

          const badges = document.createElement('div');
          badges.className = 'timeline-badges';
          const durBadge = document.createElement('div');
          durBadge.className = 'timeline-badge';
          durBadge.textContent = `${scene.seconds}s`;
          badges.appendChild(durBadge);
          if (scene.assets?.background) {
            const bg = buildTimelineAssetBadge('background', scene.assets.background);
            bg.title = `Background image\n${scene.assets.background}`;
            badges.appendChild(bg);
          }
          if (scene.assets?.foreground) {
            const fg = buildTimelineAssetBadge('foreground', scene.assets.foreground);
            fg.title = `Foreground image\n${scene.assets.foreground}`;
            badges.appendChild(fg);
          }

          const noteInput = document.createElement('textarea');
          noteInput.className = 'timeline-edit-note';
          noteInput.placeholder = 'Optional note (drag source/file/snippet here)';
          noteInput.value = scene.narration || '';
          noteInput.addEventListener('mousedown', (e) => e.stopPropagation());
          noteInput.addEventListener('keydown', (e) => e.stopPropagation());
          noteInput.addEventListener('input', () => {
            timelineState[idx].narration = noteInput.value;
            scheduleAutosave();
          });

          const details = document.createElement('details');
          details.className = 'timeline-details';
          const summary = document.createElement('summary');
          summary.textContent = 'Narration details';
          details.appendChild(summary);
          details.appendChild(noteInput);

          const handle = document.createElement('div');
          handle.className = 'timeline-handle';
          handle.title = 'Drag to change duration';
          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const startX = e.clientX;
            const startSec = Number(timelineState[idx].seconds || 1);
            const trackW = timelineTrackEl.getBoundingClientRect().width || 1;
            const totalSec = timelineState.reduce((s, sc) => s + Number(sc.seconds || 0), 0) || 1;
            const pxPerSec = trackW / totalSec;

            function onMove(ev) {
              const dx = ev.clientX - startX;
              const delta = dx / Math.max(8, pxPerSec);
              const next = Math.max(1, Math.round(startSec + delta));
              timelineState[idx].seconds = next;
              block.style.flex = `0 0 ${Math.max(120, next * 14)}px`;
              durBadge.textContent = `${next}s`;
            }
            function onUp() {
              window.removeEventListener('mousemove', onMove);
              window.removeEventListener('mouseup', onUp);
              renderTimeline();
            }
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
          });

          block.appendChild(header);
          block.appendChild(editRow);
          block.appendChild(badges);
          block.appendChild(details);
          block.appendChild(handle);

          block.addEventListener('dragstart', (e) => {
            block.classList.add('dragging');
            e.dataTransfer.setData('text/timeline-index', idx.toString());
            e.dataTransfer.setData('text/plain', idx.toString());
          });
          block.addEventListener('dragend', () => {
            block.classList.remove('dragging');
          });
          block.addEventListener('dragover', (e) => {
            e.preventDefault();
          });
          const handleSceneDrop = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const to = Number(block.dataset.index);
            const timelineFrom = Number(e.dataTransfer.getData('text/timeline-index'));
            if (Number.isFinite(timelineFrom) && !Number.isNaN(timelineFrom)) {
              if (timelineFrom === to) return;
              const moved = timelineState.splice(timelineFrom, 1)[0];
              timelineState.splice(to, 0, moved);
              renderTimeline();
              return;
            }
            await applyDropToSceneIndex(to, e.dataTransfer);
          };
          block.addEventListener('drop', handleSceneDrop);

          // Make drops reliable even when targeting nested controls inside a scene card.
          [header, editRow, goalInput, durInput, badges, noteInput].forEach((target) => {
            target.addEventListener('dragover', (e) => {
              e.preventDefault();
            });
            target.addEventListener('drop', handleSceneDrop);
          });

          timelineTrackEl.appendChild(block);
        });
        highlightTimelineAt(videoEl.currentTime || 0);
        if (lastPlanBox) syncPlanFromTimeline();
        refreshAppliedAssetInfo();
        refreshSceneTargetPlaceholders();
        scheduleAutosave();
        updateFirst60Checklist();
      }

      if (timelineTrackEl) {
        let trackSeeking = false;
        function seekFromTrack(clientX) {
          if (!videoEl.duration) return;
          const rect = timelineTrackEl.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
          videoEl.currentTime = pct * videoEl.duration;
          timelineScrubEl.value = Math.floor(pct * 100);
          updateTransportUI();
        }
        timelineTrackEl.addEventListener('mousedown', (e) => {
          trackSeeking = true;
          seekFromTrack(e.clientX);
        });
        window.addEventListener('mousemove', (e) => {
          if (!trackSeeking) return;
          seekFromTrack(e.clientX);
        });
        window.addEventListener('mouseup', () => { trackSeeking = false; });

        timelineTrackEl.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        timelineTrackEl.addEventListener('drop', async (e) => {
          e.preventDefault();
          if (!timelineState.length) return;
          const idx = sceneIndexFromClientX(e.clientX);
          if (idx < 0) return;
          const timelineFrom = Number(e.dataTransfer.getData('text/timeline-index'));
          if (Number.isFinite(timelineFrom) && !Number.isNaN(timelineFrom)) {
            if (timelineFrom === idx) return;
            const moved = timelineState.splice(timelineFrom, 1)[0];
            timelineState.splice(idx, 0, moved);
            renderTimeline();
            return;
          }
          await applyDropToSceneIndex(idx, e.dataTransfer);
        });
      }

      function activeSceneIndexAt(second) {
        const t = Number(second || 0);
        let cursor = 0;
        for (let i = 0; i < timelineState.length; i++) {
          const dur = Math.max(1, Number(timelineState[i]?.seconds || 1));
          if (t >= cursor && t < cursor + dur) return i;
          cursor += dur;
        }
        return -1;
      }

      function highlightTimelineAt(second) {
        const activeIdx = activeSceneIndexAt(second);
        const blocks = Array.from(timelineTrackEl.querySelectorAll('.timeline-block'));
        blocks.forEach((b, idx) => {
          b.classList.toggle('active', idx === activeIdx);
        });
      }

      function syncPlanFromTimeline() {
        if (!lastPlanBox || !timelineState.length) return;
        const total = timelineState.reduce((s, sc) => s + sc.seconds, 0);
        const plan = {
          title: timelineMeta.title || 'Scene Plan',
          total_seconds: total,
          scenes: timelineState.map((sc) => ({
            seconds: sc.seconds,
            goal: sc.goal || 'Updated scene',
            elements: sc.elements || [],
            actions: sc.actions || [],
            narration: sc.narration || '',
            assets: sc.assets || {}
          }))
        };
        lastPlanBox.value = JSON.stringify(plan, null, 2);
        currentPlanText = lastPlanBox.value;
      }

      function parseDurationText(raw) {
        const t = String(raw || '').trim().toLowerCase();
        if (!t) return 0;
        const mmss = t.match(/^(\d{1,2}):(\d{2})$/);
        if (mmss) {
          const m = Number(mmss[1] || 0);
          const s = Number(mmss[2] || 0);
          return Math.max(0, m * 60 + s);
        }
        const num = t.match(/^(\d+(?:\.\d+)?)/);
        if (!num) return 0;
        const v = Number(num[1] || 0);
        if (/m(in)?/.test(t)) return Math.round(v * 60);
        return Math.round(v);
      }

      function ensureTimelineLoadedFromPlan() {
        if (Array.isArray(timelineState) && timelineState.length) return true;
        const txt = (lastPlanBox && lastPlanBox.value) || currentPlanText || '';
        if (!txt.trim()) return false;
        try {
          const obj = JSON.parse(txt);
          if (!obj || !Array.isArray(obj.scenes)) return false;
          timelineMeta.title = obj.title || 'Scene Plan';
          timelineState = obj.scenes.map((sc) => ({
            seconds: Math.max(1, Number(sc.seconds || 1)),
            goal: sc.goal || 'Scene',
            elements: sc.elements || [],
            actions: sc.actions || [],
            narration: sc.narration || '',
            assets: sc.assets || {},
          }));
          renderTimeline();
          return timelineState.length > 0;
        } catch {
          return false;
        }
      }

      function trimTimelineBySeconds(cutSec) {
        let remaining = Math.max(0, Math.round(Number(cutSec || 0)));
        if (!remaining || !timelineState.length) return false;
        const out = timelineState.map((s) => ({ ...s }));
        while (remaining > 0 && out.length) {
          const last = out[out.length - 1];
          const dur = Math.max(1, Math.round(Number(last.seconds || 1)));
          if (dur <= remaining) {
            remaining -= dur;
            out.pop();
            continue;
          }
          last.seconds = Math.max(1, dur - remaining);
          remaining = 0;
        }
        if (!out.length) {
          out.push({
            seconds: 3,
            goal: 'Short recap',
            elements: [],
            actions: [],
            narration: 'Quick recap and close.',
            assets: {},
          });
        }
        timelineState = out;
        renderTimeline();
        syncPlanFromTimeline();
        return true;
      }

      function setTimelineTotalSeconds(targetSec) {
        const target = Math.max(3, Math.round(Number(targetSec || 0)));
        const current = timelineState.reduce((s, sc) => s + Math.max(1, Number(sc.seconds || 1)), 0);
        if (!current) return false;
        if (target === current) return true;
        if (target < current) {
          return trimTimelineBySeconds(current - target);
        }
        const delta = target - current;
        const last = timelineState[timelineState.length - 1] || null;
        const copy = last ? { ...last, assets: { ...(last.assets || {}) } } : null;
        timelineState.push({
          seconds: delta,
          goal: copy?.goal ? `Extended: ${copy.goal}` : 'Extended segment',
          elements: copy?.elements || [],
          actions: copy?.actions || [],
          narration: copy?.narration || `Extend the explanation with ${delta}s of additional clarity and examples.`,
          assets: copy?.assets || {},
        });
        renderTimeline();
        syncPlanFromTimeline();
        return true;
      }

      const DIRECTOR_BRIEF_SOFT_LIMIT = 1800;
      let lastBriefTrimNoticeAt = 0;
      function clipDirectorBrief(text) {
        const raw = String(text || '').trim();
        if (!raw) return null;
        if (raw.length <= DIRECTOR_BRIEF_SOFT_LIMIT) return raw;
        const now = Date.now();
        if (now - lastBriefTrimNoticeAt > 1600) {
          lastBriefTrimNoticeAt = now;
          if (statusEl) statusEl.textContent = 'Director brief was long. Auto-trimmed to avoid request errors.';
          showToast('Director brief auto-trimmed for request size.', 'ok');
        }
        return `${raw.slice(0, DIRECTOR_BRIEF_SOFT_LIMIT)}\n\n[Auto-trimmed for request size.]`;
      }

      async function handleAgenticEditCommand(raw) {
        const text = String(raw || '').trim().toLowerCase();
        if (!text) return false;
        const isCut = text.match(/cut\s+last\s+([0-9:]+(?:\s*(?:s|sec|secs|seconds|min|m))?)/i);
        const isExtendTo = text.match(/extend\s+to\s+([0-9:]+(?:\s*(?:s|sec|secs|seconds|min|m))?)/i);
        const isExtendBy = text.match(/extend\s+by\s+([0-9:]+(?:\s*(?:s|sec|secs|seconds|min|m))?)/i);
        const isRedo = /\bredo\b/.test(text);
        if (!isCut && !isExtendTo && !isExtendBy && !isRedo) return false;
        if (!currentJobId || !ensureTimelineLoadedFromPlan()) {
          showToast('Create a plan first, then use cut/extend commands.', 'err');
          return true;
        }

        let ok = false;
        if (isCut) {
          const sec = parseDurationText(isCut[1]);
          ok = trimTimelineBySeconds(sec);
          if (ok) addChat('agent', 'Agent edit', `Cut last ${sec}s and queued re-render.`);
        } else if (isExtendTo) {
          const sec = parseDurationText(isExtendTo[1]);
          ok = setTimelineTotalSeconds(sec);
          if (ok) addChat('agent', 'Agent edit', `Extended plan to ${sec}s and queued re-render.`);
        } else if (isExtendBy) {
          const delta = parseDurationText(isExtendBy[1]);
          const cur = timelineState.reduce((s, sc) => s + Math.max(1, Number(sc.seconds || 1)), 0);
          ok = setTimelineTotalSeconds(cur + delta);
          if (ok) addChat('agent', 'Agent edit', `Extended by ${delta}s and queued re-render.`);
        } else if (isRedo) {
          syncPlanFromTimeline();
          ok = true;
          addChat('agent', 'Agent edit', 'Redo requested. Re-rendering current plan.');
        }
        if (!ok) {
          showToast('Could not apply edit command.', 'err');
          return true;
        }
        await approvePlan(lastPlanBox ? lastPlanBox.value : currentPlanText || '');
        return true;
      }

      function buildDirectorBrief() {
        const pieces = [];
        if (directorBriefEl.value.trim()) pieces.push(directorBriefEl.value.trim());
        const creativeLines = [];
        if (creativeMotionEl) creativeLines.push(`Camera motion intensity: ${creativeMotionEl.value}/100`);
        if (creativeDensityEl) creativeLines.push(`On-screen label density: ${creativeDensityEl.value}/100`);
        if (creativeEnergyEl) creativeLines.push(`Animation energy: ${creativeEnergyEl.value}/100`);
        if (creativeComplexityEl) creativeLines.push(`Scene complexity: ${creativeComplexityEl.value}/100`);
        if (creativePolishEl) creativeLines.push(`Refinement polish: ${creativePolishEl.value}/100`);
        if (creativePrecisionEl) creativeLines.push(`Precision focus: ${creativePrecisionEl.value}/100`);
        if (creativeLines.length) pieces.push(`Creative controls:\n${creativeLines.join('\n')}`);
        if (includeImagesEl && includeImagesEl.value === 'true') {
          const imageSpec = [];
          if (imageAssetTypeEl) imageSpec.push(`Primary asset type: ${imageAssetTypeEl.value}`);
          if (imageModeEl) imageSpec.push(`Image placement mode: ${imageModeEl.value}`);
          if (imageVariantsEl) imageSpec.push(`Image variation count: ${imageVariantsEl.value}`);
          imageSpec.push(`Image prompt contract:\n${buildImagePrompt()}`);
          pieces.push(`Image generation guidance:\n${imageSpec.join('\n')}`);
        }
        const vibeLines = [];
        if (vibeEnableEl && vibeEnableEl.checked) {
          vibeLines.push('Enable vibe motion overlays and caption choreography.');
          if (vibePresetEl) vibeLines.push(`Vibe preset: ${vibePresetEl.value}`);
          if (orientationGuideEl) vibeLines.push(`Orientation guide: ${orientationGuideEl.value}`);
          if (vibeTitleEl && vibeTitleEl.value.trim()) {
            vibeLines.push(`Primary title overlay: "${vibeTitleEl.value.trim()}"`);
          }
          if (vibeCaptionModeEl) vibeLines.push(`Caption behavior: ${vibeCaptionModeEl.value}`);
          if (vibeTextAnimEl) vibeLines.push(`Text animation style: ${vibeTextAnimEl.value}`);
          if (vibeCaptionAnimEl) vibeLines.push(`Caption animation: ${vibeCaptionAnimEl.value}`);
          if (vibeCaptionPositionEl) vibeLines.push(`Caption position: ${vibeCaptionPositionEl.value}`);
          if (vibeCaptionDensityEl) vibeLines.push(`Caption density: ${vibeCaptionDensityEl.value}`);
          if (vibeOverlayStrengthEl) vibeLines.push(`Overlay intensity: ${vibeOverlayStrengthEl.value}/100`);
          if (vibeTitleWeightEl) vibeLines.push(`Title typography weight: ${vibeTitleWeightEl.value}`);
          vibeLines.push(`Frame orientation target: ${aspectEl ? aspectEl.value : '9:16'}. Keep safe margins and avoid edge clipping.`);
          vibeLines.push('Use tasteful animated text callouts for key transitions (hook, equation, recap).');
        } else {
          vibeLines.push('Keep overlay text minimal; no extra caption choreography beyond essential labels.');
        }
        pieces.push(`Vibe motion:\n${vibeLines.join('\n')}`);
        const rules = rulesTextEl.value.trim();
        if (rules) pieces.push(`Rules:\n${rules}`);
        const sub = subagentsTextEl.value.trim();
        if (sub) pieces.push(`Subagents:\n${sub}`);

        const sources = getSources();
        if (sources.length) {
          const block = sources.map((raw, i) => {
            const s = normalizeSourceRecord(raw);
            const lines = [];
            lines.push(`Source ${i + 1}: ${s.title || s.url || 'source'}`);
            if (s.kind === 'youtube' && s.video_id) lines.push(`Type: youtube (${s.video_id})`);
            else lines.push(`Type: ${s.kind || 'web'}`);
            if (s.url) lines.push(`URL: ${s.url}`);
            if (s.summary) lines.push(`Summary: ${s.summary}`);
            if (Array.isArray(s.key_points) && s.key_points.length) {
              lines.push('Key points:');
              s.key_points.slice(0, 8).forEach((p) => lines.push(`- ${p}`));
            }
            if (s.prompt_hint) lines.push(`Prompt hint: ${s.prompt_hint}`);
            if (s.file_path) lines.push(`Workspace summary file: ${s.file_path}`);
            if (!s.summary && s.notes) lines.push(`Notes: ${s.notes.slice(0, 800)}`);
            return lines.join('\n');
          }).join('\n\n');
          pieces.push(`References:\n${block}`);
        }
        return clipDirectorBrief(pieces.join('\n\n'));
      }

      async function runGeminiPromptPolish(opts = {}) {
        const silent = !!opts.silent;
        const idea = (chatInputEl.value || '').trim();
        if (!idea) {
          if (!silent) showToast('Add a prompt first.', 'err');
          return null;
        }
        if (!silent) {
          statusEl.textContent = 'Gemini assist: polishing prompt and brief';
        }
        let data = null;
        try {
          const resp = await fetch('/api/gemini/refine', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              idea,
              director_brief: buildDirectorBrief(),
              image_prompt: includeImagesEl.value === 'true' ? buildImagePrompt() : null,
              audience: audienceEl.value,
              tone: toneEl.value,
              style: styleEl.value,
              pace: paceEl.value,
              color_palette: paletteEl.value,
              model: chatModelEl.value || null
            })
          });
          data = await parseApiResponse(resp, 'Gemini assist failed.');
        } catch {
          data = { ok: false, error: 'Gemini assist failed: backend not reachable.' };
        }
        if (!data?.ok) {
          if (!silent) {
            statusEl.textContent = data?.error || 'Gemini assist failed.';
            showToast(data?.error || 'Gemini assist failed.', 'err');
          }
          return data;
        }

        if (data.refined_idea) chatInputEl.value = String(data.refined_idea);
        if (directorBriefEl && data.refined_director_brief) {
          directorBriefEl.value = String(data.refined_director_brief);
        }
        if (imagePromptEl && includeImagesEl.value === 'true' && data.refined_image_prompt) {
          imagePromptEl.value = String(data.refined_image_prompt);
        }
        scheduleAutosave();

        if (!silent) {
          const checklist = Array.isArray(data.checklist) ? data.checklist : [];
          const panel = document.createElement('div');
          panel.className = 'drawer-section';
          const intro = document.createElement('div');
          intro.className = 'muted';
          intro.textContent = 'Prompt, brief, and image prompt were refined with Gemini.';
          panel.appendChild(intro);
          if (checklist.length) {
            const ul = document.createElement('ul');
            checklist.forEach((item) => {
              const li = document.createElement('li');
              li.textContent = String(item);
              ul.appendChild(li);
            });
            panel.appendChild(ul);
          }
          addChat('agent', 'Gemini Assist', 'Refinement complete.', panel);
          statusEl.textContent = 'Gemini assist complete.';
          showToast('Gemini assist applied.', 'ok');
        }
        return data;
      }

      async function runSlashCommand(text) {
        const raw = text.trim();
        if (!raw.startsWith('/')) return false;
        const parts = raw.split(/\s+/g);
        const cmd = parts[0].toLowerCase();
        if (cmd === '/health') {
          openSettingsTab('render');
          await runHealth();
          return true;
        }
        if (cmd === '/settings') {
          openSettingsTab('api');
          return true;
        }
        if (cmd === '/clear') {
          document.getElementById('backBtn').click();
          return true;
        }
        if (cmd === '/attach') {
          const path = parts.slice(1).join(' ');
          if (!path) {
            statusEl.textContent = 'Usage: /attach notes/outline.md';
            return true;
          }
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`);
          const data = await resp.json();
          if (!data.ok) {
            statusEl.textContent = data.error || 'Attach failed.';
            return true;
          }
          chatInputEl.value = `Attached file: ${data.path}\n\n${data.content}\n\n`;
          return true;
        }
        statusEl.textContent = `Unknown command: ${cmd}`;
        return true;
      }

      async function createPlan() {
        resetSteps();
        setStep('plan', 'active');
        setStepNote('plan', 'Sending prompt to Gemini for scene planning');

        let idea = chatInputEl.value.trim();
        if (!idea) return;

        if (await handleAgenticEditCommand(idea)) return;
        if (await runSlashCommand(idea)) return;

        if (geminiAssistEl && geminiAssistEl.checked) {
          const refined = await runGeminiPromptPolish({ silent: true });
          if (refined?.ok) {
            idea = chatInputEl.value.trim();
            setStepNote('plan', 'Gemini assist refined prompt. Sending plan request');
          }
        }

        addChat('user', 'You', idea);
        setBusy(true, 'Planning', 'Planning');
        await new Promise(requestAnimationFrame);

        let data = null;
        try {
          const resp = await fetch('/api/plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              idea,
              audience: audienceEl.value,
              tone: toneEl.value,
              style: styleEl.value,
              pace: paceEl.value,
              color_palette: paletteEl.value,
              include_equations: equationsEl.value === 'true',
              include_graphs: graphsEl.value === 'true',
              include_narration: narrationEl.value === 'true',
              target_seconds: targetSecondsEl.value ? Number(targetSecondsEl.value) : null,
              max_scenes: maxScenesEl.value ? Number(maxScenesEl.value) : null,
              max_objects: maxObjectsEl.value ? Number(maxObjectsEl.value) : null,
              aspect_ratio: aspectEl.value,
              director_brief: buildDirectorBrief(),
              include_images: includeImagesEl.value === 'true',
              image_prompt: includeImagesEl.value === 'true' ? buildImagePrompt() : null,
              memory_ids: selectedMemoryIds(),
              skill_ids: selectedSkillIdsWithMentions(idea),
              model: chatModelEl.value || null
            })
          });
          data = await parseApiResponse(resp, 'Plan request failed.');
        } catch (e) {
          setBusy(false, 'Failed to reach backend.');
          showToast('Backend not reachable.', 'err');
          setStep('plan', 'error');
          setStepNote('plan', 'Backend unreachable. Start FastAPI server and retry.');
          return;
        } finally {
          setBusy(false);
        }
        if (!data.ok) {
          statusEl.textContent = data.error || 'Plan failed.';
          showToast(data.error || 'Plan failed.', 'err');
          setStep('plan', 'error');
          setStepNote('plan', data.error || 'Plan failed.');
          return;
        }
        currentJobId = data.job_id;
        persistedSceneSignature = '';
        didAnimateCode = false;
        currentPlanText = data.plan_text;
        jobIdEl.textContent = currentJobId;
        pushHistory(`Created plan ${currentJobId}`);
        if (appendFromJobId && appendFromJobId !== currentJobId) {
          statusEl.textContent = `Append mode active: base ${appendFromJobId} -> next ${currentJobId}`;
        }
        updateOutputPaths();
        updateJobFiles(data.job_files);
        if (genImagesBtn) genImagesBtn.disabled = false;
        updateBackEnabled();
        scheduleAutosave();

        const planBox = document.createElement('textarea');
        planBox.style.width = '100%';
        planBox.style.minHeight = '120px';
        planBox.style.maxHeight = '260px';
        planBox.value = data.plan_text;
        lastPlanBox = planBox;

        const approveBtn = document.createElement('button');
        approveBtn.textContent = 'Approve & Render';
        approveBtn.style.marginTop = '8px';

        const wrapper = document.createElement('div');
        if (data.plan) {
          wrapper.appendChild(buildPlanInspector(data.plan, planBox));
        }
        const jsonEditor = document.createElement('details');
        jsonEditor.className = 'drawer-section';
        const sum = document.createElement('summary');
        sum.style.cursor = 'pointer';
        sum.style.color = 'var(--muted)';
        sum.textContent = 'Editable plan JSON';
        jsonEditor.appendChild(sum);
        jsonEditor.appendChild(planBox);
        wrapper.appendChild(jsonEditor);
        wrapper.appendChild(approveBtn);

        addChat('agent', 'Scene Plan (edit if needed)', '', wrapper);
        setStep('plan', 'done');
        setStepNote('plan', `Plan ready: ${data.plan?.scenes?.length || 0} scenes.`);
        setStep('approve', 'active');
        setStepNote('approve', 'Review the plan JSON, then click Approve & Render.');

        approveBtn.addEventListener('click', async () => {
          approveBtn.disabled = true;
          approveBtn.textContent = 'Processing';
          if (timelineState.length) {
            syncPlanFromTimeline();
          }
          if (crazyModeEl && crazyModeEl.checked) {
            startCrazyCountdown(async () => {
              await createCrazyRun();
            });
            approveBtn.disabled = false;
            approveBtn.textContent = 'Approve & Render';
            setStep('approve', 'active');
            setStepNote('approve', 'Crazy mode armed. Undo within 10s or launch 3 variants.');
            return;
          }
          await approvePlan(lastPlanBox ? lastPlanBox.value : planBox.value);
          approveBtn.disabled = false;
          approveBtn.textContent = 'Approve & Render';
        });

        if (data.plan && data.plan.scenes) {
          timelineMeta.title = data.plan.title || 'Scene Plan';
          timelineState = data.plan.scenes.map(sc => ({
            seconds: sc.seconds || 3,
            goal: sc.goal,
            elements: sc.elements,
            actions: sc.actions,
            narration: sc.narration
          }));
          renderTimeline();
        }

        const session = getActiveChatSession();
        if (session) {
          session.job_id = currentJobId;
          session.plan_text = currentPlanText || '';
          session.timeline_state = Array.isArray(timelineState) ? timelineState : [];
          session.timeline_meta = { ...(timelineMeta || {}) };
          session.job_files = Array.isArray(data.job_files) ? data.job_files : [];
          session.step_states = { plan: 'done', approve: 'active', code: '', render: '' };
          session.step_notes = {
            plan: `Plan ready: ${data.plan?.scenes?.length || 0} scenes.`,
            approve: 'Review the plan JSON, then click Approve & Render.',
            code: defaultStepNotes.code,
            render: defaultStepNotes.render,
          };
          updateSessionPhase(session);
          renderChatSessions();
        }
      }

      function createSessionRecord(name) {
        const nextIndex = chatSessions.length + 1;
        return {
          id: `chat-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          name: name || makeSessionName(nextIndex),
          color: SESSION_COLORS[(nextIndex - 1) % SESSION_COLORS.length],
          prompt: '',
          model: chatModelEl?.value || 'gemini-3-flash-preview',
          messages_html: '',
          last_sig: '',
          context_lock: false,
          job_id: '',
          plan_text: '',
          timeline_state: [],
          timeline_meta: { title: 'Scene Plan' },
          video_url: '',
          logs_text: '',
          code_text: '',
          step_states: {},
          step_notes: { ...defaultStepNotes },
          phase: 'idle',
          job_files: [],
          diagnosis: '',
          code_diff: '',
          retry_result: '',
          created_at: Date.now(),
          missing_checks: 0,
          pending_delete: false,
        };
      }

      async function createCrazyRun() {
        cancelCrazyCountdown('');
        let idea = chatInputEl.value.trim();
        if (!idea) return;
        if (await runSlashCommand(idea)) return;
        if (geminiAssistEl && geminiAssistEl.checked) {
          const refined = await runGeminiPromptPolish({ silent: true });
          if (refined?.ok) {
            idea = chatInputEl.value.trim();
          }
        }
        setBusy(true, 'Launching 3 parallel variants', 'Crazy mode');
        setStep('plan', 'active');
        setStepNote('plan', 'Running 3 variants in parallel');
        let data = null;
        try {
          const resp = await fetch('/api/crazy-run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              idea,
              variants: 3,
              audience: audienceEl.value,
              tone: toneEl.value,
              style: styleEl.value,
              pace: paceEl.value,
              color_palette: paletteEl.value,
              include_equations: equationsEl.value === 'true',
              include_graphs: graphsEl.value === 'true',
              include_narration: narrationEl.value === 'true',
              target_seconds: targetSecondsEl.value ? Number(targetSecondsEl.value) : null,
              max_scenes: maxScenesEl.value ? Number(maxScenesEl.value) : null,
              max_objects: maxObjectsEl.value ? Number(maxObjectsEl.value) : null,
              aspect_ratio: aspectEl.value,
              quality: qualityEl.value,
              director_brief: buildDirectorBrief(),
              include_images: includeImagesEl.value === 'true',
              image_prompt: includeImagesEl.value === 'true' ? buildImagePrompt() : null,
              image_mode: imageModeEl.value,
              image_variants: imageVariantsEl ? Number(imageVariantsEl.value || 1) : 1,
              memory_ids: selectedMemoryIds(),
              skill_ids: selectedSkillIdsWithMentions(idea),
              model: chatModelEl.value || null,
              image_model: imageModelOverrideEl.value || null,
            }),
          });
          data = await parseApiResponse(resp, 'Crazy mode request failed.');
        } catch {
          data = { ok: false, error: 'Backend not reachable.' };
        } finally {
          setBusy(false);
        }

        if (!data || !data.ok) {
          const msg = data?.error || 'Crazy mode failed.';
          showToast(msg, 'err');
          statusEl.textContent = msg;
          setStep('plan', 'error');
          setStepNote('plan', msg);
          return;
        }

        const jobs = Array.isArray(data.jobs) ? data.jobs : [];
        if (!jobs.length) {
          showToast('No variants returned.', 'err');
          return;
        }
        const validJobs = jobs.filter((j) => !!String(j?.job_id || '').trim());
        if (!validJobs.length) {
          showToast('Crazy mode failed: backend returned no valid job ids.', 'err');
          statusEl.textContent = 'Crazy mode failed: no valid jobs were created.';
          setStep('plan', 'error');
          setStepNote('plan', 'Crazy mode failed: no valid job ids returned.');
          return;
        }
        const dropped = jobs.length - validJobs.length;
        if (dropped > 0) {
          showToast(`Skipped ${dropped} invalid variant${dropped > 1 ? 's' : ''}.`, 'err');
        }
        saveActiveSessionState();
        const labels = ['Crazy A', 'Crazy B', 'Crazy C'];
        const created = [];
        validJobs.forEach((j, idx) => {
          const session = createSessionRecord(labels[idx] || `Crazy ${idx + 1}`);
          session.job_id = j.job_id || '';
          session.plan_text = j.plan_text || '';
          if (j.plan && Array.isArray(j.plan.scenes)) {
            session.timeline_meta = { title: j.plan.title || 'Scene Plan' };
            session.timeline_state = j.plan.scenes.map((sc) => ({
              seconds: sc.seconds || 3,
              goal: sc.goal,
              elements: sc.elements,
              actions: sc.actions,
              narration: sc.narration,
              assets: sc.assets || {},
            }));
          }
          session.step_states = { plan: 'done', approve: 'done', code: 'active', render: 'active' };
          session.step_notes = {
            plan: 'Plan ready (crazy mode).',
            approve: 'Auto-approved in crazy mode.',
            code: 'Generating code',
            render: 'Rendering',
          };
          session.phase = 'queued';
          session.job_files = Array.isArray(j.job_files) ? j.job_files : [];
          chatSessions.push(session);
          created.push(session);
        });

        const first = created[0];
        if (first) {
          activeChatSessionId = first.id;
          restoreSessionState(first);
          currentJobId = first.job_id;
          jobIdEl.textContent = first.job_id || '';
          updateOutputPaths();
          updateBackEnabled();
        }
        renderChatSessions();
        startSessionPoller();
        showToast('Crazy mode running: 3 parallel variants.', 'ok');
        statusEl.textContent = 'Crazy mode started. Swipe session carousel to compare variants.';
        setStep('plan', 'done');
        setStep('approve', 'done');
        setStep('code', 'active');
        setStep('render', 'active');
        setStepNote('code', 'Running parallel code generation across variants.');
        setStepNote('render', 'Parallel renders in progress.');
        scheduleAutosave();
      }

      async function approvePlan(planText) {
        if (!currentJobId) return { ok: false };
        setStep('approve', 'active');
        setStepNote('approve', 'Running preflight checks');

        let preflight = null;
        try {
          const preResp = await fetch('/api/preflight');
          preflight = await preResp.json();
        } catch {
          preflight = null;
        }
        if (!preflight || !preflight.ok) {
          const missing = Array.isArray(preflight?.missing) ? preflight.missing : ['backend'];
          const msg = `Preflight failed: ${missing.join(', ')}.`;
          statusEl.textContent = msg;
          showToast(msg, 'err');
          setStep('approve', 'error');
          setStepNote('approve', msg);

          const wrap = document.createElement('div');
          wrap.className = 'drawer-section';
          const p = document.createElement('div');
          p.className = 'muted';
          p.textContent = `${msg} Use the fix button, then retry Approve & Render.`;
          const fixBtn = document.createElement('button');
          fixBtn.textContent = 'Fix now';
          fixBtn.style.marginTop = '8px';
          fixBtn.addEventListener('click', async () => {
            const action = preflight?.fix_action || '';
            if (action === 'open_settings_api') openSettingsTab('api');
            else openSettingsTab('render');
            if (action === 'open_settings_render_get_started' && getStartedBtn) {
              try { getStartedBtn.click(); } catch {}
            }
          });
          wrap.appendChild(p);
          wrap.appendChild(fixBtn);
          addChat('agent', 'Preflight check', msg, wrap);
          return { ok: false, error: msg };
        }

        setStep('approve', 'done');
        setStep('code', 'active');
        setStepNote('code', 'Preflight passed. Starting code generation');
        if (timelineState.length && lastPlanBox) {
          syncPlanFromTimeline();
          planText = lastPlanBox.value;
        }
        const runJobId = currentJobId;
        const preferredCodePath = resolvePreferredCodePath();
        if (preferredCodePath) {
          setStepNote('code', `Preflight passed. Generating code into ${preferredCodePath}`);
        }
        didAnimateCode = false;
        let lastPushedCode = '';
        let shownCodeToast = false;
        let finished = false;
        let resolved = false;
        return await new Promise(async (resolveRun) => {
          const finish = (payload) => {
            if (resolved) return;
            resolved = true;
            resolveRun(payload || {});
          };

          function pushCode(code, opts) {
            const text = String(code || '');
            if (!text.trim()) return;
            if (text === lastPushedCode) return;
            lastPushedCode = text;
            didAnimateCode = true;
            setActiveTab('code');
            ensureHighlightMode();
            animateCodeIntoEditor(text, opts);
            persistGeneratedSceneFile(text, true, preferredCodePath);
            const codePath = resolvePreferredCodePath(preferredCodePath) || `notes/generated/${runJobId}/scene.py`;
            statusEl.textContent = `Coding writing to ${codePath}`;
            setStepNote('code', `Code generated and saved: ${codePath}`);
            if (!shownCodeToast) {
              shownCodeToast = true;
              showToast(`Code generated -> ${codePath}`, 'ok');
            }
          }

          async function maybeAppendVideo() {
            if (!appendFromJobId || appendFromJobId === runJobId) return null;
            const baseId = appendFromJobId;
            try {
              const resp = await fetch('/api/jobs/append', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  base_job_id: baseId,
                  next_job_id: runJobId,
                }),
              });
              const data = await resp.json();
              if (!data.ok) {
                showToast(data.error || 'Append failed.', 'err');
                return null;
              }
              appendFromJobId = runJobId;
              return { ...data, appended_from: baseId };
            } catch {
              showToast('Append failed.', 'err');
              return null;
            }
          }

          async function applyFinalState(st, errText) {
            if (!st || !st.ok) {
              showToast(st?.error || 'Failed to load job results.', 'err');
              setStep('render', 'error');
              setStepNote('render', st?.error || 'Failed to load final state.');
              finish(st || { ok: false });
              return;
            }
            if (st.status === 'failed') {
              const hasCode = !!(st.code && String(st.code).trim());
              if (hasCode && st.code) pushCode(st.code, { immediate: true });
              if (hasCode) setStep('code', 'done');
              else setStep('code', 'error');
              setStep('render', 'error');
              const tail = (st.logs_tail || errText || 'Render failed.');
              setStepNote('render', 'Render failed. Check logs and retry.');
              if (/no module named manim/i.test(tail) || /manim/i.test(tail) && /not found|no such file|missing/i.test(tail)) {
                openSettingsTab('render');
                try { await runHealth(); } catch {}
              }
              const retryBtn = document.createElement('button');
              retryBtn.textContent = 'Retry Render';
              retryBtn.className = 'secondary';
              retryBtn.addEventListener('click', () => approvePlan(lastPlanBox ? lastPlanBox.value : planText));
              const reportBtn = document.createElement('button');
              reportBtn.textContent = 'Report issue';
              reportBtn.className = 'ghost';
              reportBtn.style.marginLeft = '8px';
              reportBtn.addEventListener('click', () => {
                const subject = encodeURIComponent(`NorthStar render issue - ${runJobId}`);
                const body = encodeURIComponent(
                  [
                    `Job: ${runJobId}`,
                    `Error: ${st.error || 'Render failed'}`,
                    `Retry: ${st.retry_result || 'n/a'}`,
                    '',
                    'Diagnosis:',
                    String(st.diagnosis || '').slice(0, 1800),
                    '',
                    'Log tail:',
                    String(st.logs_tail || errText || '').slice(0, 1800),
                  ].join('\n')
                );
                window.location.href = `mailto:itsarnavsalkade@gmail.com?subject=${subject}&body=${body}`;
              });
              const wrap = document.createElement('div');
              const diagPanel = document.createElement('div');
              diagPanel.className = 'drawer-section';
              const errPre = document.createElement('pre');
              errPre.style.whiteSpace = 'pre-wrap';
              errPre.style.margin = '0';
              errPre.textContent = (st.logs_tail || errText || 'Render failed.').slice(0, 6000);
              const diag = document.createElement('details');
              diag.open = true;
              const diagSum = document.createElement('summary');
              diagSum.textContent = 'Gemini diagnosis';
              const diagBody = document.createElement('pre');
              diagBody.style.whiteSpace = 'pre-wrap';
              diagBody.textContent = (st.diagnosis || 'Diagnosis unavailable.').slice(0, 4000);
              diag.appendChild(diagSum);
              diag.appendChild(diagBody);
              const diff = document.createElement('details');
              const diffSum = document.createElement('summary');
              diffSum.textContent = 'Code diff (repair)';
              const diffPre = document.createElement('pre');
              diffPre.style.whiteSpace = 'pre-wrap';
              diffPre.textContent = (st.code_diff || 'No code diff available.').slice(0, 8000);
              diff.appendChild(diffSum);
              diff.appendChild(diffPre);
              const retryInfo = document.createElement('div');
              retryInfo.className = 'muted';
              retryInfo.style.marginTop = '6px';
              retryInfo.textContent = `Retry result: ${st.retry_result || 'not_attempted'}`;
              const tip = document.createElement('div');
              tip.className = 'muted';
              tip.style.marginTop = '6px';
              tip.textContent = 'Tip: Settings -> Health verifies Manim/ffmpeg and Python path.';
              diagPanel.appendChild(errPre);
              diagPanel.appendChild(diag);
              diagPanel.appendChild(diff);
              diagPanel.appendChild(retryInfo);
              diagPanel.appendChild(tip);
              wrap.appendChild(diagPanel);
              wrap.appendChild(retryBtn);
              wrap.appendChild(reportBtn);
              addChat('agent', 'Render failed', 'Error -> diagnosis -> diff -> retry status', wrap);
              showToast('Render failed.', 'err');
              finish(st);
              return;
            }

            let finalState = st;
            const appendResult = await maybeAppendVideo();
            if (appendResult?.ok) {
              if (appendResult.video_path) finalState.video_path = appendResult.video_path;
              if (appendResult.plan) finalState.plan = appendResult.plan;
              if (appendResult.job_files) finalState.job_files = appendResult.job_files;
              setStepNote('render', `Rendered and stitched with previous segment (${appendResult.appended_from || ''}).`);
              showToast('Segment appended to previous video.', 'ok');
            }

            setStep('code', 'done');
            setStep('render', 'done');
            setStepNote('render', 'Render complete. MP4 is ready.');
            if (finalState.video_path) {
              const src = '/' + finalState.video_path + '?t=' + Date.now();
              lastVideoUrl = src;
              videoEl.src = src;
              videoEl.load();
              setVideoAvailable(true);
              pushHistory(`Rendered ${runJobId}`);
              addRenderToDeck({
                job_id: runJobId,
                video_path: finalState.video_path,
                appended_from: appendResult?.appended_from || '',
              });
            }
            lastCaptionsUrl = '';
            if (finalState.captions_path) {
              lastCaptionsUrl = '/' + finalState.captions_path + '?t=' + Date.now();
              setVideoAvailable(true);
            }
            if (finalState.code) {
              pushCode(finalState.code, { immediate: true });
              updateEditorMode();
            }
            if (finalState.plan && finalState.plan.scenes) {
              timelineMeta.title = finalState.plan.title || 'Scene Plan';
              timelineState = finalState.plan.scenes.map(sc => ({
                seconds: sc.seconds || 3,
                goal: sc.goal,
                elements: sc.elements,
                actions: sc.actions,
                narration: sc.narration,
                assets: sc.assets || {}
              }));
              renderTimeline();
            }
            if (finalState.job_files) updateJobFiles(finalState.job_files);
            if (finalState.logs_tail) logsEl.textContent = finalState.logs_tail;
            const noticeKey = `${runJobId}`;
            if (!renderNoticeByJob.has(noticeKey)) {
              renderNoticeByJob.add(noticeKey);
              if (finalState.video_path) {
                statusEl.textContent = `Render complete. Output: ${finalState.video_path}`;
              } else {
                statusEl.textContent = 'Render complete.';
              }
              showToast('Render complete.', 'ok');
            }
            updateBackEnabled();
            finish(finalState);
          }

          activeEditorTabId = 'generated';
          upsertGeneratedTab('# Generating Manim scene...\n');
          applyActiveEditorTab();
          ensureHighlightMode();

          setBusy(true, 'Generating video', 'Rendering');
          setStep('approve', 'done');
          setStep('code', 'active');
          setStep('render', 'active');
          setStepNote('approve', 'Approved. Generating code');
          setStepNote('code', 'Gemini is writing Manim code');
          setStepNote('render', 'Renderer is queued');
          setActiveTab('code');
          await new Promise(requestAnimationFrame);

          try {
            const resp = await fetch('/api/approve', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                job_id: runJobId,
                plan_text: planText,
                include_images: includeImagesEl.value === 'true',
                image_prompt: includeImagesEl.value === 'true' ? buildImagePrompt() : null,
                image_mode: imageModeEl.value,
                image_model: imageModelOverrideEl.value || null,
                image_variants: imageVariantsEl ? Number(imageVariantsEl.value || 1) : 1,
                quality: qualityEl.value,
                aspect_ratio: aspectEl.value,
                model: chatModelEl.value || null
              })
            });
            const data = await parseApiResponse(resp, 'Approve & render failed.');
            if (!data.ok) {
              setBusy(false, 'Render failed.');
              showToast(data.error || 'Render failed.', 'err');
              setStep('code', 'error');
              setStep('render', 'error');
              setStepNote('render', data.error || 'Render failed.');
              logsEl.textContent = data.error || 'Render failed.';
              finish(data);
              return;
            }
            if (data.status === 'already_running') {
              setStepNote('render', 'Render already in progress. Streaming live state');
            }
          } catch (e) {
            setBusy(false, 'Failed to reach backend.');
            showToast('Backend not reachable.', 'err');
            setStep('code', 'error');
            setStep('render', 'error');
            setStepNote('render', 'Backend unreachable.');
            finish({ ok: false, error: 'Backend not reachable.' });
            return;
          }

          // Stream logs + state live via SSE until the job completes.
          try { if (jobEventSource) jobEventSource.close(); } catch {}
          logsEl.textContent = '';
          let pollTimer = null;
          const stopPoll = () => {
            if (pollTimer) {
              clearInterval(pollTimer);
              pollTimer = null;
            }
          };
          const es = new EventSource(`/api/jobs/${encodeURIComponent(runJobId)}/events`);
          jobEventSource = es;
          pollTimer = setInterval(async () => {
            if (!runJobId || finished) return;
            try {
              const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
              const st = await stResp.json();
              if (!st.ok) return;
              if (st.code) pushCode(st.code);
              if (st.job_files) updateJobFiles(st.job_files);
              if (st.status === 'done' || st.status === 'failed') {
                finished = true;
                stopPoll();
                try { es.close(); } catch {}
                jobEventSource = null;
                setBusy(false);
                await applyFinalState(st, st.error || '');
              }
            } catch {}
          }, 450);
          es.onerror = () => {
            if (!finished) {
              statusEl.textContent = 'Live stream dropped, using polling fallback';
              setStepNote('render', 'SSE dropped, polling fallback active.');
            }
          };
          es.addEventListener('log', (e) => {
            try {
              const data = JSON.parse(e.data);
              if (data.chunk) {
                logsEl.textContent += data.chunk;
                logsEl.scrollTop = logsEl.scrollHeight;
              }
            } catch {}
          });
          es.addEventListener('code', (e) => {
            try {
              const data = JSON.parse(e.data);
              if (data.code) pushCode(data.code);
            } catch {}
          });
          es.addEventListener('state', async (e) => {
            let s = null;
            try { s = JSON.parse(e.data); } catch { s = null; }
            const status = s?.status || '';
            const step = s?.step || '';
            const msg = s?.message || '';
            const err = s?.error || '';
            if (msg) statusEl.textContent = msg;
            if (busySubEl && msg) busySubEl.textContent = msg;

            if (step === 'code') {
              setStep('code', 'active');
              setStep('render', '');
              setStepNote('code', msg || 'Generating code');
            }
            if (step === 'render') {
              setStep('code', 'done');
              setStep('render', 'active');
              setStepNote('render', msg || 'Rendering');
              if (!didAnimateCode) {
                try {
                  const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
                  const st = await stResp.json();
                  if (st.ok && st.code) pushCode(st.code);
                  if (st.ok && st.job_files) updateJobFiles(st.job_files);
                } catch {}
              }
            }
            if (status === 'repairing') {
              setStep('render', 'active');
              setStepNote('render', msg || 'Repairing code and retrying render');
            }

            if (status === 'done' || status === 'failed') {
              if (finished) return;
              finished = true;
              stopPoll();
              try { es.close(); } catch {}
              jobEventSource = null;
              setBusy(false);
              let st = null;
              try {
                const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
                st = await stResp.json();
              } catch {
                showToast('Failed to load final job state.', 'err');
                setStep('render', 'error');
                setStepNote('render', 'Failed to load final state.');
                finish({ ok: false, error: 'Failed to load final state.' });
                return;
              }
              await applyFinalState(st, err);
            }
          });
        });
      }

      renderCodeBtn.addEventListener('click', async () => {
        if (!codeEl.value.trim()) return;
        if (openFilePath && !openFilePath.endsWith('.py')) {
          statusEl.textContent = 'Render disabled: you are editing a non-Python workspace file.';
          return;
        }
        const resp = await fetch('/api/render-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: codeEl.value, quality: qualityEl.value })
        });
        const data = await parseApiResponse(resp, 'Render code request failed.');
        if (!data.ok) {
          statusEl.textContent = data.error || 'Render failed.';
          showToast(data.error || 'Render failed.', 'err');
          logsEl.textContent = data.logs || data.error || 'Render failed.';
          return;
        }
        const src = '/' + data.video_path + '?t=' + Date.now();
        lastVideoUrl = src;
        videoEl.src = src;
        videoEl.load();
        setVideoAvailable(true);
        addRenderToDeck({
          job_id: currentJobId || 'manual',
          video_path: data.video_path,
          appended_from: '',
        });
        updateEditorMode();
        updateJobFiles(data.job_files);
        logsEl.textContent = data.logs || 'Render complete.';
        showToast('Render complete.', 'ok');
        pushHistory(`Rendered ${currentJobId || 'code'}`);
      });

      downloadVideoBtn.addEventListener('click', () => {
        if (!videoEl.src) return;
        const a = document.createElement('a');
        a.href = videoEl.src;
        a.download = currentJobId ? `${currentJobId}.mp4` : 'out.mp4';
        document.body.appendChild(a);
        a.click();
        a.remove();
        showToast('Downloading video', 'ok');
      });

      async function execTerminalCommand(cmd, { append = false, silent = false } = {}) {
        const command = (cmd || '').trim();
        if (!command) return '';
        termRunEl.disabled = true;
        termCmdEl.value = command;
        const prefix = `${append ? '\n' : ''}> ${command}\n`;
        logsEl.textContent = (append ? (logsEl.textContent || '') : '') + prefix;
        try {
          const resp = await fetch('/api/terminal/run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command })
          });
          const data = await resp.json();
          const output = data.ok ? (data.output || '') : (data.error || 'Command failed');
          if (!silent) logsEl.textContent += (output || '') + '\n';
          if (data.ok) pushHistory(`Terminal: ${command}`);
          return output || '';
        } catch (e) {
          logsEl.textContent += 'Failed to reach backend.\n';
          return '';
        } finally {
          termRunEl.disabled = false;
        }
      }

      async function runTerminalCommand() {
        const cmd = (termCmdEl.value || '').trim();
        if (!cmd) return;
        await execTerminalCommand(cmd, { append: false });
      }
      safeOn(termRunEl, 'click', runTerminalCommand);
      safeOn(termCmdEl, 'keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          runTerminalCommand();
        }
      });

      safeOn(timelineScrubEl, 'input', () => {
        if (!videoEl.duration) return;
        const pct = Number(timelineScrubEl.value) / 100;
        videoEl.currentTime = pct * videoEl.duration;
        updateTransportUI();
      });
      safeOn(videoEl, 'timeupdate', () => {
        if (!videoEl.duration) return;
        timelineScrubEl.value = Math.floor((videoEl.currentTime / videoEl.duration) * 100);
        updateTransportUI();
      });
      if (timelineRulerEl) {
        let rulerSeeking = false;
        function seekFromRulerClientX(clientX) {
          if (!videoEl.duration) return;
          const rect = timelineRulerEl.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
          videoEl.currentTime = pct * videoEl.duration;
          timelineScrubEl.value = Math.floor(pct * 100);
          updateTransportUI();
        }
        timelineRulerEl.addEventListener('mousedown', (e) => {
          rulerSeeking = true;
          seekFromRulerClientX(e.clientX);
        });
        window.addEventListener('mousemove', (e) => {
          if (!rulerSeeking) return;
          seekFromRulerClientX(e.clientX);
        });
        window.addEventListener('mouseup', () => {
          rulerSeeking = false;
        });
      }

      safeOn(planBtn, 'click', createPlan);
      safeOn(crazyUndoBtnEl, 'click', () => cancelCrazyCountdown('Crazy mode launch cancelled.'));
      safeOn(crazyModeEl, 'change', () => {
        if (!crazyModeEl.checked) cancelCrazyCountdown('');
      });
      safeOn(polishPromptBtn, 'click', () => runGeminiPromptPolish({ silent: false }));
      safeOn(first60DemoBtn, 'click', () => {
        seedDemoDefaults();
        updateFirst60Checklist();
        showToast('Demo prompt loaded.', 'ok');
      });
      safeOn(first60HealthBtn, 'click', async () => {
        openSettingsTab('render');
        await runHealth();
        await refreshSidebarHealth();
      });
      safeOn(first60HideBtn, 'click', () => setFirst60Visible(false, true));
      safeOn(first60ShowBtn, 'click', () => setFirst60Visible(true, true));
      safeOn(saveSettingsBtn, 'click', saveSettings);
      safeOn(getStartedBtn, 'click', async () => {
        openSettingsTab('render');
        lastHealthData = await runHealth();
        if (!lastHealthData) return;
        const missing = [];
        if (!lastHealthData.manim_ok) missing.push('manim');
        if (!lastHealthData.ffmpeg_ok) missing.push('ffmpeg');
        if (!missing.length) {
          showInstallPrompt([]);
          showToast('All dependencies are ready.', 'ok');
          return;
        }
        showInstallPrompt(missing);
        showToast('Missing dependencies detected.', 'err');
      });
      safeOn(installDepsBtn, 'click', installMissingDeps);
      safeOn(cancelInstallBtn, 'click', () => showInstallPrompt([]));
      safeOn(copyOutputNowBtn, 'click', async () => {
        if (!currentJobId) {
          showToast('Render a video first.', 'err');
          return;
        }
        try {
          const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/copy-output`, { method: 'POST' });
          const data = await resp.json();
          if (!data.ok) {
            showToast(data.error || 'Copy failed.', 'err');
            return;
          }
          showToast(`Copied to ${data.copied_path}`, 'ok');
          pushHistory(`Copied output for ${currentJobId}`);
        } catch {
          showToast('Copy request failed.', 'err');
        }
      });
      safeOn(runHealthBtn, 'click', async () => {
        await runHealth();
        await refreshSidebarHealth();
      });
      safeOn(refreshSidebarHealthBtn, 'click', refreshSidebarHealth);
      safeOn(resetLayoutBtn, 'click', resetLayout);
      safeOn(replayWelcomeBtn, 'click', () => {
        try { localStorage.removeItem(WELCOME_SEEN_KEY); } catch {}
        openWelcome();
      });
      safeOn(addMemoryBtn, 'click', addMemory);
      safeOn(skillRailPrevEl, 'click', () => scrollSkillRail(-240));
      safeOn(skillRailNextEl, 'click', () => scrollSkillRail(240));
      safeOn(saveSkillBtn, 'click', saveSkill);
      safeOn(generateSkillBtn, 'click', generateSkill);
      safeOn(subagentsTextEl, 'input', () => {
        renderSubagentCards();
        scheduleAutosave();
      });
      safeOn(aspectEl, 'change', () => setPreviewAspect(aspectEl.value));
      safeOn(aspectQuickEl, 'change', () => {
        setPreviewAspect(aspectQuickEl.value);
        scheduleAutosave();
      });
      safeOn(crazyModeEl, 'change', () => {
        syncComposeModeChips();
        scheduleAutosave();
      });
      safeOn(geminiAssistEl, 'change', () => {
        syncComposeModeChips();
        scheduleAutosave();
      });
      safeOn(imagePresetEl, 'change', () => {
        applyImagePreset(imagePresetEl.value, true);
      });
      safeOn(vibePresetEl, 'change', () => {
        applyVibePreset(vibePresetEl.value, true);
      });
      safeOn(orientationGuideEl, 'change', () => {
        applyOrientationGuidePreset(orientationGuideEl.value, true);
      });
      safeOn(applyOrientationGuideEl, 'click', () => {
        applyOrientationGuidePreset(orientationGuideEl ? orientationGuideEl.value : 'auto', true);
      });
      safeOn(durationPresetEl, 'change', () => {
        const val = Number(durationPresetEl.value || 0);
        if (!Number.isFinite(val) || val <= 0) return;
        targetSecondsEl.value = String(val);
        scheduleAutosave();
      });
      safeOn(applyRenameBtn, 'click', renamePending);
      safeOn(genImagesBtn, 'click', generateImages);
      safeOn(applyBgSceneBtn, 'click', () => applyAssetToSceneFromInput('background', bgSceneTargetEl));
      safeOn(applyBgAllBtn, 'click', () => applyAssetToAllScenes('background'));
      safeOn(clearBgAllBtn, 'click', () => clearAssetFromAllScenes('background'));
      safeOn(applyFgSceneBtn, 'click', () => applyAssetToSceneFromInput('foreground', fgSceneTargetEl));
      safeOn(applyFgAllBtn, 'click', () => applyAssetToAllScenes('foreground'));
      safeOn(clearFgAllBtn, 'click', () => clearAssetFromAllScenes('foreground'));
      safeOn(resetSceneAssetsBtn, 'click', resetSceneAssetAssignments);
      safeOn(bgSceneTargetEl, 'keydown', (e) => {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        applyAssetToSceneFromInput('background', bgSceneTargetEl);
      });
      safeOn(fgSceneTargetEl, 'keydown', (e) => {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        applyAssetToSceneFromInput('foreground', fgSceneTargetEl);
      });
      safeOn(createFolderBtn, 'click', createFolder);
      safeOn(createFileBtn, 'click', createFile);
      safeOn(newCodeTabBtn, 'click', createNewCodeTabFile);
      safeOn(newPathEl, 'keydown', (e) => {
        if (e.key === 'Enter' && pendingRenameFrom) {
          e.preventDefault();
          renamePending();
        }
      });

      safeOn(saveFileBtn, 'click', saveWorkspaceFile);
      safeOn(undoCodeBtn, 'click', () => {
        codeEl.focus();
        try { document.execCommand('undo'); } catch {}
      });
      safeOn(redoCodeBtn, 'click', () => {
        codeEl.focus();
        try { document.execCommand('redo'); } catch {}
      });
      window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
          if (openFilePath) {
            e.preventDefault();
            saveWorkspaceFile();
          }
        }
      });

      safeOn(sourceUrlEl, 'input', () => {
        const url = String(sourceUrlEl?.value || '').trim().toLowerCase();
        if (!sourceTypeEl) return;
        if (!url) return;
        if (url.includes('youtube.com') || url.includes('youtu.be')) {
          sourceTypeEl.value = 'youtube';
          return;
        }
        if (sourceTypeEl.value === 'youtube') sourceTypeEl.value = 'auto';
      });

      safeOn(indexSourceBtn, 'click', async () => {
        const url = sourceUrlEl.value.trim();
        const notes = sourceNotesEl.value.trim();
        const sourceType = (sourceTypeEl?.value || 'auto').trim();
        if (!url) {
          setSourceStatus('Enter a source URL first.', 'err');
          showToast('Enter a source URL first.', 'err');
          return;
        }
        const looksYoutube = /youtu\.be|youtube\.com/i.test(url);
        setSourceStatus(
          looksYoutube
            ? 'Indexing YouTube source (fetching transcript/description)'
            : 'Indexing source with Gemini',
          'loading'
        );
        const indexBtnLabel = indexSourceBtn.textContent || 'Index source';
        indexSourceBtn.disabled = true;
        indexSourceBtn.classList.add('indexing');
        indexSourceBtn.textContent = 'Indexing';
        if (sourceCardsEl) {
          sourceCardsEl.innerHTML = `
            <div class="saved-card index-skeleton">
              <div class="saved-card-title">Preparing source summary</div>
              <div class="saved-card-body">Gemini is extracting context and key points.</div>
            </div>
          `;
        }
        try {
          const resp = await fetch('/api/docs/index', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url,
              notes,
              source_type: sourceType,
              model: chatModelEl?.value || null,
            }),
          });
          const data = await parseApiResponse(resp, 'Indexing failed.');
          if (!data.ok || !data.indexed) {
            if (looksYoutube) {
              const fallback = buildYoutubeFallbackSource(url, notes);
              upsertSource(fallback);
              setSourceStatus('YouTube fallback saved. Add notes/transcript and re-index for richer context.', 'warn');
              showToast(data.error || 'Transcript unavailable, fallback source saved.', 'ok');
            } else {
              setSourceStatus(data.error || 'Indexing failed.', 'err');
              showToast(data.error || 'Indexing failed.', 'err');
            }
            renderSources({ preserveStatus: true });
            return;
          }
          const indexed = normalizeSourceRecord({
            ...data.indexed,
            notes,
            source_type: sourceType,
            saved_at: new Date().toISOString(),
          });
          const savedPath = await persistSourceSummaryFile(data.indexed);
          if (savedPath) indexed.file_path = savedPath;
          upsertSource(indexed);
          renderSources();
          const transcriptMeta = indexed.kind === 'youtube'
            ? ` | transcript: ${data.indexed.transcript_used ? 'yes' : 'no'}`
            : '';
          if (savedPath) setSourceStatus(`Indexed ${indexed.kind} source${transcriptMeta}. Saved: ${savedPath}`, 'ok');
          else setSourceStatus(`Indexed ${indexed.kind} source${transcriptMeta}.`, 'ok');
          if (data.warning) {
            setSourceStatus(data.warning, 'warn');
            showToast(data.warning, 'err');
          } else {
            showToast('Source indexed.', 'ok');
          }
          sourceUrlEl.value = '';
          sourceNotesEl.value = '';
          scheduleAutosave();
        } catch {
          if (looksYoutube) {
            const fallback = buildYoutubeFallbackSource(url, notes);
            upsertSource(fallback);
            setSourceStatus('Backend unavailable. Saved YouTube source in fallback mode.', 'warn');
            showToast('Saved fallback source (backend unavailable).', 'ok');
          } else {
            setSourceStatus('Failed to reach backend. Is the server running?', 'err');
            showToast('Failed to reach backend.', 'err');
          }
          renderSources({ preserveStatus: true });
        } finally {
          indexSourceBtn.disabled = false;
          indexSourceBtn.classList.remove('indexing');
          indexSourceBtn.textContent = indexBtnLabel;
        }
      });

      safeOn(saveSourceBtn, 'click', () => {
        const url = sourceUrlEl.value.trim();
        const notes = sourceNotesEl.value.trim();
        if (!url && !notes) {
          setSourceStatus('Enter a URL or notes before saving.', 'err');
          return;
        }
        const manual = normalizeSourceRecord({
          id: `src-manual-${Date.now()}`,
          url,
          notes,
          source_type: sourceTypeEl?.value || 'auto',
          kind: sourceTypeEl?.value === 'youtube' ? 'youtube' : 'web',
          title: url ? `Manual source: ${compactLabel(url, 48)}` : 'Manual notes source',
          summary: cleanInline(notes).slice(0, 320),
          key_points: [],
          prompt_hint: '',
          saved_at: new Date().toISOString(),
        });
        upsertSource(manual);
        renderSources();
        sourceUrlEl.value = '';
        sourceNotesEl.value = '';
        setSourceStatus('Saved source without indexing.', 'ok');
        showToast('Saved source.', 'ok');
        scheduleAutosave();
      });

      safeOn(openInstallGuideBtn, 'click', () => {
        openSettingsTab('render');
        if (!healthEl) return;
        healthEl.textContent = [
          'Install Guide (macOS)',
          '1) cd /Users/hema/Desktop/Gemini-Hack-Manim',
          '2) python3 -m venv .venv',
          '3) source .venv/bin/activate',
          '4) python -m pip install -U pip',
          '5) python -m pip install -r requirements.txt',
          '6) python -m pip install manim',
          '7) brew install ffmpeg',
          '8) python -m manim --version',
          '9) python -m uvicorn backend.main:app --reload --port 8000',
          '',
          'Install Guide (Linux)',
          'A) sudo apt-get update',
          'B) sudo apt-get install -y ffmpeg libcairo2-dev pango1.0-tools',
          'C) run steps 1, 3, 4, 5, 6, 8, 9 above',
        ].join('\n');
      });

      function seedDemoDefaults() {
        // Keep this lightweight: only fill if the user hasn't typed anything.
        if (!chatInputEl.value.trim()) {
          chatInputEl.value = 'Explain the photoelectric effect in 60 seconds (red vs blue light, threshold frequency, Einstein equation).';
        }
        if (!imagePromptEl.value.trim()) {
          imagePromptEl.value = 'Matte black cinematic background, soft vignette, subtle texture, no text, no objects';
        }
        if (imagePresetEl && !imagePresetEl.value) imagePresetEl.value = 'matte_black_stage';
        if (imageAssetTypeEl && !imageAssetTypeEl.value) imageAssetTypeEl.value = 'cinematic_background';
        if (imageMinorEditEl && !String(imageMinorEditEl.value || '').trim()) imageMinorEditEl.value = '';
        if (!includeImagesEl.value) includeImagesEl.value = 'true';
        if (!imageModeEl.value) imageModeEl.value = 'background';
        if (imageVariantsEl && !imageVariantsEl.value) imageVariantsEl.value = '1';

        if (!aspectEl.value) aspectEl.value = '9:16';
        if (!audienceEl.value) audienceEl.value = 'high school';
        if (!toneEl.value) toneEl.value = 'epic';
        if (!styleEl.value) styleEl.value = 'cinematic';
        if (!paceEl.value) paceEl.value = 'medium';
        if (!paletteEl.value) paletteEl.value = 'cool';
        if (!qualityEl.value) qualityEl.value = 'pqm';
        if (!targetSecondsEl.value.trim()) targetSecondsEl.value = '60';
        if (!maxScenesEl.value.trim()) maxScenesEl.value = '6';
        if (vibeEnableEl) vibeEnableEl.checked = true;
        if (vibePresetEl && !vibePresetEl.value) vibePresetEl.value = 'cinematic_science';
        if (orientationGuideEl && !orientationGuideEl.value) orientationGuideEl.value = 'portrait_9_16';
        if (vibeTitleEl && !vibeTitleEl.value.trim()) vibeTitleEl.value = 'The Quantum Spark';
        if (vibeCaptionModeEl && !vibeCaptionModeEl.value) vibeCaptionModeEl.value = 'concise';
        if (vibeTextAnimEl && !vibeTextAnimEl.value) vibeTextAnimEl.value = 'cinematic_fade';
        if (vibeCaptionAnimEl && !vibeCaptionAnimEl.value) vibeCaptionAnimEl.value = 'soft_fade';
        if (vibeCaptionPositionEl && !vibeCaptionPositionEl.value) vibeCaptionPositionEl.value = 'lower_third';
        if (vibeCaptionDensityEl && !vibeCaptionDensityEl.value) vibeCaptionDensityEl.value = 'balanced';
        if (vibeOverlayStrengthEl && !String(vibeOverlayStrengthEl.value || '').trim()) vibeOverlayStrengthEl.value = '62';
        if (vibeTitleWeightEl && !vibeTitleWeightEl.value) vibeTitleWeightEl.value = 'bold';

        if (!rulesTextEl.value.trim()) {
          rulesTextEl.value = [
            'Show 1 concept at a time.',
            'Keep all text centered with safe padding for 9:16.',
            'Always label variables when introduced; avoid clutter.',
            'Use simple arrows/axes; avoid tiny text.',
          ].join('\\n');
        }
        if (!subagentsTextEl.value.trim()) {
          subagentsTextEl.value = [
            'PhotonCoach: drives photon-vs-wave framing and keeps threshold intuition clear.',
            'LabDesigner: builds emitter plate, collector, stopping-potential layout with clean labels.',
            'EquationTutor: introduces K_max = h f - phi and eV_s = K_max one symbol at a time.',
            'GraphAnalyst: ensures K_max vs f graph shows f0 intercept and slope meaning.',
            'VisualPacer: enforces one concept at a time and smooth transitions for short-form video.',
            'SafetyQA: validates spacing, overlap, and readability for 9:16 and 16:9 exports.',
          ].join('\\n');
        }

        try {
          const sources = getSources();
          if (!sources.length) {
            setSources([{
              url: 'https://example.com/photoelectric-effect',
              notes: 'Key points to include:\\n- Intensity changes number of emitted electrons (when above threshold).\\n- Frequency must exceed threshold: f > f0 (work function).\\n- Einstein: K_max = h f - .\\n- Stopping potential: e V_s = K_max.',
              saved_at: new Date().toISOString()
            }]);
            renderSources();
          }
        } catch {}

        if (termCmdEl && !termCmdEl.value.trim()) termCmdEl.value = 'help';
        setPreviewAspect(aspectEl.value);
        renderSubagentCards();
        renderMentionBar();
      }

      // Boot
      // Keep the button clickable; if there's no job_id yet we'll show a hint toast.
      loadTemplates();
      loadSettings();
      loadMemories();
      loadSkills();
      loadWorkspaceFiles();
      initImagePresetControls();
      renderSources();
      setPreviewAspect(aspectEl.value);
      initChatSessions();
      startSessionPoller();
      updateEditorMode();
      applyLayoutColumns();
      const didRestore = restoreProject();
      if (!didRestore) seedDemoDefaults();
      syncComposeModeChips();
      refreshTimelineVisibility();
      refreshCreativeReadouts();
      refreshSceneTargetPlaceholders();
      applyVibePreset(vibePresetEl ? vibePresetEl.value : 'cinematic_science', false);
      applyOrientationGuidePreset(orientationGuideEl ? orientationGuideEl.value : 'auto', false);
      ensurePhysicsSubagentsForDemo();
      renderSubagentCards();
      renderMentionBar();
      ensureGeneratedTab();
      renderEditorTabs();
      renderHistory();
      renderDeckUI();
      setTerminalMode(false);
      setContextTab('memory');
      setVideoAvailable(false);
      updateOutputPaths();
      updateTopbarToggles();
      updateStepProgress();
      refreshSidebarHealth();
      setInterval(refreshSidebarHealth, 30000);
      try {
        const hidden = localStorage.getItem(FIRST60_HIDE_KEY) === '1';
        setFirst60Visible(!hidden, false);
      } catch {
        setFirst60Visible(true, false);
      }
      updateFirst60Checklist();
      maybeOpenWelcome();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  </body>
</html>
