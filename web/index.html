<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NorthStar</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230b1220'/%3E%3Cpath d='M14 42V22h6v20h-6zm10 0V22h6v8l10-8h8L36 31l13 11h-8l-11-9v9h-6z' fill='%236aa9ff'/%3E%3C/svg%3E" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
    <style>
      @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap');

      :root {
        color-scheme: dark;
        --bg: #0b0d12;
        --panel: #14171d;
        --panel-2: #1a1f26;
        --panel-3: #0f131a;
        --text: #e6e9ef;
        --muted: #9aa4b2;
        --accent: #6aa9ff;
        --accent-2: #22c55e;
        --border: #242a33;
        --tab: #151a22;
        --danger: #ef4444;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: 'IBM Plex Sans', sans-serif;
        background: radial-gradient(circle at top, #111620 0%, #0b0d12 40%, #0a0c10 100%);
        color: var(--text);
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        background: #0c0f14;
        border-bottom: 1px solid var(--border);
      }
      .window-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        min-width: 80px;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: #ef4444;
      }
      .dot.yellow { background: #f59e0b; }
      .dot.green { background: #22c55e; }
      .topbar-title {
        font-weight: 600;
        color: #d7dce5;
        letter-spacing: 0.4px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }
      .badge {
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(12, 15, 20, 0.35);
        color: var(--muted);
      }
      .topbar-actions {
        display: flex;
        gap: 8px;
      }
      .icon-btn {
        background: #0f141d;
        border: 1px solid var(--border);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
      }
      .icon-btn svg { width: 16px; height: 16px; }
      .icon-btn.primary {
        background: var(--accent);
        color: #0b0f14;
        border: none;
        font-weight: 700;
      }
      .icon-btn.primary svg { stroke: #0b0f14; }
      .icon-btn.toggled {
        border-color: rgba(106,169,255,0.55);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.14) inset;
      }
      .icon-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .icon-btn[data-tip]:hover::after {
        content: attr(data-tip);
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: rgba(12, 15, 20, 0.92);
        border: 1px solid rgba(255,255,255,0.14);
        color: var(--text);
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        z-index: 50;
        box-shadow: 0 14px 36px rgba(0,0,0,0.35);
      }
      .icon-btn[data-tip]:hover::before {
        content: "";
        position: absolute;
        top: calc(100% + 2px);
        right: 12px;
        border: 6px solid transparent;
        border-bottom-color: rgba(255,255,255,0.14);
        z-index: 51;
        pointer-events: none;
      }
      .icon-btn[data-tip]:focus-visible::after,
      .icon-btn[data-tip]:focus-visible::before {
        opacity: 1;
      }

      .layout {
        display: grid;
        grid-template-columns: 280px 6px 1fr 6px 360px;
        grid-template-rows: 1fr;
        height: calc(100vh - 48px);
        gap: 0;
      }

      /* Pin items to specific columns so toggling widths never reflows to a new row. */
      #leftPanel { grid-column: 1; grid-row: 1; }
      #splitterLeft { grid-column: 2; grid-row: 1; }
      main.workspace { grid-column: 3; grid-row: 1; }
      #splitterRight { grid-column: 4; grid-row: 1; }
      #rightPanel { grid-column: 5; grid-row: 1; }

      .splitter {
        background: #0f141d;
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        cursor: col-resize;
      }
      .splitter.hidden { display: none; }

      .panel {
        background: var(--panel);
        border-right: 1px solid var(--border);
        border-left: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      .panel-header {
        padding: 10px 12px;
        font-weight: 600;
        border-bottom: 1px solid var(--border);
        background: var(--panel-2);
      }
      .panel-body {
        padding: 10px 12px;
        overflow: auto;
      }
      #leftPanel .panel-body {
        display: flex;
        flex-direction: column;
      }
      #historyPanel { margin-top: auto; }

      .tabs {
        display: flex;
        gap: 6px;
        padding: 8px;
        background: var(--panel-2);
        border-bottom: 1px solid var(--border);
      }
      .tab {
        padding: 6px 12px;
        border-radius: 8px;
        background: var(--tab);
        border: 1px solid var(--border);
        font-size: 12px;
        cursor: pointer;
        color: var(--muted);
      }
      .tab.active {
        background: #1c2430;
        border-color: var(--accent);
        color: var(--accent);
      }

      .tab-panels {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .tab-panel {
        display: none;
        padding: 12px;
        flex: 1;
        min-height: 0;
        /* Keep the middle pane "IDE fixed". Specific panels implement their own internal scrolling. */
        overflow: hidden;
      }
      .tab-panel.active { display: block; }
      /* Keep the middle pane fixed; allow only internal cards to scroll. */
      .tab-panel[data-tab="canvas"] { overflow: hidden; }
      .tab-panel[data-tab="code"].active,
      .tab-panel[data-tab="settings"].active {
        display: flex;
        flex-direction: column;
      }

      .tree {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        display: grid;
        gap: 6px;
      }
      .tree summary { cursor: pointer; color: #93c5fd; list-style: none; }
      .tree summary::-webkit-details-marker { display: none; }
      .tree details { padding-left: 0; }
      .tree details > .tree-children {
        margin-left: 14px;
        padding-left: 10px;
        border-left: 1px solid rgba(255,255,255,0.08);
        display: grid;
        gap: 4px;
      }
      .tree .tree-file {
        color: #cbd5f5;
        padding-left: 0;
        cursor: grab;
      }
      .tree .tree-file:hover { color: var(--accent); }
      .tree-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        align-items: center;
        gap: 8px;
        padding-left: 12px;
        border-radius: 8px;
        padding-top: 3px;
        padding-bottom: 3px;
      }
      .tree-row.selected {
        background: rgba(106,169,255,0.14);
        border: 1px solid rgba(106,169,255,0.35);
      }
      .tree-row-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .tree-row-name input {
        width: 100%;
        padding: 4px 6px;
        border-radius: 8px;
        font-size: 12px;
        line-height: 1.25;
      }
      .tree-row-actions {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .tree-act {
        width: 24px;
        height: 24px;
        min-width: 24px;
        padding: 0;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--muted);
        font-size: 11px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .tree-act svg {
        width: 12px;
        height: 12px;
        display: block;
      }
      .tree-act:hover {
        color: var(--text);
        border-color: rgba(106,169,255,0.55);
      }
      .tree-act.danger:hover {
        border-color: rgba(239,68,68,0.55);
        color: #fca5a5;
      }
      .tree-act.confirm {
        border-color: rgba(34,197,94,0.55);
        color: #86efac;
      }
      .tree-act.confirm:hover {
        border-color: rgba(34,197,94,0.85);
        color: #dcfce7;
      }
      .tree-act.reject {
        border-color: rgba(239,68,68,0.55);
        color: #fca5a5;
      }
      .tree-act.reject:hover {
        border-color: rgba(239,68,68,0.85);
        color: #ffe4e6;
      }

      .section-title {
        margin-top: 12px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
        display: block;
        margin-bottom: 6px;
      }
      input, select, textarea, button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: var(--panel-3);
        color: var(--text);
        font-family: inherit;
      }
      textarea { min-height: 90px; }
      button {
        background: var(--accent);
        color: #0b1220;
        font-weight: 700;
        border: none;
        cursor: pointer;
      }
      button.secondary { background: #1f2937; color: var(--text); }
      button.ghost { background: transparent; border: 1px solid var(--border); color: var(--text); }

      .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .row.small { grid-template-columns: 1fr auto auto auto; align-items: center; }
      .muted { color: var(--muted); font-size: 12px; }
      code { font-family: 'IBM Plex Mono', monospace; font-size: 12px; }

      .workspace { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }

      .canvas-grid {
        display: grid;
        grid-template-columns: 1fr;
        /* Top/bottom canvas sections are draggable via splitter. */
        --canvas-top: 72%;
        --canvas-timeline: 16%;
        --canvas-controls: calc(100% - var(--canvas-top) - var(--canvas-timeline) - 8px);
        grid-template-rows: minmax(180px, var(--canvas-top)) 8px minmax(110px, var(--canvas-timeline)) minmax(120px, var(--canvas-controls));
        gap: 12px;
        height: 100%;
        min-height: 0;
      }
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 12px;
        min-height: 0;
      }
      .card.scroll { overflow: auto; }
      .timeline-card { grid-column: 1 / -1; }
      .timeline-card {
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .preview-card { display: flex; flex-direction: column; min-height: 0; }
      .controls-card { grid-column: 1 / -1; grid-row: 4; overflow: auto; }
      .preview-card { grid-column: 1 / -1; grid-row: 1; }
      .timeline-card { grid-column: 1 / -1; grid-row: 3; }
      .canvas-splitter {
        grid-column: 1 / -1;
        grid-row: 2;
        height: 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(106,169,255,0.18), rgba(106,169,255,0.08));
        cursor: row-resize;
        position: relative;
        z-index: 6;
        pointer-events: auto;
      }

      .preview-area {
        height: 100%;
        min-height: 240px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(11, 13, 18, 0.4);
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.06);
        padding: 10px;
        overflow: hidden;
      }
      .preview-shell {
        height: 100%;
        aspect-ratio: var(--preview-aspect, 9 / 16);
        width: auto;
        max-width: 100%;
        max-height: 100%;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .preview-shell video { width: 100%; height: 100%; object-fit: contain; }

      .preview-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 8px;
        pointer-events: none;
      }
      .overlay-btn {
        pointer-events: auto;
        width: auto;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(12, 15, 20, 0.72);
        backdrop-filter: blur(10px);
        color: var(--text);
        display: inline-flex;
        align-items: center;
        gap: 0;
      }
      .overlay-btn svg { width: 16px; height: 16px; }
      .overlay-btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .preview-wrap {
        position: relative;
        flex: 1;
        min-height: 0;
      }
      .preview-transport {
        margin-top: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        border-radius: 12px;
        background: rgba(11, 13, 18, 0.58);
        padding: 8px 10px;
      }
      .preview-transport #timelineScrub {
        margin-top: 0;
      }
      .preview-transport .timeline-controls {
        margin-top: 8px;
      }
      .preview-empty {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        color: rgba(255,255,255,0.55);
        font-weight: 700;
        letter-spacing: 0.2px;
        text-align: center;
        padding: 20px;
      }
      .preview-empty.hidden { display: none !important; }

      .health-badges { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
      .badge-pill {
        width: auto;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.55);
        font-size: 12px;
        font-weight: 800;
      }
      .badge-pill.ok { border-color: rgba(34,197,94,0.35); color: rgba(134,239,172,0.95); }
      .badge-pill.bad { border-color: rgba(248,113,113,0.35); color: rgba(253,164,175,0.95); }

      .asset-tray {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .asset-slot {
        border: 1px dashed rgba(255,255,255,0.18);
        background: rgba(15, 19, 26, 0.65);
        border-radius: 12px;
        padding: 8px;
        min-height: 96px;
        display: grid;
        gap: 6px;
        align-content: start;
      }
      .asset-title { font-size: 11px; color: var(--muted); }
      .asset-meta { font-size: 11px; color: var(--muted); }
      .asset-actions {
        display: flex;
        gap: 6px;
      }
      .asset-actions button {
        width: auto;
        padding: 6px 8px;
        font-size: 11px;
      }
      .asset-thumb {
        height: 64px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f14;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 11px;
      }
      .asset-thumb img { width: 100%; height: 100%; object-fit: cover; }
      .asset-thumb.draggable { cursor: grab; }

      .timeline-wrap {
        margin-top: 12px;
        min-height: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .timeline-ruler {
        position: relative;
        height: 26px;
        background: #0b1220;
        border-radius: 8px;
        border: 1px solid var(--border);
        overflow: hidden;
      }
      .timeline-ruler .tick {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 1px;
        background: rgba(255,255,255,0.10);
      }
      .timeline-ruler .tick.major {
        background: rgba(106,169,255,0.45);
      }
      .timeline-ruler .tick-label {
        position: absolute;
        top: 6px;
        transform: translateX(-50%);
        font-size: 10px;
        color: var(--muted);
        white-space: nowrap;
      }
      .timeline-marker {
        position: absolute;
        top: 0;
        bottom: 0;
        transform: translateX(-50%);
        pointer-events: none;
      }
      .timeline-marker-dot {
        position: absolute;
        top: 2px;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: #6aa9ff;
        box-shadow: 0 0 10px rgba(106,169,255,0.55);
      }
      .timeline-marker-label {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #cfe3ff;
        font-family: 'IBM Plex Mono', monospace;
      }
      .timeline-track {
        display: flex;
        gap: 6px;
        align-items: stretch;
        margin-top: 8px;
        overflow-x: auto;
        overflow-y: hidden;
        padding-bottom: 6px;
        min-height: 140px;
        flex: 1 1 auto;
      }
      .timeline-block {
        flex: 0 0 180px;
        min-width: 160px;
        background: #0b1220;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 7px 8px;
        display: grid;
        gap: 4px;
        position: relative;
      }
      .timeline-edit-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
        align-items: center;
      }
      .timeline-edit-input {
        width: 100%;
        padding: 5px 7px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--text);
        font-size: 11px;
        min-height: 28px;
      }
      .timeline-edit-note {
        width: 100%;
        min-height: 38px;
        max-height: 84px;
        resize: vertical;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--muted);
        font-size: 11px;
        line-height: 1.25;
        padding: 6px 7px;
        display: none;
      }
      .timeline-edit-note::placeholder,
      .timeline-edit-input::placeholder {
        color: rgba(154,164,178,0.75);
      }
      .timeline-dur-input {
        width: 58px;
        padding: 4px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(15, 20, 29, 0.9);
        color: var(--text);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 11px;
        text-align: right;
      }
      .timeline-block.dragging { opacity: 0.55; }
      .timeline-block.active {
        border-color: rgba(106,169,255,0.7);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.16) inset;
      }
      .timeline-block.active .timeline-edit-note,
      .timeline-block:hover .timeline-edit-note { display: block; }
      .timeline-handle {
        position: absolute;
        right: 3px;
        top: 3px;
        bottom: 3px;
        width: 8px;
        border-radius: 8px;
        background: rgba(106,169,255,0.20);
        cursor: ew-resize;
        opacity: 0.65;
      }
      .timeline-block:hover .timeline-handle { opacity: 1; }
      .timeline-block-header {
        font-size: 11px;
        color: var(--muted);
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .timeline-block-title {
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .timeline-badges {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }
      .timeline-badge {
        width: auto;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        font-size: 10px;
        color: var(--muted);
        background: rgba(11,13,18,0.55);
      }

      .timeline-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        flex-wrap: wrap;
        padding-bottom: 2px;
        width: 100%;
      }
      .timeline-controls .ctl {
        width: auto;
        min-width: 42px;
        padding: 8px 9px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0f141d;
        color: var(--text);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }
      .timeline-controls .ctl svg { width: 16px; height: 16px; }
      .timeline-controls .ctl-label { display: none; }
      #timeReadout {
        font-family: 'IBM Plex Mono', monospace;
        margin-left: 8px;
      }
      .install-prompt {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel);
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .install-prompt.hidden { display: none; }
      .timeline-hint {
        margin-top: 6px;
        font-size: 11px;
        color: var(--muted);
      }
      .deck-btn {
        width: auto;
        min-width: 34px;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(12, 16, 22, 0.78);
        color: var(--text);
        font-weight: 700;
      }
      .deck-inline {
        margin-top: 8px;
        display: grid;
        grid-template-columns: auto minmax(0, 1fr) auto;
        gap: 6px;
        align-items: center;
      }
      .deck-inline.hidden {
        display: none !important;
      }
      .deck-inline-track {
        min-width: 0;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 4px 2px;
        scrollbar-width: thin;
      }
      .deck-card {
        flex: 0 0 150px;
        width: 150px;
        height: 56px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.16);
        background: linear-gradient(180deg, rgba(16, 24, 35, 0.95), rgba(8, 12, 18, 0.95));
        transition: transform 160ms ease, opacity 160ms ease, box-shadow 160ms ease;
        overflow: hidden;
        cursor: pointer;
      }
      .deck-card.active {
        border-color: rgba(106,169,255,0.75);
        box-shadow: 0 0 0 2px rgba(106,169,255,0.22) inset, 0 6px 18px rgba(0,0,0,0.45);
      }
      .deck-card-line1 {
        font-size: 11px;
        color: #dbeafe;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 8px 10px 2px;
      }
      .deck-card-line2 {
        font-size: 10px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 0 10px;
      }

      .preview-busy {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(circle at center, rgba(15,20,29,0.55), rgba(11,13,18,0.85));
        border-radius: 16px;
        z-index: 8;
        pointer-events: none;
      }
      .busy-title {
        font-size: 18px;
        font-weight: 800;
        letter-spacing: 0.4px;
        background: linear-gradient(90deg, #93c5fd, #22c55e, #93c5fd);
        background-size: 220% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: shimmer 1.8s ease-in-out infinite;
      }
      .busy-sub { color: var(--muted); font-size: 12px; margin-top: 4px; max-width: 260px; text-align: center; }
      .busy-thought {
        color: #93c5fd;
        font-size: 11px;
        margin-top: 2px;
        opacity: 0.9;
        text-align: center;
        animation: thoughtPulse 1.25s ease-in-out infinite;
      }
      @keyframes shimmer {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      @keyframes thoughtPulse {
        0% { opacity: 0.5; }
        50% { opacity: 1; }
        100% { opacity: 0.5; }
      }
      .spinner {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 3px solid rgba(255,255,255,0.18);
        border-top-color: rgba(106,169,255,0.9);
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

      .terminal {
        border-top: 1px solid var(--border);
        background: #0b1119;
        padding: 10px;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
      }
      .terminal.hidden { display: none; }
      .terminal pre { white-space: pre-wrap; margin: 0; color: #86efac; }

      .chat {
        display: flex;
        flex-direction: column;
        height: 100%;
        gap: 10px;
      }
      .chat-messages {
        flex: 1;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 4px;
      }
      .chat-compose {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .mention-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .mention-bar.collapsed { display: none; }
      .mention-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .mention-toggle {
        width: auto;
        padding: 4px 8px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: rgba(12, 16, 22, 0.72);
        color: var(--muted);
        font-size: 11px;
      }
      .mention-chip {
        width: auto;
        max-width: 220px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(11, 13, 18, 0.65);
        color: var(--muted);
        font-size: 11px;
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .mention-icon {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 800;
        margin-right: 6px;
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(106,169,255,0.18);
        color: #cfe3ff;
        flex: 0 0 auto;
      }
      .mention-chip.agent .mention-icon {
        background: rgba(34,197,94,0.18);
        color: #c7f9d7;
      }
      .mention-text {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .mention-chip:hover {
        border-color: rgba(106,169,255,0.5);
        color: var(--text);
      }
      .compose-btn, .compose-send {
        width: auto;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #0f141d;
        color: var(--text);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .compose-btn svg, .compose-send svg { width: 18px; height: 18px; }
      .compose-send {
        background: var(--accent);
        color: #0b0f14;
        border: none;
      }
      .compose-send svg { stroke: #0b0f14; }
      .compose-model {
        width: auto;
        flex: 0 0 auto;
        min-width: 0;
        max-width: 220px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.65);
        font-weight: 700;
        letter-spacing: 0.2px;
        color: var(--text);
      }
      .bubble {
        max-width: 92%;
        border-radius: 16px;
        padding: 10px 12px;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(11, 18, 32, 0.55);
        backdrop-filter: blur(8px);
      }
      .bubble.user {
        align-self: flex-end;
        border-color: rgba(106,169,255,0.14);
        background: linear-gradient(180deg, rgba(106,169,255,0.16), rgba(11,18,32,0.35));
      }
      .bubble.agent {
        align-self: flex-start;
        border-color: rgba(34,197,94,0.12);
        background: linear-gradient(180deg, rgba(34,197,94,0.10), rgba(11,18,32,0.35));
      }
      .bubble-title { font-weight: 600; font-size: 12px; color: var(--muted); }
      .bubble pre {
        margin: 8px 0 0 0;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.72);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        word-break: break-word;
        max-height: 260px;
        overflow: auto;
      }
      .bubble code {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
      }
      .bubble a { color: #93c5fd; }

      /* Code editor (editable) with line numbers. */
      .code-editor {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 0;
        border-radius: 12px;
        border: 1px solid var(--border);
        overflow: hidden;
        background: rgba(11, 13, 18, 0.6);
      }
      .code-gutter {
        padding: 12px 8px;
        border-right: 1px solid rgba(255,255,255,0.08);
        color: rgba(255,255,255,0.38);
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
        text-align: right;
        user-select: none;
        background: rgba(11, 13, 18, 0.75);
      }
      .code-editor textarea {
        border: none;
        outline: none;
        border-radius: 0;
        min-height: 520px;
        padding: 12px;
        resize: none;
        background: transparent;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
        white-space: pre;
        overflow: auto;
        tab-size: 4;
      }

      /* Highlighted code view with line numbers. */
      pre.hljs {
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 0;
        overflow: auto;
        max-height: 640px;
        background: linear-gradient(180deg, rgba(6, 10, 16, 0.95), rgba(8, 12, 18, 0.92));
      }
      pre.hljs code { color: #dbeafe; }
      .hljs-keyword,
      .hljs-selector-tag,
      .hljs-meta .hljs-keyword { color: #ff7ab2; }
      .hljs-title,
      .hljs-title.function_,
      .hljs-title.class_ { color: #7dd3fc; }
      .hljs-built_in,
      .hljs-type { color: #86efac; }
      .hljs-string,
      .hljs-regexp { color: #fcd34d; }
      .hljs-number,
      .hljs-literal { color: #fca5a5; }
      .hljs-comment,
      .hljs-quote { color: #94a3b8; }
      .hljs-params,
      .hljs-variable { color: #c4b5fd; }
      .code-lines {
        counter-reset: line;
        padding: 12px 0;
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        line-height: 18px;
      }
      .code-line {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 0;
        padding: 0 12px 0 0;
      }
      .code-line::before {
        counter-increment: line;
        content: counter(line);
        padding: 0 10px 0 0;
        text-align: right;
        color: rgba(255,255,255,0.38);
        user-select: none;
      }
      .code-line > span {
        display: block;
        padding-left: 12px;
        border-left: 1px solid rgba(255,255,255,0.08);
        white-space: pre;
      }
      .code-line.highlight {
        background: rgba(106,169,255,0.08);
      }

      .agent-steps { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
      .agent-progress {
        margin-top: 6px;
        height: 5px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(11, 13, 18, 0.6);
        overflow: hidden;
      }
      .agent-progress-fill {
        height: 100%;
        width: 0%;
        transition: width 220ms ease;
        background: linear-gradient(90deg, #6aa9ff, #22c55e);
      }
      .agent-step {
        background: #0b1220;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px;
        font-size: 11px;
        text-align: center;
        cursor: pointer;
      }
      .agent-step.active { border-color: var(--accent); color: var(--accent); }
      .agent-step.done { border-color: var(--accent-2); color: var(--accent-2); }
      .agent-step.error { border-color: var(--danger); color: var(--danger); }
      .agent-step.selected {
        box-shadow: 0 0 0 2px rgba(106,169,255,0.25) inset;
      }

      @keyframes glowPulse {
        0% { box-shadow: 0 0 0 rgba(106,169,255,0.0); transform: translateY(0); }
        50% { box-shadow: 0 0 22px rgba(106,169,255,0.30); transform: translateY(-1px); }
        100% { box-shadow: 0 0 0 rgba(106,169,255,0.0); transform: translateY(0); }
      }
      @keyframes glowPulseOk {
        0% { box-shadow: 0 0 0 rgba(34,197,94,0.0); }
        50% { box-shadow: 0 0 22px rgba(34,197,94,0.25); }
        100% { box-shadow: 0 0 0 rgba(34,197,94,0.0); }
      }
      .agent-step.active { animation: glowPulse 1.2s ease-in-out infinite; }
      .agent-step.done { animation: glowPulseOk 0.8s ease-in-out 1; }
      .step-detail {
        margin-top: 8px;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        background: rgba(11, 13, 18, 0.55);
        color: var(--muted);
        font-size: 12px;
        padding: 8px 10px;
        min-height: 34px;
        white-space: pre-wrap;
      }

      .context-block summary {
        cursor: pointer;
        color: var(--muted);
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .context-tabs { display: flex; gap: 8px; margin-top: 10px; }
      .ctx-tab {
        width: auto;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(15, 19, 26, 0.55);
        color: var(--muted);
        font-weight: 700;
        font-size: 12px;
      }
      .ctx-tab.active {
        color: var(--text);
        border-color: rgba(106,169,255,0.55);
        background: rgba(106,169,255,0.12);
      }
      .context-panel { display: none; margin-top: 10px; }
      .context-panel.active { display: block; }
      .context-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }

      .drop-target { outline: 2px dashed var(--accent); }
      .context-drop {
        border-color: rgba(106,169,255,0.55) !important;
        box-shadow: 0 0 0 2px rgba(106,169,255,0.16) inset;
      }

      .hidden { display: none !important; }

      .status-pulse { animation: glowPulse 1.2s ease-in-out infinite; border-radius: 10px; padding: 6px 8px; display: inline-block; }

      button:disabled, input:disabled, select:disabled, textarea:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .toolbar .spacer { flex: 1; }
      .btn-inline { width: auto; padding: 8px 10px; }
      .icon-only {
        width: 36px;
        height: 36px;
        padding: 0;
      }
      .icon-only svg {
        width: 15px;
        height: 15px;
      }

      .editor-tabs-wrap {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }
      .editor-tabs {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        padding-bottom: 2px;
      }
      .editor-tab {
        width: auto;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.1);
        background: rgba(15, 19, 26, 0.55);
        color: var(--muted);
        font-size: 12px;
      }
      .editor-tab.active {
        border-color: rgba(106,169,255,0.55);
        background: rgba(106,169,255,0.12);
        color: var(--text);
      }
      .editor-tab-name {
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
      }
      .editor-tab-close {
        width: 20px;
        height: 20px;
        padding: 0;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(11, 13, 18, 0.6);
        color: var(--muted);
      }
      .editor-tab-close:hover {
        color: #fecaca;
        border-color: rgba(239,68,68,0.6);
      }

      /* Settings live in the middle panel (IDE style). */
      .tab-panel[data-tab="settings"] { padding: 0; }
      .settings-shell {
        flex: 1;
        min-height: 0;
        display: grid;
        grid-template-columns: 180px 1fr;
        gap: 12px;
        padding: 12px;
      }
      .settings-nav {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 8px;
        display: grid;
        gap: 6px;
        align-content: start;
        min-height: 0;
      }
      .settings-nav button {
        width: 100%;
        background: #0f141d;
        border: 1px solid rgba(255,255,255,0.08);
        color: var(--muted);
        text-align: left;
        font-weight: 700;
      }
      .settings-nav button.active {
        border-color: rgba(106,169,255,0.55);
        color: var(--text);
        background: rgba(106,169,255,0.12);
      }
      .settings-content {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--panel-2);
        padding: 12px;
        overflow: auto;
        min-height: 0;
      }
      .settings-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 12px;
        border-bottom: 1px solid rgba(255,255,255,0.06);
      }
      .settings-title { font-weight: 800; letter-spacing: 0.2px; }
      .settings-section { display: none; }
      .settings-section.active { display: block; }

      /* Code tab: fixed toolbar + scrollable editor body. */
      .tab-panel[data-tab="code"] { padding: 12px; }
      .code-body {
        flex: 1;
        min-height: 0;
        overflow: auto;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        background: rgba(11, 13, 18, 0.45);
        padding: 8px;
      }

      .drawer-section {
        border: 1px solid var(--border);
        background: rgba(15, 19, 26, 0.55);
        border-radius: 12px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .drawer-title {
        font-weight: 700;
        font-size: 12px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 8px;
      }
      .saved-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 8px;
        margin-top: 10px;
      }
      .saved-card {
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 8px;
        background: rgba(11,13,18,0.55);
      }
      .saved-card[data-kind="youtube"] {
        border-color: rgba(239, 68, 68, 0.45);
      }
      .saved-card[data-kind="web"] {
        border-color: rgba(106, 169, 255, 0.4);
      }
      .saved-card-title {
        font-weight: 700;
        font-size: 12px;
        color: var(--text);
      }
      .saved-card-body {
        margin-top: 4px;
        font-size: 12px;
        color: var(--muted);
        max-height: 48px;
        overflow: hidden;
      }

      .toast {
        position: fixed;
        bottom: 14px;
        right: 14px;
        max-width: 420px;
        background: rgba(15, 20, 29, 0.95);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        z-index: 40;
      }
      .toast.ok { border-color: rgba(34, 197, 94, 0.6); }
      .toast.err { border-color: rgba(239, 68, 68, 0.6); }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.55);
        z-index: 50;
        padding: 16px;
      }
      .modal.open { display: flex; }
      .modal-card {
        width: min(720px, 96vw);
        border-radius: 16px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(20,23,29,0.98), rgba(15,19,26,0.98));
        box-shadow: 0 30px 80px rgba(0,0,0,0.6);
        padding: 14px;
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255,255,255,0.06);
        margin-bottom: 10px;
      }
      .modal-title { font-weight: 700; letter-spacing: 0.2px; }
      .modal-body { color: var(--text); font-size: 13px; line-height: 1.45; }
      .modal-body kbd {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(255,255,255,0.12);
        border-bottom-color: rgba(255,255,255,0.18);
        border-radius: 8px;
        background: rgba(11,13,18,0.6);
      }

      @media (max-width: 1200px) {
        .layout { grid-template-columns: 1fr; grid-template-rows: auto; height: auto; }
        /* Undo column pinning on smaller viewports to avoid implicit off-screen columns. */
        #leftPanel, #splitterLeft, main.workspace, #splitterRight, #rightPanel { grid-column: 1 !important; grid-row: auto !important; }
        .splitter { display: none !important; }
        .canvas-grid { grid-template-columns: 1fr; }
        .context-grid { grid-template-columns: 1fr; }
        .settings-shell { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="window-controls">
        <span class="dot"></span>
        <span class="dot yellow"></span>
        <span class="dot green"></span>
      </div>
      <div class="topbar-title">
        NorthStar
        <span class="badge">NorthStar • Gemini Hackathon 2026</span>
      </div>
      <div class="topbar-actions">
        <button id="backBtn" class="icon-btn" title="Back" aria-label="Back" data-tip="Back">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <button id="toggleLeft" class="icon-btn" title="Explorer" aria-label="Explorer" data-tip="Explorer">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7h6l2 2h10v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><path d="M3 7V5a2 2 0 0 1 2-2h4l2 2"/></svg>
        </button>
        <button id="toggleRight" class="icon-btn" title="Chat" aria-label="Chat" data-tip="Chat">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a4 4 0 0 1-4 4H7l-4 3V7a4 4 0 0 1 4-4h10a4 4 0 0 1 4 4z"/></svg>
        </button>
        <button id="toggleTerminal" class="icon-btn" title="Terminal" aria-label="Terminal" data-tip="Terminal">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17l6-5-6-5"/><path d="M12 19h8"/></svg>
        </button>
        <button id="saveProject" class="icon-btn" title="Save" aria-label="Save" data-tip="Save">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><path d="M17 21v-8H7v8"/><path d="M7 3v5h8"/></svg>
        </button>
        <button id="openInfo" class="icon-btn" title="How It Works" aria-label="How it works" data-tip="How it works">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        </button>
        <button id="openSettings" class="icon-btn primary" title="Settings" aria-label="Settings" data-tip="Settings">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/><path d="M19.4 15a1.8 1.8 0 0 0 .36 1.98l.03.03a2.2 2.2 0 0 1-1.56 3.75 2.2 2.2 0 0 1-1.56-.65l-.03-.03a1.8 1.8 0 0 0-1.98-.36 1.8 1.8 0 0 0-1.08 1.65V22a2.2 2.2 0 0 1-4.4 0v-.04a1.8 1.8 0 0 0-1.08-1.65 1.8 1.8 0 0 0-1.98.36l-.03.03a2.2 2.2 0 0 1-3.12 0 2.2 2.2 0 0 1 0-3.12l.03-.03A1.8 1.8 0 0 0 4.6 15a1.8 1.8 0 0 0-1.65-1.08H2.9a2.2 2.2 0 0 1 0-4.4h.04A1.8 1.8 0 0 0 4.6 8.44a1.8 1.8 0 0 0-.36-1.98l-.03-.03a2.2 2.2 0 0 1 3.12-3.12l.03.03A1.8 1.8 0 0 0 9.34 3.7 1.8 1.8 0 0 0 10.42 2.05V2a2.2 2.2 0 0 1 4.4 0v.04a1.8 1.8 0 0 0 1.08 1.65 1.8 1.8 0 0 0 1.98-.36l.03-.03a2.2 2.2 0 0 1 3.12 3.12l-.03.03a1.8 1.8 0 0 0-.36 1.98 1.8 1.8 0 0 0 1.65 1.08H22a2.2 2.2 0 0 1 0 4.4h-.04A1.8 1.8 0 0 0 19.4 15z"/></svg>
        </button>
      </div>
    </div>

    <div class="layout" id="layoutRoot">
      <aside class="panel" id="leftPanel">
        <div class="panel-header">Explorer</div>
        <div class="panel-body">
          <div class="section-title">Template</div>
          <label for="templateSelect">Preset</label>
          <select id="templateSelect"></select>
          <div class="row" style="margin-top:8px;">
            <button id="resetToTemplate" class="ghost" title="Reset prompt + brief to the selected template (demo fast-path)">Reset to template</button>
            <div class="muted" style="display:flex; align-items:center;">One-click demo recovery.</div>
          </div>
          <div class="muted" id="templateOutputPath" style="margin-top:8px;">
            Output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code>
          </div>
          <label for="templateDescription" style="margin-top:8px;">Template description</label>
          <textarea id="templateDescription" disabled></textarea>

          <div class="section-title">Workspace</div>
          <div class="row small" style="margin-top:8px;">
            <input id="newPath" placeholder="notes/outline.md" />
            <button id="applyRename" class="ghost hidden" title="Apply rename" aria-label="Apply rename">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>
            </button>
            <button id="createFolder" class="ghost" title="Create folder">+ Folder</button>
            <button id="createFile" class="ghost" title="Create file">+ File</button>
          </div>
          <div class="muted" id="fileStatus" style="margin-top:6px;">Tip: type a path, then click + Folder or + File.</div>
          <div class="tree" id="workspaceTree" style="margin-top:8px;"></div>

          <div class="section-title">Job</div>
          <div class="muted" id="outputPaths" style="margin-bottom:8px;">Current output: work/jobs/&lt;job_id&gt;/out.mp4</div>
          <details id="jobArtifacts">
            <summary>Job artifacts</summary>
            <div class="muted" style="margin-top:6px;">Job ID</div>
            <div id="jobId" style="margin-bottom:8px;">—</div>
            <div class="tree" id="jobFileList"></div>
          </details>
          <details id="historyPanel" style="margin-top:10px;">
            <summary>History</summary>
            <div class="muted" style="margin-top:6px;">Last 3 actions</div>
            <div class="tree" id="historyList"></div>
          </details>
        </div>
      </aside>

      <div class="splitter" id="splitterLeft"></div>

      <main class="panel workspace">
        <div class="tabs">
          <button class="tab active" data-tab="canvas">Canvas</button>
          <button class="tab" data-tab="code">Code</button>
        </div>

        <div class="tab-panels">
          <section class="tab-panel active" data-tab="canvas">
            <div class="canvas-grid">
              <div class="card scroll controls-card">
                <details id="imageGenDetails" open>
                  <summary>Image generation</summary>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="imagePrompt">Image prompt</label>
                      <input id="imagePrompt" placeholder="Scientist walking in a park" />
                    </div>
                    <div>
                      <label for="imageMode">Image placement</label>
                      <select id="imageMode">
                        <option value="background">Background</option>
                        <option value="foreground">Foreground</option>
                        <option value="both">Both</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <button id="genImages" type="button" class="secondary" title="Generate background/foreground previews using the image model (Nano Banana)">
                      Generate images
                    </button>
                    <div class="muted" style="display:flex; align-items:center;">
                      Tip: click “Generate images” after “Create plan” (job created), then drag BG/FG into scenes.
                    </div>
                  </div>

                  <div class="asset-tray">
                    <div class="asset-slot">
                      <div class="asset-title">Background preview (drag into a scene)</div>
                      <div class="asset-thumb" id="bgThumb">No image yet</div>
                      <div class="asset-meta" id="bgAppliedInfo">Applied to: none</div>
                      <div class="asset-actions">
                        <button id="applyBgAll" class="ghost">BG -> all scenes</button>
                        <button id="clearBgAll" class="ghost">Clear BG</button>
                      </div>
                    </div>
                    <div class="asset-slot">
                      <div class="asset-title">Foreground preview (drag into a scene)</div>
                      <div class="asset-thumb" id="fgThumb">No image yet</div>
                      <div class="asset-meta" id="fgAppliedInfo">Applied to: none</div>
                      <div class="asset-actions">
                        <button id="applyFgAll" class="ghost">FG -> all scenes</button>
                        <button id="clearFgAll" class="ghost">Clear FG</button>
                      </div>
                    </div>
                  </div>
                </details>

                <div class="row" style="margin-top:8px;">
                  <div>
                    <label for="includeImages">Include images</label>
                    <select id="includeImages">
                      <option value="true">Yes</option>
                      <option value="false">No</option>
                    </select>
                  </div>
                  <div>
                    <label for="aspect">Aspect ratio</label>
                    <select id="aspect">
                      <option value="9:16">9:16</option>
                      <option value="16:9">16:9</option>
                      <option value="1:1">1:1</option>
                    </select>
                  </div>
                </div>

                <details style="margin-top:10px;">
                  <summary>Advanced creative controls</summary>
                  <div class="muted" style="margin-top:8px;">These controls are applied by default on every plan and render.</div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="audience">Audience</label>
                      <select id="audience">
                        <option value="general">General</option>
                        <option value="high school">High school</option>
                        <option value="undergrad">Undergrad</option>
                        <option value="expert">Expert</option>
                      </select>
                    </div>
                    <div>
                      <label for="tone">Tone</label>
                      <select id="tone">
                        <option value="epic">Epic</option>
                        <option value="calm">Calm</option>
                        <option value="playful">Playful</option>
                        <option value="serious">Serious</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="style">Style</label>
                      <select id="style">
                        <option value="cinematic">Cinematic</option>
                        <option value="clean">Clean</option>
                        <option value="chalkboard">Chalkboard</option>
                        <option value="neon">Neon</option>
                      </select>
                    </div>
                    <div>
                      <label for="pace">Pace</label>
                      <select id="pace">
                        <option value="medium">Medium</option>
                        <option value="slow">Slow</option>
                        <option value="fast">Fast</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="palette">Color palette</label>
                      <select id="palette">
                        <option value="cool">Cool</option>
                        <option value="warm">Warm</option>
                        <option value="neon">Neon</option>
                        <option value="monochrome">Monochrome</option>
                      </select>
                    </div>
                    <div>
                      <label for="quality">Render quality</label>
                      <select id="quality">
                        <option value="pql">Low</option>
                        <option value="pqm">Medium</option>
                        <option value="pqh">High</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="targetSeconds">Target seconds</label>
                      <input id="targetSeconds" placeholder="Leave blank" />
                      <select id="durationPreset" style="margin-top:6px;">
                        <option value="">Duration presets</option>
                        <option value="30">30s</option>
                        <option value="45">45s</option>
                        <option value="60">1 min</option>
                        <option value="90">1:30</option>
                        <option value="120">2 min</option>
                        <option value="180">3 min</option>
                      </select>
                    </div>
                    <div>
                      <label for="maxScenes">Max scenes</label>
                      <input id="maxScenes" placeholder="Leave blank" />
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="maxObjects">Max objects</label>
                      <input id="maxObjects" placeholder="Leave blank" />
                    </div>
                    <div>
                      <label for="directorBrief">Director brief</label>
                      <input id="directorBrief" placeholder="Use a strong hook" />
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="equations">Equations</label>
                      <select id="equations">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                    <div>
                      <label for="graphs">Graphs</label>
                      <select id="graphs">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                  </div>
                  <div class="row" style="margin-top:8px;">
                    <div>
                      <label for="narration">Narration</label>
                      <select id="narration">
                        <option value="true">Include</option>
                        <option value="false">Exclude</option>
                      </select>
                    </div>
                    <div>
                      <label for="imageModelOverride">Image model override</label>
                      <select id="imageModelOverride">
                        <option value="">Default</option>
                        <option value="gemini-2.5-flash-image">gemini-2.5-flash-image (Nano Banana)</option>
                        <option value="gemini-3-pro-image-preview">gemini-3-pro-image-preview</option>
                      </select>
                    </div>
                  </div>
                </details>
              </div>

              <div class="card preview-card">
                <div class="muted" style="margin-bottom:6px;">Preview</div>
                <div class="preview-wrap">
                  <div class="preview-area">
                    <div class="preview-shell" id="previewSlot"></div>
                  </div>
                  <div class="preview-empty" id="previewEmpty">Create a plan, approve it, and your rendered video will appear here.</div>
                  <div class="preview-busy hidden" id="busyOverlay" aria-hidden="true">
                    <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
                      <div style="display:flex; align-items:center; gap:10px;">
                        <div class="spinner"></div>
                        <div class="busy-title" id="busyTitle">Rendering</div>
                      </div>
                      <div class="busy-sub" id="busySub">Directing scenes…</div>
                      <div class="busy-thought" id="busyThought">Thinking about scene pacing…</div>
                    </div>
                  </div>
                  <div class="preview-overlay">
                    <button id="downloadBtn" class="overlay-btn" title="Download video" aria-label="Download video" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 21h14"/></svg>
                    </button>
                    <button id="shareBtn" class="overlay-btn" title="Share link" aria-label="Share link" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><path d="M16 6l-4-4-4 4"/><path d="M12 2v14"/></svg>
                    </button>
                    <button id="appendBtn" class="overlay-btn" title="Add next scene (+)" aria-label="Add next scene" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg>
                    </button>
                    <button id="snapshotBtn" class="overlay-btn" title="Capture PNG frame" aria-label="Capture PNG frame" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                    </button>
                    <button id="voiceoverBtn" class="overlay-btn" title="Add ElevenLabs voiceover" aria-label="Add ElevenLabs voiceover" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>
                    </button>
                    <button id="exportBtn" class="overlay-btn" title="Download project ZIP" aria-label="Download project ZIP" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M7 10l5 5 5-5"/><path d="M12 15V3"/></svg>
                    </button>
                    <button id="ccBtn" class="overlay-btn" title="Download captions (.srt)" aria-label="Download captions" disabled>
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H3v14h18V5z"/><path d="M7 10h1"/><path d="M7 14h1"/><path d="M11 10h1"/><path d="M11 14h1"/><path d="M15 10h2"/><path d="M15 14h2"/></svg>
                    </button>
                  </div>
                </div>
                <div class="preview-transport">
                  <input id="timelineScrub" type="range" min="0" max="100" value="0" />
                  <div class="timeline-controls">
                    <button id="rew10" class="ctl" title="Rewind 10s" aria-label="Rewind 10 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 19l-9-7 9-7v14z"/></svg>
                      <span class="ctl-label">10s</span>
                    </button>
                    <button id="rew5" class="ctl" title="Back 5s" aria-label="Back 5 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 5v14"/></svg>
                      <span class="ctl-label">5s</span>
                    </button>
                    <button id="playPause" class="ctl" title="Play/Pause" aria-label="Play pause">
                      <svg id="playPauseIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 5v14l11-7z"/></svg>
                      <span id="playPauseLabel" class="ctl-label">Play</span>
                    </button>
                    <button id="ff5" class="ctl" title="Forward 5s" aria-label="Forward 5 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19l9-7-9-7v14z"/><path d="M2 5v14"/></svg>
                      <span class="ctl-label">5s</span>
                    </button>
                    <button id="ff10" class="ctl" title="Forward 10s" aria-label="Forward 10 seconds">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19l9-7-9-7v14z"/><path d="M2 19l9-7-9-7v14z"/></svg>
                      <span class="ctl-label">10s</span>
                    </button>
                    <div class="muted" id="timeReadout">0:00</div>
                  </div>
                  <div id="deckCarousel" class="deck-inline hidden" aria-label="Render history">
                    <button id="deckPrev" class="deck-btn" title="Previous render">◀</button>
                    <div id="deckTrack" class="deck-inline-track"></div>
                    <button id="deckNext" class="deck-btn" title="Next render">▶</button>
                  </div>
                </div>
              </div>

              <div class="canvas-splitter" id="canvasSplitter" title="Drag to resize preview/timeline"></div>

              <div class="card timeline-card">
                <div class="timeline-wrap">
                  <div class="muted" id="timelineLabel">Timeline</div>
                  <div class="timeline-ruler" id="timelineRuler" style="margin-top:6px;"></div>
                  <div class="timeline-track" id="timelineTrack"></div>
                  <div class="timeline-hint">Tip: drag scene cards to reorder, drag right-edge to resize, and drop BG/FG assets on a scene.</div>
                </div>

                <div class="muted" style="margin-top:10px;">
                  Pro tip: type <code>/health</code>, <code>/settings</code>, <code>/attach notes/outline.md</code>, <code>/clear</code> in the prompt box.
                </div>
              </div>
            </div>
          </section>

          <section class="tab-panel" data-tab="code">
            <div class="editor-tabs-wrap">
              <div id="editorTabs" class="editor-tabs"></div>
              <button id="newCodeTab" class="ghost btn-inline" title="New file tab">+</button>
            </div>
              <div class="toolbar">
                <div class="muted" id="editorLabel">Editor</div>
                <div class="spacer"></div>
                <button id="undoCode" class="ghost btn-inline icon-only" title="Undo" aria-label="Undo">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 14L4 9l5-5"/><path d="M4 9h9a7 7 0 1 1 0 14h-1"/></svg>
                </button>
                <button id="redoCode" class="ghost btn-inline icon-only" title="Redo" aria-label="Redo">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 14l5-5-5-5"/><path d="M20 9h-9a7 7 0 1 0 0 14h1"/></svg>
                </button>
                <button id="addSelection" class="ghost btn-inline" title="Add selected text to prompt (@reference)">@</button>
                <button id="saveFile" class="ghost btn-inline" disabled>Save file</button>
                <button id="renderCode" class="secondary btn-inline">Render code</button>
              <button id="downloadVideo" class="secondary btn-inline">Download video</button>
              <button id="toggleHighlight" class="ghost btn-inline" title="Toggle syntax highlighting">Highlight</button>
            </div>
            <div class="code-body">
              <div class="code-editor" id="codeEditor">
                <div class="code-gutter" id="codeGutter">1</div>
                <textarea id="code" spellcheck="false" wrap="off"></textarea>
              </div>
              <pre id="codePrettyWrap" class="hljs hidden"><code id="codePretty" class="language-python code-lines"></code></pre>
            </div>
          </section>

          <section class="tab-panel" data-tab="settings" id="settingsPanel">
            <div class="settings-header">
              <div class="settings-title">Settings</div>
              <button id="closeSettings" class="icon-btn" title="Close settings" aria-label="Close settings" style="width:auto;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
              </button>
            </div>

            <div class="settings-shell">
              <div class="settings-nav" id="settingsNav">
                <button class="ghost active" data-stab="api">API & Models</button>
                <button class="ghost" data-stab="render">Rendering</button>
                <button class="ghost" data-stab="output">Output</button>
                <button class="ghost" data-stab="agent">Agent</button>
                <button class="ghost" data-stab="skills">Skills</button>
                <button class="ghost" data-stab="layout">Layout</button>
              </div>

              <div class="settings-content">
                <div class="settings-section active" data-stab="api">
                  <div class="drawer-section">
                    <div class="drawer-title">API & Models</div>
                    <label for="settingsApiKey">Gemini API key</label>
                    <input id="settingsApiKey" type="password" placeholder="Paste key" />
                    <button id="settingsShowKey" class="ghost" style="margin-top:6px;">Show/Hide Gemini key</button>
                    <button id="settingsShowAllKeys" class="ghost" style="margin-top:6px;">Show/Hide all keys</button>

                    <div class="row" style="margin-top:10px;">
                      <div>
                        <label for="settingsTextModel">Default text model</label>
                        <select id="settingsTextModel">
                          <option value="gemini-3-flash-preview">gemini-3-flash-preview</option>
                          <option value="gemini-3-pro-preview">gemini-3-pro-preview</option>
                          <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                          <option value="gemini-2.5-pro">gemini-2.5-pro</option>
                        </select>
                      </div>
                      <div>
                        <label for="settingsImageModel">Default image model</label>
                        <select id="settingsImageModel">
                          <option value="gemini-2.5-flash-image">gemini-2.5-flash-image (Nano Banana)</option>
                          <option value="gemini-3-pro-image-preview">gemini-3-pro-image-preview</option>
                        </select>
                      </div>
                    </div>
                    <div class="muted" style="margin-top:6px;">Nano Banana = <code>gemini-2.5-flash-image</code></div>
                    <div class="drawer-section" style="margin-top:10px;">
                      <div class="drawer-title">Voiceover (ElevenLabs)</div>
                      <div class="row">
                        <div>
                          <label for="settingsElevenApiKey">ElevenLabs API key</label>
                          <input id="settingsElevenApiKey" type="password" placeholder="Paste key" />
                        </div>
                        <div>
                          <label for="settingsElevenVoiceId">Voice ID</label>
                          <input id="settingsElevenVoiceId" placeholder="21m00Tcm4TlvDq8ikWAM" />
                        </div>
                      </div>
                      <label for="settingsElevenModelId" style="margin-top:8px;">Model ID</label>
                      <input id="settingsElevenModelId" placeholder="eleven_multilingual_v2" />
                    </div>
                    <button id="saveSettings" style="margin-top:10px;">Save</button>
                  </div>
                </div>

                <div class="settings-section" data-stab="render">
                  <div class="drawer-section">
                    <div class="drawer-title">Rendering</div>
                    <label for="settingsManimPy">Python executable for Manim</label>
                    <input id="settingsManimPy" type="text" placeholder="python3" />
                    <div class="muted" style="margin-top:6px;">
                      This is the python executable used to run <code>python -m manim</code>. Leave blank to auto-detect.
                      Outputs are saved under <code>work/jobs/&lt;job_id&gt;/out.mp4</code>.
                    </div>
                    <div class="health-badges">
                      <span id="badgeManim" class="badge-pill bad">Manim: —</span>
                      <span id="badgeFfmpeg" class="badge-pill bad">ffmpeg: —</span>
                    </div>
                    <div class="row" style="margin-top:10px;">
                      <button id="getStarted" class="secondary">Get started</button>
                      <button id="runHealth" class="secondary">Health</button>
                      <button id="openInstallGuide" class="ghost">Install guide</button>
                    </div>
                    <div id="installPrompt" class="install-prompt hidden">
                      <div class="muted">Missing: <span id="installMissingList">manim</span></div>
                      <button id="installDeps" class="secondary">Install missing</button>
                      <button id="cancelInstall" class="ghost">Cancel</button>
                    </div>
                    <pre id="health" class="muted" style="margin-top:8px; white-space:pre-wrap;">No checks yet.</pre>
                  </div>
                </div>

                <div class="settings-section" data-stab="output">
                  <div class="drawer-section">
                    <div class="drawer-title">Output Paths</div>
                    <div class="muted">Where your generated files go:</div>
                    <div style="margin-top:8px;">
                      <div class="muted">Current MP4</div>
                      <code id="settingsOutputVideoPath">work/jobs/&lt;job_id&gt;/out.mp4</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Current scene code</div>
                      <code id="settingsOutputCodePath">notes/generated/&lt;job_id&gt;/scene.py</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Workspace files</div>
                      <code>work/user_files/...</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Project root</div>
                      <code id="settingsProjectRoot">—</code>
                    </div>
                    <div style="margin-top:8px;">
                      <div class="muted">Work root</div>
                      <code id="settingsWorkRoot">—</code>
                    </div>
                    <label for="settingsOutputCopyDir" style="margin-top:10px;">Optional extra copy destination</label>
                    <input id="settingsOutputCopyDir" placeholder="~/Desktop/NorthStar-Exports" />
                    <div class="muted" style="margin-top:6px;">After render, click “Copy to output folder” to copy MP4 there.</div>
                    <button id="copyOutputNow" class="secondary" style="margin-top:8px;">Copy to output folder</button>
                  </div>
                </div>

                <div class="settings-section" data-stab="agent">
                  <div class="drawer-section">
                    <div class="drawer-title">Agent Structure</div>
                    <div class="muted">These rules/subagents are appended to your director brief.</div>
                    <label for="rulesText" style="margin-top:8px;">Rules</label>
                    <textarea id="rulesText" placeholder="Example: 1 concept per scene. Always label variables. Keep text centered."></textarea>
                    <label for="subagentsText" style="margin-top:8px;">Subagents (optional)</label>
                    <textarea id="subagentsText" placeholder="Example:\nDirector: creates storyboard\nAnimator: writes manim code\nQA: validates labels + spacing"></textarea>
                    <div class="saved-grid" id="subagentCards"></div>
                  </div>
                </div>

                <div class="settings-section" data-stab="skills">
                  <div class="drawer-section">
                    <div class="drawer-title">Skills</div>
                    <div class="muted">Create reusable instruction blocks. Select them in Chat → Context.</div>
                    <label for="skillName" style="margin-top:8px;">Skill name</label>
                    <input id="skillName" placeholder="Physics explainers" />
                    <label for="skillContent" style="margin-top:6px;">Skill instructions</label>
                    <textarea id="skillContent" placeholder="Always define variables on screen. Keep text centered."></textarea>
                    <button id="saveSkill" style="margin-top:6px;">Save skill</button>
                    <label for="skillIdea" style="margin-top:10px;">Generate skill idea</label>
                    <input id="skillIdea" placeholder="Make a concise storyboard rule" />
                    <input id="skillGenerateName" placeholder="Skill name (optional)" style="margin-top:6px;" />
                    <button id="generateSkill" class="secondary" style="margin-top:6px;">Generate skill</button>
                    <div class="saved-grid" id="savedSkillCards"></div>
                  </div>
                </div>

                <div class="settings-section" data-stab="layout">
                  <div class="drawer-section">
                    <div class="drawer-title">Layout</div>
                    <div class="muted">If panels disappear or sizes feel broken, reset the layout.</div>
                    <button id="resetLayout" class="secondary" style="margin-top:8px;">Reset layout</button>
                  </div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <div class="terminal hidden" id="terminalPanel">
          <div class="toolbar" style="margin:0 0 8px 0;">
            <div class="muted">Terminal</div>
            <div class="spacer"></div>
            <input id="termCmd" class="btn-inline" style="width: 320px;" placeholder="help | manim --version | ffmpeg -version | ls jobs" />
            <button id="termRun" class="ghost btn-inline" title="Run command">Run</button>
          </div>
          <pre id="logs">Logs will appear here.</pre>
        </div>
      </main>

      <div class="splitter" id="splitterRight"></div>

      <aside class="panel" id="rightPanel">
        <div class="panel-header">Chat & Agent</div>
        <div class="panel-body chat">
          <div class="agent-steps" id="agentSteps">
            <div class="agent-step" data-step="plan">Plan</div>
            <div class="agent-step" data-step="approve">Approve</div>
            <div class="agent-step" data-step="code">Code</div>
            <div class="agent-step" data-step="render">Render</div>
          </div>
          <div class="agent-progress" aria-hidden="true"><div id="agentProgressFill" class="agent-progress-fill"></div></div>
          <div id="stepDetail" class="step-detail">Click a step to inspect details.</div>

          <div class="chat-messages" id="chatMessages"></div>

          <details class="context-block">
            <summary>Context</summary>
            <div class="context-tabs" role="tablist" aria-label="Context tabs">
              <button class="ctx-tab active" data-ctx="memory" role="tab" aria-selected="true">Memory</button>
              <button class="ctx-tab" data-ctx="docs" role="tab" aria-selected="false">Docs</button>
              <button class="ctx-tab" data-ctx="skills" role="tab" aria-selected="false">Skills</button>
            </div>

            <div class="context-panel active" data-ctx="memory" role="tabpanel">
              <div class="muted" style="margin-bottom:6px;">Save key facts you want Gemini to remember for this run.</div>
              <div class="row">
                <div>
                  <label for="memoryTitle">Title</label>
                  <input id="memoryTitle" placeholder="Key idea" />
                </div>
                <div>
                  <label for="memoryContent">Content</label>
                  <input id="memoryContent" placeholder="Threshold frequency depends on work function" />
                </div>
              </div>
              <button id="addMemory" style="margin-top:8px;">Add memory</button>
              <div class="tree" id="memoryList" style="margin-top:8px;"></div>
            </div>

            <div class="context-panel" data-ctx="docs" role="tabpanel">
              <div class="muted" style="margin-bottom:6px;">Paste a YouTube/web link + notes. Indexing creates a short source summary you can drag into prompt or timeline.</div>
              <div class="row">
                <div>
                  <label for="sourceUrl">Link</label>
                  <input id="sourceUrl" placeholder="https://..." />
                </div>
                <div>
                  <label for="sourceNotes">Notes / transcript</label>
                  <textarea id="sourceNotes" placeholder="Paste transcript or key points here"></textarea>
                </div>
              </div>
              <div class="row" style="margin-top:8px;">
                <div>
                  <label for="sourceType">Source type</label>
                  <select id="sourceType">
                    <option value="auto">Auto detect</option>
                    <option value="youtube">YouTube link</option>
                    <option value="web">Web article/page</option>
                  </select>
                </div>
                <div style="display:flex; align-items:end; gap:8px;">
                  <button id="indexSource" class="secondary">Index source</button>
                  <button id="saveSource" class="ghost">Save source</button>
                </div>
              </div>
              <div id="sourceCards" class="saved-grid" style="margin-top:10px;"></div>
              <pre id="sourceStatus" class="muted" style="margin-top:10px; white-space:pre-wrap;">No sources yet.</pre>
            </div>

            <div class="context-panel" data-ctx="skills" role="tabpanel">
              <div class="muted" style="margin-bottom:6px;">Select skills to apply to this run (manage in Settings → Skills).</div>
              <div class="tree" id="skillList" style="margin-top:6px;"></div>
            </div>
          </details>

          <div class="muted">
            Tip: use <code>/</code> commands like <code>/health</code> and drag files into the prompt.
          </div>

          <textarea id="chatInput" placeholder="Type a prompt… (or /health, /settings, /attach notes/outline.md)"></textarea>
          <div class="chat-compose">
            <input id="filePicker" type="file" class="hidden" multiple />
            <button id="attachBtn" class="compose-btn" title="Attach file (+)" aria-label="Attach file">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
            </button>
            <select id="chatModel" class="compose-model" title="Model" aria-label="Model">
              <option value="gemini-3-flash-preview">gemini-3-flash-preview</option>
              <option value="gemini-3-pro-preview">gemini-3-pro-preview</option>
              <option value="gemini-2.5-flash">gemini-2.5-flash</option>
              <option value="gemini-2.5-pro">gemini-2.5-pro</option>
            </select>
            <button id="voiceBtn" class="compose-btn" title="Voice input" aria-label="Voice input">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>
            </button>
            <button id="planBtn" class="compose-send" title="Send / Create plan" aria-label="Send">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/></svg>
            </button>
          </div>
          <div class="mention-toolbar">
            <button id="toggleMentions" class="mention-toggle">Hide refs</button>
            <div class="muted" id="mentionInfo">Skills & agents references</div>
          </div>
          <div id="mentionBar" class="mention-bar"></div>
          <div class="muted" id="status">Ready.</div>
        </div>
      </aside>
    </div>

    <!-- settings drawer removed (settings are now in the middle panel) -->

    <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

    <div id="infoModal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">How It Works</div>
          <button id="closeInfo" class="icon-btn" style="width:auto;" title="Close" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="modal-body">
          <div style="margin-bottom:10px;">
            Fast path:
            <code>Create plan → Generate images → (optional drag into scenes) → Approve & Render</code>
          </div>
          <div class="muted" style="margin-bottom:10px;">
            Tips: use <kbd>/health</kbd> if rendering fails; drag a file from Explorer into the prompt to attach it; select code + press <kbd>@</kbd> to reference it.
          </div>
          <div style="display:grid; gap:8px;">
            <div><strong>Create plan</strong>: Gemini writes a strict JSON scene plan (timings + actions).</div>
            <div><strong>Generate images</strong>: Nano Banana generates BG/FG thumbnails you can drag into scene blocks.</div>
            <div><strong>Approve & Render</strong>: Gemini generates Manim code, then the backend renders an MP4 (with one auto-repair attempt).</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const jobFileListEl = document.getElementById('jobFileList');
      const jobIdEl = document.getElementById('jobId');
      const outputPathsEl = document.getElementById('outputPaths');
      const workspaceTreeEl = document.getElementById('workspaceTree');
      const newPathEl = document.getElementById('newPath');
      const applyRenameBtn = document.getElementById('applyRename');
      const createFolderBtn = document.getElementById('createFolder');
      const createFileBtn = document.getElementById('createFile');
      const fileStatusEl = document.getElementById('fileStatus');

      const templateSelectEl = document.getElementById('templateSelect');
      const templateDescriptionEl = document.getElementById('templateDescription');
      const resetToTemplateBtn = document.getElementById('resetToTemplate');
      const templateOutputPathEl = document.getElementById('templateOutputPath');
      const imageGenDetailsEl = document.getElementById('imageGenDetails');
      const imagePromptEl = document.getElementById('imagePrompt');
      const imageModeEl = document.getElementById('imageMode');
      const genImagesBtn = document.getElementById('genImages');
      const includeImagesEl = document.getElementById('includeImages');
      const aspectEl = document.getElementById('aspect');
      const audienceEl = document.getElementById('audience');
      const toneEl = document.getElementById('tone');
      const styleEl = document.getElementById('style');
      const paceEl = document.getElementById('pace');
      const paletteEl = document.getElementById('palette');
      const qualityEl = document.getElementById('quality');
      const targetSecondsEl = document.getElementById('targetSeconds');
      const durationPresetEl = document.getElementById('durationPreset');
      const maxScenesEl = document.getElementById('maxScenes');
      const maxObjectsEl = document.getElementById('maxObjects');
      const directorBriefEl = document.getElementById('directorBrief');
      const equationsEl = document.getElementById('equations');
      const graphsEl = document.getElementById('graphs');
      const narrationEl = document.getElementById('narration');
      const imageModelOverrideEl = document.getElementById('imageModelOverride');

      const memoryTitleEl = document.getElementById('memoryTitle');
      const memoryContentEl = document.getElementById('memoryContent');
      const addMemoryBtn = document.getElementById('addMemory');
      const memoryListEl = document.getElementById('memoryList');
      const ctxTabs = Array.from(document.querySelectorAll('.ctx-tab'));
      const ctxPanels = Array.from(document.querySelectorAll('.context-panel'));
      const skillNameEl = document.getElementById('skillName');
      const skillContentEl = document.getElementById('skillContent');
      const saveSkillBtn = document.getElementById('saveSkill');
      const skillIdeaEl = document.getElementById('skillIdea');
      const skillGenerateNameEl = document.getElementById('skillGenerateName');
      const generateSkillBtn = document.getElementById('generateSkill');
      const skillListEl = document.getElementById('skillList');
      const savedSkillCardsEl = document.getElementById('savedSkillCards');

      const bgThumbEl = document.getElementById('bgThumb');
      const fgThumbEl = document.getElementById('fgThumb');
      const bgAppliedInfoEl = document.getElementById('bgAppliedInfo');
      const fgAppliedInfoEl = document.getElementById('fgAppliedInfo');
      const applyBgAllBtn = document.getElementById('applyBgAll');
      const clearBgAllBtn = document.getElementById('clearBgAll');
      const applyFgAllBtn = document.getElementById('applyFgAll');
      const clearFgAllBtn = document.getElementById('clearFgAll');

      const previewSlot = document.getElementById('previewSlot');
      const previewEmptyEl = document.getElementById('previewEmpty');
      const downloadBtnEl = document.getElementById('downloadBtn');
      const shareBtnEl = document.getElementById('shareBtn');
      const appendBtnEl = document.getElementById('appendBtn');
      const snapshotBtnEl = document.getElementById('snapshotBtn');
      const voiceoverBtnEl = document.getElementById('voiceoverBtn');
      const exportBtnEl = document.getElementById('exportBtn');
      const ccBtnEl = document.getElementById('ccBtn');
      const deckCarouselEl = document.getElementById('deckCarousel');
      const deckTrackEl = document.getElementById('deckTrack');
      const deckPrevBtn = document.getElementById('deckPrev');
      const deckNextBtn = document.getElementById('deckNext');
      const timelineRulerEl = document.getElementById('timelineRuler');
      const timelineTrackEl = document.getElementById('timelineTrack');
      const timelineLabelEl = document.getElementById('timelineLabel');
      const timelineScrubEl = document.getElementById('timelineScrub');
      const canvasGridEl = document.querySelector('.canvas-grid');
      const canvasSplitterEl = document.getElementById('canvasSplitter');
      const controlsCardEl = document.querySelector('.controls-card');
      const rew10Btn = document.getElementById('rew10');
      const rew5Btn = document.getElementById('rew5');
      const playPauseBtn = document.getElementById('playPause');
      const playPauseIcon = document.getElementById('playPauseIcon');
      const playPauseLabel = document.getElementById('playPauseLabel');
      const ff5Btn = document.getElementById('ff5');
      const ff10Btn = document.getElementById('ff10');
      const timeReadoutEl = document.getElementById('timeReadout');
      const codeEl = document.getElementById('code');
      const codeEditorEl = document.getElementById('codeEditor');
      const codeGutterEl = document.getElementById('codeGutter');
      const editorTabsEl = document.getElementById('editorTabs');
      const newCodeTabBtn = document.getElementById('newCodeTab');
      const editorLabelEl = document.getElementById('editorLabel');
      const undoCodeBtn = document.getElementById('undoCode');
      const redoCodeBtn = document.getElementById('redoCode');
      const addSelectionBtn = document.getElementById('addSelection');
      const saveFileBtn = document.getElementById('saveFile');
      const renderCodeBtn = document.getElementById('renderCode');
      const downloadVideoBtn = document.getElementById('downloadVideo');
      const toggleHighlightBtn = document.getElementById('toggleHighlight');
      const codePrettyWrapEl = document.getElementById('codePrettyWrap');
      const codePrettyEl = document.getElementById('codePretty');
      const logsEl = document.getElementById('logs');
      const terminalPanel = document.getElementById('terminalPanel');
      const termCmdEl = document.getElementById('termCmd');
      const termRunEl = document.getElementById('termRun');
      const busyOverlayEl = document.getElementById('busyOverlay');
      const busyTitleEl = document.getElementById('busyTitle');
      const busySubEl = document.getElementById('busySub');
      const busyThoughtEl = document.getElementById('busyThought');
      const toastEl = document.getElementById('toast');
      let toastTimer = null;
      document.querySelectorAll('button:not([type])').forEach((btn) => btn.setAttribute('type', 'button'));

      function showToast(message, kind = '') {
        if (!toastEl) return;
        toastEl.textContent = String(message || '');
        toastEl.classList.remove('ok', 'err', 'hidden');
        if (kind) toastEl.classList.add(kind);
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          toastEl.classList.add('hidden');
        }, 2600);
      }

      let isBusy = false;
      let busyThoughtTimer = null;
      let busyThoughtIndex = 0;
      function busyThoughtPool(phase) {
        const key = String(phase || '').toLowerCase();
        if (key.includes('plan')) return [
          'Breaking topic into scenes…',
          'Balancing clarity and pacing…',
          'Keeping one concept per scene…'
        ];
        if (key.includes('image')) return [
          'Composing background + foreground assets…',
          'Matching visual style to the brief…',
          'Preparing draggable image assets…'
        ];
        if (key.includes('voice')) return [
          'Drafting narration timing…',
          'Aligning captions and speech…',
          'Mixing voice with video track…'
        ];
        return [
          'Generating Manim scene code…',
          'Validating scene structure…',
          'Rendering frames and stitching output…'
        ];
      }
      function setBusyThought(phase, fallbackMessage) {
        if (!busyThoughtEl) return;
        const pool = busyThoughtPool(phase);
        if (!pool.length) {
          busyThoughtEl.textContent = String(fallbackMessage || 'Working...');
          return;
        }
        busyThoughtEl.textContent = pool[busyThoughtIndex % pool.length];
        busyThoughtIndex += 1;
      }
      function startBusyThoughts(phase, fallbackMessage) {
        if (!busyThoughtEl) return;
        if (busyThoughtTimer) clearInterval(busyThoughtTimer);
        busyThoughtIndex = 0;
        setBusyThought(phase, fallbackMessage);
        busyThoughtTimer = setInterval(() => setBusyThought(phase, fallbackMessage), 1300);
      }
      function stopBusyThoughts() {
        if (busyThoughtTimer) {
          clearInterval(busyThoughtTimer);
          busyThoughtTimer = null;
        }
      }
      function setBusy(on, message, phase) {
        isBusy = !!on;
        if (busyOverlayEl) busyOverlayEl.classList.toggle('hidden', !isBusy);
        if (previewEmptyEl && isBusy) previewEmptyEl.classList.add('hidden');
        if (previewEmptyEl && !isBusy && !videoEl?.src) previewEmptyEl.classList.remove('hidden');
        if (statusEl) statusEl.classList.toggle('status-pulse', isBusy);
        if (typeof message === 'string' && statusEl) statusEl.textContent = message;
        if (typeof message === 'string' && busySubEl) busySubEl.textContent = message || 'Working…';
        if (busyTitleEl) busyTitleEl.textContent = isBusy ? (phase || 'Rendering') : 'Ready';
        if (isBusy) startBusyThoughts(phase, message);
        else stopBusyThoughts();
        if (planBtn) planBtn.disabled = isBusy;
        if (renderCodeBtn) renderCodeBtn.disabled = !!isBusy;
        if (toggleHighlightBtn) toggleHighlightBtn.disabled = isBusy;
        if (!isBusy) updateEditorMode();
      }

      window.addEventListener('error', (e) => {
        const msg = e?.error?.stack || e?.message || String(e);
        logsEl.textContent = `JS error:\n${msg}`;
      });
      window.addEventListener('unhandledrejection', (e) => {
        const msg = e?.reason?.stack || e?.reason?.message || String(e?.reason || e);
        logsEl.textContent = `Unhandled promise rejection:\n${msg}`;
      });

      const chatMessagesEl = document.getElementById('chatMessages');
      const chatInputEl = document.getElementById('chatInput');
      const chatModelEl = document.getElementById('chatModel');
      const planBtn = document.getElementById('planBtn');
      const attachBtnEl = document.getElementById('attachBtn');
      const filePickerEl = document.getElementById('filePicker');
      const voiceBtnEl = document.getElementById('voiceBtn');
      const mentionBarEl = document.getElementById('mentionBar');
      const mentionInfoEl = document.getElementById('mentionInfo');
      const toggleMentionsBtn = document.getElementById('toggleMentions');
      const statusEl = document.getElementById('status');
      const agentStepsEl = document.getElementById('agentSteps');
      const agentProgressFillEl = document.getElementById('agentProgressFill');
      const stepDetailEl = document.getElementById('stepDetail');

      const leftPanel = document.getElementById('leftPanel');
      const rightPanel = document.getElementById('rightPanel');
      const layoutRoot = document.getElementById('layoutRoot');
      const splitterLeft = document.getElementById('splitterLeft');
      const splitterRight = document.getElementById('splitterRight');
      const backBtnEl = document.getElementById('backBtn');
      const toggleLeftBtn = document.getElementById('toggleLeft');
      const toggleRightBtn = document.getElementById('toggleRight');
      const toggleTerminalBtn = document.getElementById('toggleTerminal');
      const saveProjectBtn = document.getElementById('saveProject');

      const settingsPanelEl = document.getElementById('settingsPanel');
      const closeSettingsBtn = document.getElementById('closeSettings');
      const settingsNavEl = document.getElementById('settingsNav');
      const openInstallGuideBtn = document.getElementById('openInstallGuide');
      const getStartedBtn = document.getElementById('getStarted');
      const installPromptEl = document.getElementById('installPrompt');
      const installMissingListEl = document.getElementById('installMissingList');
      const installDepsBtn = document.getElementById('installDeps');
      const cancelInstallBtn = document.getElementById('cancelInstall');
      const openSettingsBtn = document.getElementById('openSettings');
      const openInfoBtn = document.getElementById('openInfo');
      const infoModal = document.getElementById('infoModal');
      const closeInfoBtn = document.getElementById('closeInfo');
      const settingsApiKeyEl = document.getElementById('settingsApiKey');
      const settingsShowKeyBtn = document.getElementById('settingsShowKey');
      const settingsShowAllKeysBtn = document.getElementById('settingsShowAllKeys');
      const settingsTextModelEl = document.getElementById('settingsTextModel');
      const settingsImageModelEl = document.getElementById('settingsImageModel');
      const settingsManimPyEl = document.getElementById('settingsManimPy');
      const saveSettingsBtn = document.getElementById('saveSettings');
      const runHealthBtn = document.getElementById('runHealth');
      const healthEl = document.getElementById('health');
      const badgeManimEl = document.getElementById('badgeManim');
      const badgeFfmpegEl = document.getElementById('badgeFfmpeg');
      const resetLayoutBtn = document.getElementById('resetLayout');
      const settingsOutputVideoPathEl = document.getElementById('settingsOutputVideoPath');
      const settingsOutputCodePathEl = document.getElementById('settingsOutputCodePath');
      const settingsProjectRootEl = document.getElementById('settingsProjectRoot');
      const settingsWorkRootEl = document.getElementById('settingsWorkRoot');
      const settingsOutputCopyDirEl = document.getElementById('settingsOutputCopyDir');
      const copyOutputNowBtn = document.getElementById('copyOutputNow');
      const settingsElevenApiKeyEl = document.getElementById('settingsElevenApiKey');
      const settingsElevenVoiceIdEl = document.getElementById('settingsElevenVoiceId');
      const settingsElevenModelIdEl = document.getElementById('settingsElevenModelId');

      const rulesTextEl = document.getElementById('rulesText');
      const subagentsTextEl = document.getElementById('subagentsText');
      const subagentCardsEl = document.getElementById('subagentCards');

      const sourceUrlEl = document.getElementById('sourceUrl');
      const sourceNotesEl = document.getElementById('sourceNotes');
      const sourceTypeEl = document.getElementById('sourceType');
      const indexSourceBtn = document.getElementById('indexSource');
      const saveSourceBtn = document.getElementById('saveSource');
      const sourceCardsEl = document.getElementById('sourceCards');
      const sourceStatusEl = document.getElementById('sourceStatus');
      const historyListEl = document.getElementById('historyList');

      const videoEl = document.createElement('video');
      videoEl.controls = true;
      previewSlot.appendChild(videoEl);
      let lastVideoUrl = '';
      let lastCaptionsUrl = '';
      const renderDeck = [];
      let activeDeckIndex = -1;
      function setVideoAvailable(available) {
        const ok = !!available;
        if (downloadBtnEl) downloadBtnEl.disabled = !ok;
        if (shareBtnEl) shareBtnEl.disabled = !ok;
        if (appendBtnEl) appendBtnEl.disabled = !ok;
        if (snapshotBtnEl) snapshotBtnEl.disabled = !ok;
        if (voiceoverBtnEl) voiceoverBtnEl.disabled = !ok;
        if (exportBtnEl) exportBtnEl.disabled = !ok || !currentJobId;
        if (ccBtnEl) ccBtnEl.disabled = !ok || !lastCaptionsUrl;
        if (previewEmptyEl) previewEmptyEl.classList.toggle('hidden', ok);
      }

      function setActiveDeckIndex(idx) {
        if (!renderDeck.length) {
          activeDeckIndex = -1;
          renderDeckUI();
          return;
        }
        const n = renderDeck.length;
        const raw = Number(idx || 0);
        activeDeckIndex = ((raw % n) + n) % n;
        renderDeckUI();
      }

      function addRenderToDeck(entry) {
        const jobId = String(entry?.job_id || '');
        const videoPath = String(entry?.video_path || '');
        if (!jobId || !videoPath) return;
        const existing = renderDeck.findIndex((it) => it.job_id === jobId && it.video_path === videoPath);
        const payload = {
          job_id: jobId,
          video_path: videoPath,
          url: '/' + videoPath + '?t=' + Date.now(),
          appended_from: entry?.appended_from || '',
          created_at: Date.now(),
        };
        if (existing >= 0) {
          renderDeck[existing] = { ...renderDeck[existing], ...payload };
          activeDeckIndex = existing;
        } else {
          renderDeck.push(payload);
          activeDeckIndex = renderDeck.length - 1;
        }
        renderDeckUI();
      }

      function openDeckItem(item, index) {
        if (!item) return;
        activeDeckIndex = index;
        lastVideoUrl = item.url;
        videoEl.src = item.url;
        videoEl.load();
        setVideoAvailable(true);
        if (item.job_id) {
          currentJobId = item.job_id;
          jobIdEl.textContent = item.job_id;
          updateOutputPaths();
        }
        renderDeckUI();
      }

      function renderDeckUI() {
        if (!deckCarouselEl || !deckTrackEl) return;
        deckTrackEl.innerHTML = '';
        if (renderDeck.length <= 1) {
          deckCarouselEl.classList.add('hidden');
          return;
        }
        deckCarouselEl.classList.remove('hidden');
        if (activeDeckIndex < 0 || activeDeckIndex >= renderDeck.length) {
          activeDeckIndex = renderDeck.length - 1;
        }
        renderDeck.forEach((item, idx) => {
          const card = document.createElement('button');
          card.type = 'button';
          card.className = 'deck-card' + (idx === activeDeckIndex ? ' active' : '');
          card.style.opacity = idx === activeDeckIndex ? '1' : '0.72';
          const jid = item.job_id || '';
          card.innerHTML = `
            <div class="deck-card-line1">${idx + 1}. ${jid}</div>
            <div class="deck-card-line2">${item.appended_from ? 'Stitched' : 'Single segment'} • ${item.video_path.split('/').slice(-1)[0]}</div>
          `;
          card.addEventListener('click', () => openDeckItem(item, idx));
          deckTrackEl.appendChild(card);
        });
        if (deckPrevBtn) deckPrevBtn.disabled = renderDeck.length <= 1;
        if (deckNextBtn) deckNextBtn.disabled = renderDeck.length <= 1;
        const activeCard = deckTrackEl.children[activeDeckIndex];
        if (activeCard && activeCard.scrollIntoView) {
          activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      }

      function fmtTime(s) {
        const sec = Math.max(0, Math.floor(Number(s || 0)));
        const m = Math.floor(sec / 60);
        const r = sec % 60;
        return `${m}:${String(r).padStart(2, '0')}`;
      }

      function updateTransportUI() {
        if (!timeReadoutEl) return;
        const cur = videoEl.currentTime || 0;
        const dur = videoEl.duration || 0;
        timeReadoutEl.textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`;
        highlightTimelineAt(cur);
        if (!playPauseBtn) return;
        const isPaused = videoEl.paused;
        if (playPauseLabel) playPauseLabel.textContent = isPaused ? 'Play' : 'Pause';
        if (playPauseIcon) {
          playPauseIcon.innerHTML = isPaused
            ? '<path d="M8 5v14l11-7z"/>'
            : '<path d="M6 5h4v14H6z"/><path d="M14 5h4v14h-4z"/>';
        }
      }

      function nudgeVideo(dt) {
        if (!Number.isFinite(videoEl.duration)) return;
        const next = Math.max(0, Math.min(videoEl.duration || 0, (videoEl.currentTime || 0) + dt));
        videoEl.currentTime = next;
        updateTransportUI();
      }

      if (playPauseBtn) {
        playPauseBtn.addEventListener('click', async () => {
          if (!videoEl.src) return;
          try {
            if (videoEl.paused) await videoEl.play();
            else videoEl.pause();
          } catch {}
          updateTransportUI();
        });
      }
      if (rew5Btn) rew5Btn.addEventListener('click', () => nudgeVideo(-5));
      if (ff5Btn) ff5Btn.addEventListener('click', () => nudgeVideo(5));
      if (rew10Btn) rew10Btn.addEventListener('click', () => nudgeVideo(-10));
      if (ff10Btn) ff10Btn.addEventListener('click', () => nudgeVideo(10));
      videoEl.addEventListener('loadedmetadata', updateTransportUI);
      videoEl.addEventListener('play', updateTransportUI);
      videoEl.addEventListener('pause', updateTransportUI);

      downloadBtnEl.addEventListener('click', () => {
        if (!lastVideoUrl) return;
        const a = document.createElement('a');
        a.href = lastVideoUrl;
        a.download = currentJobId ? `${currentJobId}.mp4` : 'out.mp4';
        document.body.appendChild(a);
        a.click();
        a.remove();
        showToast('Downloading video…', 'ok');
        if (currentJobId) pushHistory(`Downloaded ${currentJobId}.mp4`);
      });
      if (exportBtnEl) {
        exportBtnEl.addEventListener('click', () => {
          if (!currentJobId) {
            showToast('Nothing to export yet.', 'err');
            return;
          }
          window.open(`/api/jobs/${encodeURIComponent(currentJobId)}/download`, '_blank');
        });
      }
      if (ccBtnEl) {
        ccBtnEl.addEventListener('click', () => {
          if (!lastCaptionsUrl) {
            showToast('No captions yet.', 'err');
            return;
          }
          window.open(lastCaptionsUrl, '_blank');
        });
      }
      shareBtnEl.addEventListener('click', async () => {
        if (!lastVideoUrl) return;
        try {
          if (navigator.share) {
            await navigator.share({ title: 'NorthStar', url: lastVideoUrl });
          } else if (navigator.clipboard) {
            await navigator.clipboard.writeText(lastVideoUrl);
            statusEl.textContent = 'Copied video link to clipboard.';
            showToast('Copied video link.', 'ok');
          } else {
            statusEl.textContent = 'Sharing not supported in this browser.';
            showToast('Sharing not supported in this browser.', 'err');
          }
        } catch (e) {
          statusEl.textContent = 'Share cancelled.';
          showToast('Share cancelled.', 'err');
        }
      });
      if (snapshotBtnEl) {
        snapshotBtnEl.addEventListener('click', async () => {
          if (!videoEl.src || !currentJobId) return;
          const vw = videoEl.videoWidth || 1080;
          const vh = videoEl.videoHeight || 1920;
          if (!vw || !vh) {
            showToast('Wait until video metadata is loaded, then capture.', 'err');
            return;
          }
          const canvas = document.createElement('canvas');
          canvas.width = vw;
          canvas.height = vh;
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            showToast('Could not create canvas.', 'err');
            return;
          }
          ctx.drawImage(videoEl, 0, 0, vw, vh);
          const dataUrl = canvas.toDataURL('image/png');
          const base64 = dataUrl.split(',', 2)[1] || '';
          try {
            const resp = await fetch('/api/jobs/upload-asset', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                job_id: currentJobId,
                filename: `snapshot-${Date.now()}.png`,
                content_base64: base64,
                role: 'foreground'
              })
            });
            const out = await resp.json();
            const rel = out.ok ? out.asset_path : '';
            const src = rel ? `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}` : dataUrl;
            const bubble = document.createElement('div');
            bubble.innerHTML = `<img src=\"${src}\" alt=\"Snapshot\" style=\"max-width:240px; border-radius:12px; border:1px solid rgba(255,255,255,0.12);\" />`;
            addChat('agent', 'Snapshot', 'Captured current frame.', bubble);
            const a = document.createElement('a');
            a.href = src;
            a.download = `${currentJobId}-snapshot.png`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            showToast('Snapshot captured.', 'ok');
            pushHistory(`Captured snapshot for ${currentJobId}`);
            await loadWorkspaceFiles();
          } catch {
            showToast('Snapshot upload failed.', 'err');
          }
        });
      }
      if (voiceoverBtnEl) {
        voiceoverBtnEl.addEventListener('click', async () => {
          if (!currentJobId) return;
          voiceoverBtnEl.disabled = true;
          setBusy(true, 'Adding voiceover…', 'Voiceover');
          try {
            const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/voiceover`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });
            const data = await resp.json();
            if (!data.ok) {
              showToast(data.error || 'Voiceover failed.', 'err');
              return;
            }
            if (data.video_path) {
              const src = '/' + data.video_path + '?t=' + Date.now();
              lastVideoUrl = src;
              videoEl.src = src;
              videoEl.load();
              setVideoAvailable(true);
            }
            if (data.job_files) updateJobFiles(data.job_files);
            showToast('Voiceover added.', 'ok');
            pushHistory(`Added voiceover to ${currentJobId}`);
          } catch {
            showToast('Voiceover request failed.', 'err');
          } finally {
            setBusy(false);
            if (voiceoverBtnEl) voiceoverBtnEl.disabled = false;
          }
        });
      }
      if (appendBtnEl) {
        appendBtnEl.addEventListener('click', () => {
          if (!currentJobId || !lastVideoUrl) {
            showToast('Render a video first.', 'err');
            return;
          }
          appendFromJobId = currentJobId;
          statusEl.textContent = 'Append mode: describe the next scene, then Create plan.';
          chatInputEl.focus();
          if (!targetSecondsEl.value.trim()) targetSecondsEl.value = '20';
          if (!chatInputEl.value.trim()) {
            chatInputEl.value = 'Continue with the next scene for 20 seconds: ';
          }
          showToast('Append mode enabled. Create the next scene.', 'ok');
        });
      }
      if (deckPrevBtn) {
        deckPrevBtn.addEventListener('click', () => {
          if (!renderDeck.length) return;
          setActiveDeckIndex(activeDeckIndex - 1);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        });
      }
      if (deckNextBtn) {
        deckNextBtn.addEventListener('click', () => {
          if (!renderDeck.length) return;
          setActiveDeckIndex(activeDeckIndex + 1);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        });
      }
      if (deckTrackEl) {
        deckTrackEl.addEventListener('wheel', (e) => {
          if (!renderDeck.length) return;
          e.preventDefault();
          const dir = (Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY) > 0 ? 1 : -1;
          setActiveDeckIndex(activeDeckIndex + dir);
          const item = renderDeck[activeDeckIndex];
          if (item) openDeckItem(item, activeDeckIndex);
        }, { passive: false });
      }

      let templates = [];
      let currentJobId = null;
      let appendFromJobId = null;
      let lastHealthData = null;
      let currentPlanText = null;
      let lastPlanBox = null;
      let timelineState = [];
      let timelineMeta = { title: 'Scene Plan' };
      let openFilePath = null;
      let openFileContent = '';
      let pendingRenameFrom = null;
      let pendingRenameKind = '';
      let lastAssets = { background: '', foreground: '' };
      const editorTabsState = [];
      let activeEditorTabId = 'generated';
      const historyActions = [];
      let terminalMode = false;
      const mqNarrow = window.matchMedia('(max-width: 1200px)');
      let jobEventSource = null;
      let didAnimateCode = false;
      let persistedSceneSignature = '';
      let selectedTreePath = '';
      let selectedTreeKind = '';
      let skillsCache = [];
      const renderNoticeByJob = new Set();
      let lastChatSignature = '';
      const stepNotes = {
        plan: 'No plan yet.',
        approve: 'Waiting for approval.',
        code: 'Code has not started.',
        render: 'Render has not started.',
      };

      const AUTOSAVE_KEY = 'gmma_autosave_v1';
      let autosaveTimer = null;
      let pendingRestore = null;

      function snapshotProject() {
        return {
          v: 1,
          saved_at: new Date().toISOString(),
          template_id: templateSelectEl?.value || '',
          prompt: chatInputEl?.value || '',
          chat_model: chatModelEl?.value || '',
          director_brief: directorBriefEl?.value || '',
          controls: {
            include_images: includeImagesEl?.value || 'true',
            image_prompt: imagePromptEl?.value || '',
            image_mode: imageModeEl?.value || 'background',
            aspect: aspectEl?.value || '9:16',
            audience: audienceEl?.value || 'general',
            tone: toneEl?.value || 'epic',
            style: styleEl?.value || 'cinematic',
            pace: paceEl?.value || 'medium',
            palette: paletteEl?.value || 'cool',
            quality: qualityEl?.value || 'pqm',
            target_seconds: targetSecondsEl?.value || '',
            max_scenes: maxScenesEl?.value || '',
            max_objects: maxObjectsEl?.value || '',
            equations: equationsEl?.value || 'true',
            graphs: graphsEl?.value || 'true',
            narration: narrationEl?.value || 'true',
            image_model_override: imageModelOverrideEl?.value || '',
          },
          plan_text: currentPlanText || '',
          timeline: Array.isArray(timelineState) ? timelineState : [],
          code: codeEl?.value || '',
        };
      }

      function saveProject(auto = false) {
        try {
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(snapshotProject()));
          if (!auto) showToast('Saved.', 'ok');
        } catch {
          if (!auto) showToast('Save failed (storage blocked).', 'err');
        }
      }

      function scheduleAutosave() {
        clearTimeout(autosaveTimer);
        autosaveTimer = setTimeout(() => saveProject(true), 500);
      }

      function restoreProject() {
        let raw = '';
        try { raw = localStorage.getItem(AUTOSAVE_KEY) || ''; } catch { raw = ''; }
        if (!raw) return false;
        let snap = null;
        try { snap = JSON.parse(raw); } catch { snap = null; }
        if (!snap || snap.v !== 1) return false;

        pendingRestore = snap;
        // Apply what we can immediately (templates load async).
        if (snap.prompt && chatInputEl) chatInputEl.value = snap.prompt;
        if (snap.chat_model && chatModelEl) chatModelEl.value = snap.chat_model;
        if (snap.director_brief && directorBriefEl) directorBriefEl.value = snap.director_brief;
        const c = snap.controls || {};
        if (includeImagesEl && c.include_images) includeImagesEl.value = c.include_images;
        if (imagePromptEl && c.image_prompt) imagePromptEl.value = c.image_prompt;
        if (imageModeEl && c.image_mode) imageModeEl.value = c.image_mode;
        if (aspectEl && c.aspect) { aspectEl.value = c.aspect; setPreviewAspect(c.aspect); }
        if (audienceEl && c.audience) audienceEl.value = c.audience;
        if (toneEl && c.tone) toneEl.value = c.tone;
        if (styleEl && c.style) styleEl.value = c.style;
        if (paceEl && c.pace) paceEl.value = c.pace;
        if (paletteEl && c.palette) paletteEl.value = c.palette;
        if (qualityEl && c.quality) qualityEl.value = c.quality;
        if (targetSecondsEl && c.target_seconds !== undefined) targetSecondsEl.value = c.target_seconds;
        if (maxScenesEl && c.max_scenes !== undefined) maxScenesEl.value = c.max_scenes;
        if (maxObjectsEl && c.max_objects !== undefined) maxObjectsEl.value = c.max_objects;
        if (equationsEl && c.equations) equationsEl.value = c.equations;
        if (graphsEl && c.graphs) graphsEl.value = c.graphs;
        if (narrationEl && c.narration) narrationEl.value = c.narration;
        if (imageModelOverrideEl) imageModelOverrideEl.value = c.image_model_override || '';

        if (snap.plan_text) currentPlanText = snap.plan_text;
        if (Array.isArray(snap.timeline)) { timelineState = snap.timeline; renderTimeline(); }
        if (typeof snap.code === 'string') { codeEl.value = snap.code; refreshGutter(); if (highlightOn) refreshHighlight(); }
        return true;
      }

      function pushHistory(action) {
        const txt = String(action || '').trim();
        if (!txt) return;
        const stamp = new Date();
        const hh = String(stamp.getHours()).padStart(2, '0');
        const mm = String(stamp.getMinutes()).padStart(2, '0');
        historyActions.unshift(`${hh}:${mm}  ${txt}`);
        if (historyActions.length > 3) historyActions.length = 3;
        renderHistory();
      }

      function renderHistory() {
        if (!historyListEl) return;
        if (!historyActions.length) {
          historyListEl.innerHTML = '<div class="muted">No actions yet.</div>';
          return;
        }
        historyListEl.innerHTML = '';
        historyActions.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'tree-file';
          row.textContent = item;
          historyListEl.appendChild(row);
        });
      }

      function fileBaseName(path) {
        const p = String(path || '');
        const bits = p.split('/');
        return bits[bits.length - 1] || p || 'untitled.py';
      }

      function ensureGeneratedTab() {
        if (editorTabsState.some((t) => t.id === 'generated')) return;
        editorTabsState.push({
          id: 'generated',
          path: null,
          label: 'generated.py',
          content: codeEl.value || '',
          generated: true,
        });
      }

      function getActiveEditorTab() {
        return editorTabsState.find((t) => t.id === activeEditorTabId) || null;
      }

      function syncCurrentEditorIntoActiveTab() {
        const tab = getActiveEditorTab();
        if (!tab) return;
        tab.content = codeEl.value || '';
      }

      function applyActiveEditorTab() {
        const tab = getActiveEditorTab();
        if (!tab) return;
        codeEl.value = tab.content || '';
        refreshGutter();
        if (highlightOn) refreshHighlight();
        openFilePath = tab.path || null;
        openFileContent = codeEl.value || '';
        updateEditorMode();
      }

      function renderEditorTabs() {
        if (!editorTabsEl) return;
        ensureGeneratedTab();
        editorTabsEl.innerHTML = '';
        editorTabsState.forEach((tab) => {
          const el = document.createElement('div');
          el.className = `editor-tab ${tab.id === activeEditorTabId ? 'active' : ''}`;
          el.dataset.id = tab.id;

          const name = document.createElement('div');
          name.className = 'editor-tab-name';
          name.textContent = tab.label || 'untitled.py';
          name.title = tab.path || tab.label || '';
          name.addEventListener('click', () => {
            syncCurrentEditorIntoActiveTab();
            activeEditorTabId = tab.id;
            applyActiveEditorTab();
            renderEditorTabs();
          });
          el.appendChild(name);

          if (!tab.generated) {
            const close = document.createElement('button');
            close.className = 'editor-tab-close';
            close.title = 'Close tab';
            close.setAttribute('aria-label', `Close ${tab.label}`);
            close.textContent = '×';
            close.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = editorTabsState.findIndex((x) => x.id === tab.id);
              if (idx >= 0) editorTabsState.splice(idx, 1);
              if (activeEditorTabId === tab.id) {
                activeEditorTabId = (editorTabsState[idx - 1] || editorTabsState[idx] || editorTabsState[0] || { id: 'generated' }).id;
              }
              ensureGeneratedTab();
              applyActiveEditorTab();
              renderEditorTabs();
            });
            el.appendChild(close);
          }

          editorTabsEl.appendChild(el);
        });
      }

      function upsertFileTab(path, content, activate = true) {
        const p = String(path || '');
        if (!p) return;
        let tab = editorTabsState.find((t) => t.path === p);
        if (!tab) {
          tab = {
            id: `file:${p}`,
            path: p,
            label: fileBaseName(p),
            content: String(content || ''),
            generated: false,
          };
          editorTabsState.push(tab);
        } else if (typeof content === 'string') {
          tab.content = content;
        }
        if (activate) {
          activeEditorTabId = tab.id;
          applyActiveEditorTab();
        }
        renderEditorTabs();
      }

      function upsertGeneratedTab(content) {
        ensureGeneratedTab();
        const tab = editorTabsState.find((t) => t.id === 'generated');
        if (!tab) return;
        tab.content = String(content || '');
        tab.label = 'generated.py';
        if (activeEditorTabId === 'generated') applyActiveEditorTab();
        renderEditorTabs();
      }

      async function createNewCodeTabFile() {
        let i = 1;
        while (i < 500) {
          const name = `notes/new_scene_${i}.py`;
          try {
            const resp = await fetch('/api/files/file', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: name, content: '' })
            });
            const data = await resp.json();
            if (data.ok && data.path) {
              await loadWorkspaceFiles();
              await openWorkspaceFile(data.path);
              startRename(data.path, 'file');
              pushHistory(`Created ${data.path}`);
              return;
            }
          } catch {}
          i += 1;
        }
        showToast('Could not create a new code file.', 'err');
      }

      function getSources() {
        try {
          const raw = JSON.parse(localStorage.getItem('sources') || '[]');
          const clean = Array.isArray(raw) ? raw.map(normalizeSourceRecord) : [];
          if (Array.isArray(raw) && raw.some((x) => !x?.id || !x?.kind || !x?.saved_at)) {
            localStorage.setItem('sources', JSON.stringify(clean));
          }
          return clean;
        } catch {
          return [];
        }
      }
      function setSources(sources) {
        const clean = (Array.isArray(sources) ? sources : []).map(normalizeSourceRecord);
        localStorage.setItem('sources', JSON.stringify(clean));
      }

      function normalizeSourceRecord(src) {
        const s = src || {};
        const kind = String(s.kind || s.source_type || (s.video_id ? 'youtube' : 'web')).toLowerCase();
        const id = String(s.id || `src-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`);
        const title = cleanInline(s.title || '') || compactLabel(s.url || 'Source', 56);
        const summary = cleanInline(s.summary || s.notes || '');
        const promptHint = cleanInline(s.prompt_hint || s.promptHint || '');
        const notes = String(s.notes || '').trim();
        const keyPoints = Array.isArray(s.key_points)
          ? s.key_points.map((x) => cleanInline(x)).filter(Boolean).slice(0, 12)
          : [];
        const filePath = String(s.file_path || '').trim();
        return {
          ...s,
          id,
          kind: kind === 'youtube' ? 'youtube' : 'web',
          title,
          summary,
          prompt_hint: promptHint,
          notes,
          key_points: keyPoints,
          file_path: filePath,
          saved_at: s.saved_at || new Date().toISOString(),
        };
      }

      function upsertSource(source) {
        const normalized = normalizeSourceRecord(source);
        const next = [normalized];
        getSources().forEach((item) => {
          if (item.id === normalized.id) return;
          if (normalized.url && item.url && normalized.url === item.url) return;
          next.push(item);
        });
        setSources(next.slice(0, 30));
      }

      function sourceSnippet(src) {
        const s = normalizeSourceRecord(src);
        const parts = [];
        parts.push(`[Indexed source: ${s.kind}] ${s.title || s.url || 'source'}`);
        if (s.video_id) parts.push(`YouTube ID: ${s.video_id}`);
        if (s.file_path) parts.push(`Workspace file: ${s.file_path}`);
        if (s.url) parts.push(`URL: ${s.url}`);
        if (s.summary) parts.push(`Summary: ${s.summary}`);
        const points = Array.isArray(s.key_points) ? s.key_points.filter(Boolean).slice(0, 6) : [];
        if (points.length) {
          parts.push('Key points:');
          points.forEach((p) => parts.push(`- ${p}`));
        }
        if (s.prompt_hint) parts.push(`Prompt hint: ${s.prompt_hint}`);
        if (s.notes) parts.push(`Notes: ${s.notes.slice(0, 400)}`);
        return parts.join('\n');
      }

      function sourceTimelineNote(src) {
        const s = normalizeSourceRecord(src);
        const points = Array.isArray(s.key_points) ? s.key_points.slice(0, 3) : [];
        const lines = [`[Source] ${s.title || s.url || 'reference'}`];
        if (s.summary) lines.push(s.summary);
        if (points.length) {
          lines.push('Key points:');
          points.forEach((p) => lines.push(`- ${p}`));
        }
        if (s.prompt_hint) lines.push(`Prompt hint: ${s.prompt_hint}`);
        return lines.join('\n').slice(0, 1200);
      }

      async function persistSourceSummaryFile(indexed) {
        if (!indexed || !indexed.markdown) return '';
        let path = indexed.file_suggested_path || `notes/sources/source-${Date.now()}.md`;
        let saved = await tryWriteWorkspaceFile(path, indexed.markdown);
        if (!saved) {
          for (let i = 2; i < 20 && !saved; i++) {
            const cand = path.replace(/(\.[^.]*)?$/, `-${i}$1`);
            saved = await tryWriteWorkspaceFile(cand, indexed.markdown);
          }
        }
        if (saved) await loadWorkspaceFiles();
        return saved || '';
      }

      function renderSources() {
        const sources = getSources();
        if (!sources.length) {
          sourceStatusEl.textContent = 'No sources yet.';
          if (sourceCardsEl) sourceCardsEl.innerHTML = '';
          return;
        }
        sourceStatusEl.textContent = `${sources.length} source(s) ready. Drag into prompt, timeline, or context.`;
        if (!sourceCardsEl) return;
        sourceCardsEl.innerHTML = '';
        sources.forEach((raw, idx) => {
          const s = normalizeSourceRecord(raw);
          const card = document.createElement('div');
          card.className = 'saved-card';
          card.dataset.kind = s.kind || 'web';
          const kind = s.kind === 'youtube' ? 'YouTube' : 'Web';
          const title = compactLabel(s.title || s.url || `Source ${idx + 1}`, 64);
          const body = compactLabel(s.summary || s.notes || '', 220);
          card.innerHTML = `<div class="saved-card-title">${kind} • ${title}</div><div class="saved-card-body">${body || 'No summary yet.'}</div>`;
          card.title = 'Drag into prompt/timeline/context';
          card.draggable = true;
          card.addEventListener('dragstart', (e) => {
            const snippet = sourceSnippet(s);
            const sceneNote = sourceTimelineNote(s);
            e.dataTransfer.setData('text/plain', snippet);
            e.dataTransfer.setData('text/source-snippet', snippet);
            e.dataTransfer.setData('text/source-timeline', sceneNote);
            e.dataTransfer.setData('text/source-id', s.id);
            if (s.file_path) e.dataTransfer.setData('text/source-file', s.file_path);
            e.dataTransfer.effectAllowed = 'copy';
          });

          const actions = document.createElement('div');
          actions.className = 'row small';
          actions.style.marginTop = '6px';
          const useBtn = document.createElement('button');
          useBtn.className = 'ghost';
          useBtn.textContent = 'Use in prompt';
          useBtn.addEventListener('click', () => {
            const cur = chatInputEl.value || '';
            const sep = cur && !/\s$/.test(cur) ? '\n\n' : '';
            chatInputEl.value = `${cur}${sep}${sourceSnippet(s)}\n`;
            chatInputEl.focus();
            showToast('Indexed context inserted into prompt.', 'ok');
          });
          const delBtn = document.createElement('button');
          delBtn.className = 'ghost';
          delBtn.textContent = 'Remove';
          delBtn.addEventListener('click', () => {
            const next = getSources().filter((x) => x.id !== s.id);
            setSources(next);
            renderSources();
            scheduleAutosave();
          });
          actions.appendChild(useBtn);
          actions.appendChild(delBtn);
          card.appendChild(actions);
          sourceCardsEl.appendChild(card);
        });
      }

      function clampNumber(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function getLayoutSizes() {
        let stored = {};
        try {
          stored = JSON.parse(localStorage.getItem('layoutSizes') || '{}');
        } catch {
          stored = {};
        }
        const leftNum = Number(stored.left);
        const rightNum = Number(stored.right);
        return {
          left: Number.isFinite(leftNum) ? clampNumber(leftNum, 260, 600) : 340,
          right: Number.isFinite(rightNum) ? clampNumber(rightNum, 320, 680) : 420,
        };
      }

      function saveLayoutSizes(left, right) {
        localStorage.setItem('layoutSizes', JSON.stringify({ left, right }));
      }

      function getCanvasTopSplit() {
        try {
          const raw = localStorage.getItem('canvasTopSplit');
          const n = Number(raw);
          if (Number.isFinite(n)) return clampNumber(n, 42, 86);
        } catch {}
        return 72;
      }

      function saveCanvasTopSplit(pct) {
        try {
          localStorage.setItem('canvasTopSplit', String(clampNumber(pct, 42, 86)));
        } catch {}
      }

      function applyCanvasTopSplit(pct) {
        if (!canvasGridEl) return;
        const top = clampNumber(pct, 42, 86);
        // Keep timeline compact as preview grows.
        const timeline = clampNumber(Math.round((100 - top) * 0.42), 10, 24);
        canvasGridEl.style.setProperty('--canvas-top', `${top}%`);
        canvasGridEl.style.setProperty('--canvas-timeline', `${timeline}%`);
      }

      function updateBackEnabled() {
        if (!backBtnEl) return;
        const hasJob = !!currentJobId;
        const hasChat = (chatMessagesEl && chatMessagesEl.children && chatMessagesEl.children.length > 0);
        const hasVideo = !!videoEl?.src;
        const hasOpenFile = !!openFilePath;
        const hasLogs = (logsEl?.textContent || '').trim() && logsEl.textContent.trim() !== 'Cleared.';
        backBtnEl.disabled = !(hasJob || hasChat || hasVideo || hasOpenFile || hasLogs);
      }

      function updateTopbarToggles() {
        if (toggleLeftBtn) toggleLeftBtn.classList.toggle('toggled', !leftPanel.classList.contains('hidden'));
        if (toggleRightBtn) toggleRightBtn.classList.toggle('toggled', !rightPanel.classList.contains('hidden'));
        if (toggleTerminalBtn) toggleTerminalBtn.classList.toggle('toggled', !!terminalMode);
        updateBackEnabled();
      }

      function applyLayoutColumns() {
        if (mqNarrow.matches) {
          // Let the CSS media query control the stack layout (no inline override).
          layoutRoot.style.removeProperty('grid-template-columns');
          splitterLeft.classList.add('hidden');
          splitterRight.classList.add('hidden');
          updateTopbarToggles();
          return;
        }
        const leftVisible = !leftPanel.classList.contains('hidden');
        const rightVisible = !rightPanel.classList.contains('hidden');
        const sizes = getLayoutSizes();
        const leftW = leftVisible ? sizes.left : 0;
        const rightW = rightVisible ? sizes.right : 0;
        const splitL = leftVisible ? 6 : 0;
        const splitR = rightVisible ? 6 : 0;
        splitterLeft.classList.toggle('hidden', !leftVisible);
        splitterRight.classList.toggle('hidden', !rightVisible);
        layoutRoot.style.gridTemplateColumns = `${leftW}px ${splitL}px 1fr ${splitR}px ${rightW}px`;
        updateTopbarToggles();
      }

      function resetLayout() {
        try { localStorage.removeItem('layoutSizes'); } catch {}
        leftPanel.classList.remove('hidden');
        rightPanel.classList.remove('hidden');
        applyLayoutColumns();
        showToast('Layout reset.', 'ok');
      }

      document.getElementById('toggleLeft').addEventListener('click', () => {
        leftPanel.classList.toggle('hidden');
        applyLayoutColumns();
      });
      document.getElementById('toggleRight').addEventListener('click', () => {
        rightPanel.classList.toggle('hidden');
        applyLayoutColumns();
      });
      function setTerminalMode(on) {
        terminalMode = !!on;
        if (!controlsCardEl || !terminalPanel) return;
        if (terminalPanel.parentElement !== controlsCardEl) {
          controlsCardEl.appendChild(terminalPanel);
        }
        Array.from(controlsCardEl.children).forEach((child) => {
          if (child === terminalPanel) return;
          child.classList.toggle('hidden', terminalMode);
        });
        terminalPanel.classList.toggle('hidden', !terminalMode);
        updateTopbarToggles();
        if (terminalMode) {
          setTimeout(() => termCmdEl?.focus(), 0);
        }
      }

      document.getElementById('toggleTerminal').addEventListener('click', () => {
        setTerminalMode(!terminalMode);
      });

      document.getElementById('backBtn').addEventListener('click', () => {
        resetSteps();
        currentJobId = null;
        appendFromJobId = null;
        persistedSceneSignature = '';
        renderNoticeByJob.clear();
        try { if (jobEventSource) jobEventSource.close(); } catch {}
        jobEventSource = null;
        jobIdEl.textContent = '—';
        jobFileListEl.innerHTML = '';
        updateOutputPaths();
        codeEl.value = '';
        refreshGutter();
        upsertGeneratedTab('');
        editorTabsState.splice(0, editorTabsState.length, {
          id: 'generated',
          path: null,
          label: 'generated.py',
          content: '',
          generated: true,
        });
        activeEditorTabId = 'generated';
        renderEditorTabs();
        openFilePath = null;
        openFileContent = '';
        pendingRenameFrom = null;
        pendingRenameKind = '';
        setSelectedTreePath('', '');
        updateEditorMode();
        logsEl.textContent = 'Cleared.';
        statusEl.textContent = 'Ready.';
        chatMessagesEl.innerHTML = '';
        lastChatSignature = '';
        videoEl.removeAttribute('src');
        videoEl.load();
        lastVideoUrl = '';
        lastCaptionsUrl = '';
        setVideoAvailable(false);
        timelineTrackEl.innerHTML = '';
        timelineState = [];
        if (timelineRulerEl) timelineRulerEl.innerHTML = '';
        if (timelineLabelEl) timelineLabelEl.textContent = 'Timeline';
        if (stepDetailEl) stepDetailEl.textContent = 'Click a step to inspect details.';
        renderDeckUI();
        setTerminalMode(false);
        updateBackEnabled();
      });

      function openSettingsTab(stab) {
        setActiveTab('settings');
        if (stab) setSettingsSubtab(stab);
      }
      openSettingsBtn.addEventListener('click', () => openSettingsTab('api'));
      if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => setActiveTab('canvas'));

      function setSettingsSubtab(id) {
        if (!settingsNavEl) return;
        const btns = Array.from(settingsNavEl.querySelectorAll('button[data-stab]'));
        btns.forEach(b => b.classList.toggle('active', b.dataset.stab === id));
        const secs = Array.from(document.querySelectorAll('.settings-section[data-stab]'));
        secs.forEach(s => s.classList.toggle('active', s.dataset.stab === id));
      }
      if (settingsNavEl) {
        settingsNavEl.addEventListener('click', (e) => {
          const t = e.target.closest('button[data-stab]');
          if (!t) return;
          setSettingsSubtab(t.dataset.stab);
        });
      }

      function openInfo() {
        if (!infoModal) return;
        infoModal.classList.add('open');
        infoModal.setAttribute('aria-hidden', 'false');
      }
      function closeInfo() {
        if (!infoModal) return;
        infoModal.classList.remove('open');
        infoModal.setAttribute('aria-hidden', 'true');
      }
      if (openInfoBtn) openInfoBtn.addEventListener('click', openInfo);
      if (closeInfoBtn) closeInfoBtn.addEventListener('click', closeInfo);
      if (infoModal) {
        infoModal.addEventListener('click', (e) => {
          if (e.target === infoModal) closeInfo();
        });
      }
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          // Close the most "modal" thing first.
          if (infoModal && infoModal.classList.contains('open')) {
            closeInfo();
            return;
          }
          // Settings is a full-page in the middle pane; treat Escape as "close".
          const settingsIsActive = document.querySelector('.tab-panel[data-tab="settings"]')?.classList.contains('active');
          if (settingsIsActive) {
            setActiveTab('canvas');
            return;
          }
        }
      });

      safeOn(settingsShowKeyBtn, 'click', () => {
        const isHidden = settingsApiKeyEl.type === 'password';
        settingsApiKeyEl.type = isHidden ? 'text' : 'password';
      });
      safeOn(settingsShowAllKeysBtn, 'click', () => {
        const reveal = settingsApiKeyEl.type === 'password' || settingsElevenApiKeyEl.type === 'password';
        settingsApiKeyEl.type = reveal ? 'text' : 'password';
        settingsElevenApiKeyEl.type = reveal ? 'text' : 'password';
      });
      let mentionsCollapsed = false;
      function updateMentionVisibility() {
        if (!mentionBarEl) return;
        mentionBarEl.classList.toggle('collapsed', mentionsCollapsed);
        if (toggleMentionsBtn) toggleMentionsBtn.textContent = mentionsCollapsed ? 'Show refs' : 'Hide refs';
        if (mentionInfoEl) {
          if (mentionsCollapsed) mentionInfoEl.textContent = 'References hidden';
          else mentionInfoEl.textContent = mentionInfoEl.dataset.summary || 'Skills & agents references';
        }
      }
      safeOn(toggleMentionsBtn, 'click', () => {
        mentionsCollapsed = !mentionsCollapsed;
        updateMentionVisibility();
      });

      const tabs = Array.from(document.querySelectorAll('.tab'));
      const panels = Array.from(document.querySelectorAll('.tab-panel'));
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const target = tab.dataset.tab;
          panels.forEach(p => p.classList.toggle('active', p.dataset.tab === target));
        });
      });

      function initSplitter(splitter, side) {
        let startX = 0;
        let startLeft = 0;
        let startRight = 0;

        splitter.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startX = e.clientX;
          const sizes = getLayoutSizes();
          startLeft = Number(sizes.left) || 280;
          startRight = Number(sizes.right) || 360;
          const prevUserSelect = document.body.style.userSelect;
          const prevCursor = document.body.style.cursor;
          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'col-resize';

          function onMove(ev) {
            const dx = ev.clientX - startX;
            if (side === 'left') {
              const next = Math.max(220, Math.min(520, startLeft + dx));
              saveLayoutSizes(next, startRight);
            } else {
              const next = Math.max(260, Math.min(560, startRight - dx));
              saveLayoutSizes(startLeft, next);
            }
            applyLayoutColumns();
          }

          function onUp() {
            window.removeEventListener('mousemove', onMove);
            window.removeEventListener('mouseup', onUp);
            document.body.style.userSelect = prevUserSelect;
            document.body.style.cursor = prevCursor;
          }

          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
        });
      }
      initSplitter(splitterLeft, 'left');
      initSplitter(splitterRight, 'right');

      function initCanvasSplitter() {
        if (!canvasSplitterEl || !canvasGridEl) return;
        applyCanvasTopSplit(getCanvasTopSplit());
        let dragging = false;
        let startY = 0;
        let startTopPct = getCanvasTopSplit();
        let rect = canvasGridEl.getBoundingClientRect();
        let prevUserSelect = '';
        let prevCursor = '';

        function onMove(ev) {
          if (!dragging) return;
          const dy = ev.clientY - startY;
          const deltaPct = (dy / Math.max(1, rect.height)) * 100;
          const next = clampNumber(startTopPct + deltaPct, 42, 86);
          applyCanvasTopSplit(next);
        }
        function onUp() {
          if (!dragging) return;
          dragging = false;
          const topNow = parseFloat((canvasGridEl.style.getPropertyValue('--canvas-top') || '').replace('%', '')) || startTopPct;
          saveCanvasTopSplit(topNow);
          document.body.style.userSelect = prevUserSelect;
          document.body.style.cursor = prevCursor;
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
        }
        function onDown(e) {
          e.preventDefault();
          dragging = true;
          startY = e.clientY;
          rect = canvasGridEl.getBoundingClientRect();
          const curTop = parseFloat((canvasGridEl.style.getPropertyValue('--canvas-top') || '').replace('%', ''));
          startTopPct = Number.isFinite(curTop) ? curTop : getCanvasTopSplit();
          prevUserSelect = document.body.style.userSelect;
          prevCursor = document.body.style.cursor;
          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'row-resize';
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', onUp);
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
        }

        canvasSplitterEl.addEventListener('pointerdown', onDown);
      }
      initCanvasSplitter();
      // Keep layout sane across resizes and avoid "panels disappeared" glitches.
      try {
        mqNarrow.addEventListener('change', applyLayoutColumns);
      } catch {
        try { mqNarrow.addListener(applyLayoutColumns); } catch {}
      }
      window.addEventListener('resize', applyLayoutColumns);

      function setPreviewAspect(ratio) {
        let val = '9 / 16';
        if (ratio === '16:9') val = '16 / 9';
        if (ratio === '1:1') val = '1 / 1';
        previewSlot.style.setProperty('--preview-aspect', val);
      }

      function setStep(step, state) {
        const el = agentStepsEl.querySelector(`[data-step="${step}"]`);
        if (!el) return;
        el.classList.remove('active','done','error');
        if (state) el.classList.add(state);
        updateStepProgress();
      }
      function setStepNote(step, message) {
        if (!step || !message) return;
        stepNotes[step] = String(message);
        const active = agentStepsEl.querySelector('.agent-step.active');
        if (!active && stepDetailEl) {
          stepDetailEl.textContent = stepNotes[step] || '';
          return;
        }
        if (active && active.dataset.step === step && stepDetailEl) {
          stepDetailEl.textContent = stepNotes[step] || '';
        }
      }
      function showStepDetail(step) {
        if (!stepDetailEl) return;
        stepDetailEl.textContent = stepNotes[step] || 'No details yet.';
      }
      function resetSteps() {
        ['plan','approve','code','render'].forEach(s => setStep(s, ''));
        stepNotes.plan = 'No plan yet.';
        stepNotes.approve = 'Waiting for approval.';
        stepNotes.code = 'Code has not started.';
        stepNotes.render = 'Render has not started.';
        Array.from(agentStepsEl.querySelectorAll('.agent-step')).forEach((el) => el.classList.remove('selected'));
        const planEl = agentStepsEl.querySelector('[data-step="plan"]');
        if (planEl) planEl.classList.add('selected');
        showStepDetail('plan');
        updateStepProgress();
      }

      function updateStepProgress() {
        if (!agentProgressFillEl || !agentStepsEl) return;
        const stepEls = ['plan', 'approve', 'code', 'render'].map((s) => agentStepsEl.querySelector(`[data-step="${s}"]`));
        let pct = 0;
        if (stepEls[0]?.classList.contains('done')) pct = 25;
        else if (stepEls[0]?.classList.contains('active')) pct = 12;
        if (stepEls[1]?.classList.contains('done')) pct = 50;
        else if (stepEls[1]?.classList.contains('active')) pct = Math.max(pct, 38);
        if (stepEls[2]?.classList.contains('done')) pct = 75;
        else if (stepEls[2]?.classList.contains('active')) pct = Math.max(pct, 62);
        if (stepEls[3]?.classList.contains('done')) pct = 100;
        else if (stepEls[3]?.classList.contains('active')) pct = Math.max(pct, 88);

        const hasError = stepEls.some((el) => el?.classList.contains('error'));
        agentProgressFillEl.style.background = hasError
          ? 'linear-gradient(90deg, #ef4444, #f59e0b)'
          : 'linear-gradient(90deg, #6aa9ff, #22c55e)';
        agentProgressFillEl.style.width = `${pct}%`;
      }
      if (agentStepsEl) {
        agentStepsEl.addEventListener('click', (e) => {
          const stepEl = e.target.closest('.agent-step');
          if (!stepEl) return;
          Array.from(agentStepsEl.querySelectorAll('.agent-step')).forEach((el) => el.classList.remove('selected'));
          stepEl.classList.add('selected');
          showStepDetail(stepEl.dataset.step || 'plan');
        });
      }

      function addChat(role, title, content, extraNode) {
        const sig = `${role}|${title}|${String(content || '').slice(0, 1200)}`;
        if (sig === lastChatSignature) return;
        lastChatSignature = sig;
        const bubble = document.createElement('div');
        bubble.className = `bubble ${role}`;
        bubble.innerHTML = `<div class="bubble-title">${title}</div><div>${content}</div>`;
        if (extraNode) bubble.appendChild(extraNode);
        chatMessagesEl.appendChild(bubble);
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }

      function jsonHtml(obj) {
        const raw = JSON.stringify(obj, null, 2);
        let esc = escapeHtml(raw);
        esc = esc.replace(/(&quot;[^&]+&quot;)(\s*:)/g, '<span style="color:#93c5fd;">$1</span>$2');
        esc = esc.replace(/:\s(&quot;[^&]*&quot;)/g, ': <span style="color:#22c55e;">$1</span>');
        esc = esc.replace(/:\s(-?\d+(?:\.\d+)?)/g, ': <span style="color:#f59e0b;">$1</span>');
        esc = esc.replace(/:\s(true|false|null)/g, ': <span style="color:#c084fc;">$1</span>');
        return esc;
      }

      function timelineSummary(planObj) {
        const plan = planObj || {};
        const scenes = Array.isArray(plan.scenes) ? plan.scenes : [];
        let cursor = 0;
        return scenes.map((sc, idx) => {
          const sec = Math.max(1, Number(sc.seconds || 1));
          const start = cursor;
          const end = cursor + sec;
          cursor = end;
          return `${idx + 1}. ${start}s-${end}s: ${compactLabel(sc.goal || 'Scene', 86)}`;
        });
      }

      function buildPlanInspector(planObj, planBox) {
        const wrap = document.createElement('div');
        const plan = planObj || {};
        const scenes = Array.isArray(plan.scenes) ? plan.scenes : [];

        const tldr = document.createElement('div');
        tldr.className = 'drawer-section';
        const lines = timelineSummary(plan);
        tldr.innerHTML = `
          <div class="drawer-title">TL;DR timeline</div>
          <div class="muted" style="margin-bottom:6px;">${escapeHtml(plan.title || 'Scene Plan')} • ${Number(plan.total_seconds || 0)}s • ${scenes.length} scenes</div>
          <pre style="margin:0; white-space:pre-wrap; max-height:140px; overflow:auto;">${escapeHtml(lines.join('\n') || 'No scenes')}</pre>
        `;

        const details = document.createElement('details');
        details.className = 'drawer-section';
        details.open = false;
        details.innerHTML = `
          <summary style="cursor:pointer; color:var(--muted);">Colorized JSON</summary>
          <pre style="margin-top:8px; max-height:220px; overflow:auto;">${jsonHtml(plan)}</pre>
        `;

        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'ghost';
        refreshBtn.textContent = 'Refresh TL;DR from edited JSON';
        refreshBtn.style.marginBottom = '8px';
        refreshBtn.addEventListener('click', () => {
          let parsed = null;
          try {
            parsed = JSON.parse(planBox.value || '{}');
          } catch {
            showToast('Plan JSON is invalid.', 'err');
            return;
          }
          const lines2 = timelineSummary(parsed);
          const scenes2 = Array.isArray(parsed.scenes) ? parsed.scenes : [];
          const titleEl = tldr.querySelector('.muted');
          if (titleEl) titleEl.textContent = `${parsed.title || 'Scene Plan'} • ${Number(parsed.total_seconds || 0)}s • ${scenes2.length} scenes`;
          const preEl = tldr.querySelector('pre');
          if (preEl) preEl.textContent = lines2.join('\n') || 'No scenes';
          const preJson = details.querySelector('pre');
          if (preJson) preJson.innerHTML = jsonHtml(parsed);
          timelineMeta.title = parsed.title || 'Scene Plan';
          timelineState = scenes2.map(sc => ({
            seconds: sc.seconds || 3,
            goal: sc.goal,
            elements: sc.elements,
            actions: sc.actions,
            narration: sc.narration,
            assets: sc.assets || {}
          }));
          renderTimeline();
          showToast('TL;DR refreshed.', 'ok');
        });

        wrap.appendChild(tldr);
        wrap.appendChild(details);
        wrap.appendChild(refreshBtn);
        return wrap;
      }

      function updateJobFiles(files) {
        jobFileListEl.innerHTML = '';
        if (!files || !files.length) {
          jobFileListEl.innerHTML = '<div class="muted">No files yet.</div>';
          return;
        }
        files.forEach(f => {
          const item = document.createElement('div');
          item.className = 'tree-file';
          item.textContent = f;
          jobFileListEl.appendChild(item);
        });
      }

      function updateOutputPaths() {
        if (!outputPathsEl) return;
        if (!currentJobId) {
          outputPathsEl.innerHTML = 'Current output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code><br><span class="muted">Project root: <code>Gemini-Hack-Manim/</code></span>';
          if (templateOutputPathEl) templateOutputPathEl.innerHTML = 'Output: <code>work/jobs/&lt;job_id&gt;/out.mp4</code>';
          if (settingsOutputVideoPathEl) settingsOutputVideoPathEl.textContent = 'work/jobs/<job_id>/out.mp4';
          if (settingsOutputCodePathEl) settingsOutputCodePathEl.textContent = 'notes/generated/<job_id>/scene.py';
          return;
        }
        outputPathsEl.innerHTML = `Current output: <code>work/jobs/${currentJobId}/out.mp4</code><br><span class="muted">Scene code: <code>notes/generated/${currentJobId}/scene.py</code></span>`;
        if (templateOutputPathEl) templateOutputPathEl.innerHTML = `Output: <code>work/jobs/${currentJobId}/out.mp4</code>`;
        if (settingsOutputVideoPathEl) settingsOutputVideoPathEl.textContent = `work/jobs/${currentJobId}/out.mp4`;
        if (settingsOutputCodePathEl) settingsOutputCodePathEl.textContent = `notes/generated/${currentJobId}/scene.py`;
      }

      function markTreeSelection() {
        const rows = workspaceTreeEl ? Array.from(workspaceTreeEl.querySelectorAll('.tree-row')) : [];
        rows.forEach((row) => {
          const isSel = row.dataset.path === selectedTreePath && row.dataset.kind === selectedTreeKind;
          row.classList.toggle('selected', !!isSel);
        });
      }

      function setSelectedTreePath(path, kind) {
        selectedTreePath = path || '';
        selectedTreeKind = kind || '';
        markTreeSelection();
      }

      function renderTree(node, container) {
        if (!node) return;
        if (node.type === 'dir') {
          const details = document.createElement('details');
          details.open = true;
          const summary = document.createElement('summary');
          const row = document.createElement('div');
          row.className = 'tree-row';
          row.dataset.path = node.path || '';
          row.dataset.kind = 'folder';
          if ((node.path || '') && selectedTreePath === node.path && selectedTreeKind === 'folder') {
            row.classList.add('selected');
          }
          if (node.path) {
            row.draggable = true;
            row.addEventListener('dragstart', (e) => {
              e.dataTransfer.setData('text/plain', node.path);
              e.dataTransfer.setData('text/path-kind', 'folder');
              e.dataTransfer.effectAllowed = 'copy';
            });
            row.addEventListener('click', (e) => {
              setSelectedTreePath(node.path, 'folder');
            });
            row.addEventListener('dblclick', (e) => {
              e.preventDefault();
              e.stopPropagation();
              startInlineRename(row, node.path, 'dir');
            });
          }
          const name = document.createElement('div');
          name.className = 'tree-row-name';
          name.textContent = node.name || 'folder';
          row.appendChild(name);
          if (node.path) {
            const actions = document.createElement('div');
            actions.className = 'tree-row-actions';
            const renameBtn = document.createElement('button');
            renameBtn.className = 'tree-act';
            renameBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 1 1 3 3L7 19l-4 1 1-4z"/></svg>';
            renameBtn.title = 'Rename';
            renameBtn.setAttribute('aria-label', 'Rename');
            renameBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              startRename(node.path, 'dir');
            });
            const delBtn = document.createElement('button');
            delBtn.className = 'tree-act danger';
            delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 14H6L5 6"/></svg>';
            delBtn.title = 'Delete folder';
            delBtn.setAttribute('aria-label', 'Delete folder');
            delBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              armInlineDelete(actions, node.path, 'folder');
            });
            actions.appendChild(renameBtn);
            actions.appendChild(delBtn);
            row.appendChild(actions);
          }
          summary.appendChild(row);
          details.appendChild(summary);
          const childrenWrap = document.createElement('div');
          childrenWrap.className = 'tree-children';
          (node.children || []).forEach(child => renderTree(child, childrenWrap));
          details.appendChild(childrenWrap);
          container.appendChild(details);
        } else {
          const item = document.createElement('div');
          item.className = 'tree-file';
          const row = document.createElement('div');
          row.className = 'tree-row';
          row.dataset.path = node.path || '';
          row.dataset.kind = 'file';
          if ((node.path || '') && selectedTreePath === node.path && selectedTreeKind === 'file') {
            row.classList.add('selected');
          }
          const name = document.createElement('div');
          name.className = 'tree-row-name';
          name.textContent = node.name;
          const actions = document.createElement('div');
          actions.className = 'tree-row-actions';
          const renameBtn = document.createElement('button');
          renameBtn.className = 'tree-act';
          renameBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 1 1 3 3L7 19l-4 1 1-4z"/></svg>';
          renameBtn.title = 'Rename';
          renameBtn.setAttribute('aria-label', 'Rename');
          renameBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startRename(node.path, 'file');
          });
          const delBtn = document.createElement('button');
          delBtn.className = 'tree-act danger';
          delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 14H6L5 6"/></svg>';
          delBtn.title = 'Delete file';
          delBtn.setAttribute('aria-label', 'Delete file');
          delBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            armInlineDelete(actions, node.path, 'file');
          });
          actions.appendChild(renameBtn);
          actions.appendChild(delBtn);
          row.appendChild(name);
          row.appendChild(actions);
          item.appendChild(row);
          item.draggable = true;
          item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', node.path);
            e.dataTransfer.setData('text/path-kind', 'file');
            e.dataTransfer.effectAllowed = 'copy';
          });
          item.addEventListener('click', () => {
            setSelectedTreePath(node.path, 'file');
            openWorkspaceFile(node.path);
          });
          row.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startInlineRename(row, node.path, 'file');
          });
          container.appendChild(item);
        }
      }

      async function deleteWorkspacePath(path) {
        if (!path) return;
        fileStatusEl.textContent = `Deleting ${path}...`;
        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`, { method: 'DELETE' });
          const data = await resp.json();
          if (!data.ok) {
            fileStatusEl.textContent = data.error || 'Delete failed.';
            return;
          }
          if (openFilePath && (openFilePath === path || openFilePath.startsWith(`${path}/`))) {
            openFilePath = null;
            codeEl.value = '';
            refreshGutter();
            if (highlightOn) refreshHighlight();
            updateEditorMode();
          }
          for (let i = editorTabsState.length - 1; i >= 0; i--) {
            const t = editorTabsState[i];
            if (!t.path) continue;
            if (t.path === path || t.path.startsWith(`${path}/`)) editorTabsState.splice(i, 1);
          }
          if (!editorTabsState.some((t) => t.id === activeEditorTabId)) {
            activeEditorTabId = 'generated';
            ensureGeneratedTab();
            applyActiveEditorTab();
          }
          renderEditorTabs();
          if (selectedTreePath && (selectedTreePath === path || selectedTreePath.startsWith(`${path}/`))) {
            setSelectedTreePath('', '');
          }
          fileStatusEl.textContent = `Deleted: ${path}`;
          await loadWorkspaceFiles();
          showToast('Deleted.', 'ok');
          pushHistory(`Deleted ${path}`);
        } catch {
          fileStatusEl.textContent = 'Failed to reach backend.';
        }
      }

      function armInlineDelete(actionsEl, path, kind) {
        if (!actionsEl || !path) return;
        actionsEl.innerHTML = '';
        const yesBtn = document.createElement('button');
        yesBtn.className = 'tree-act confirm';
        yesBtn.title = `Confirm delete ${kind}`;
        yesBtn.setAttribute('aria-label', `Confirm delete ${kind}`);
        yesBtn.textContent = '✓';
        yesBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await deleteWorkspacePath(path);
        });
        const noBtn = document.createElement('button');
        noBtn.className = 'tree-act reject';
        noBtn.title = 'Cancel';
        noBtn.setAttribute('aria-label', 'Cancel delete');
        noBtn.textContent = '✕';
        noBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          loadWorkspaceFiles();
          fileStatusEl.textContent = 'Delete cancelled.';
        });
        actionsEl.appendChild(yesBtn);
        actionsEl.appendChild(noBtn);
      }

      function setActiveTab(tabId) {
        const tabs = Array.from(document.querySelectorAll('.tab'));
        const panels = Array.from(document.querySelectorAll('.tab-panel'));
        tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabId));
        panels.forEach(p => p.classList.toggle('active', p.dataset.tab === tabId));
      }

      function setContextTab(id) {
        ctxTabs.forEach(b => {
          const on = b.dataset.ctx === id;
          b.classList.toggle('active', on);
          b.setAttribute('aria-selected', on ? 'true' : 'false');
        });
        ctxPanels.forEach(p => p.classList.toggle('active', p.dataset.ctx === id));
      }
      ctxTabs.forEach(b => b.addEventListener('click', () => setContextTab(b.dataset.ctx)));

      if (saveProjectBtn) saveProjectBtn.addEventListener('click', () => saveProject(false));
      function safeOn(el, eventName, handler) {
        if (el) el.addEventListener(eventName, handler);
      }

      function bindAutosave(el, ev = 'input') {
        if (!el) return;
        el.addEventListener(ev, () => scheduleAutosave());
      }
      bindAutosave(chatInputEl, 'input');
      bindAutosave(chatModelEl, 'change');
      bindAutosave(directorBriefEl, 'input');
      bindAutosave(templateSelectEl, 'change');
      bindAutosave(imagePromptEl, 'input');
      bindAutosave(imageModeEl, 'change');
      bindAutosave(includeImagesEl, 'change');
      bindAutosave(aspectEl, 'change');
      bindAutosave(audienceEl, 'change');
      bindAutosave(toneEl, 'change');
      bindAutosave(styleEl, 'change');
      bindAutosave(paceEl, 'change');
      bindAutosave(paletteEl, 'change');
      bindAutosave(qualityEl, 'change');
      bindAutosave(targetSecondsEl, 'input');
      bindAutosave(maxScenesEl, 'input');
      bindAutosave(maxObjectsEl, 'input');
      bindAutosave(equationsEl, 'change');
      bindAutosave(graphsEl, 'change');
      bindAutosave(narrationEl, 'change');
      bindAutosave(imageModelOverrideEl, 'change');

      function updateEditorMode() {
        if (!openFilePath) {
          editorLabelEl.textContent = 'Editor • generated code';
          saveFileBtn.disabled = true;
          renderCodeBtn.disabled = false;
          addSelectionBtn.disabled = false;
          return;
        }
        editorLabelEl.textContent = `Editor • ${openFilePath}`;
        saveFileBtn.disabled = false;
        const canRender = openFilePath.endsWith('.py');
        renderCodeBtn.disabled = !canRender;
        addSelectionBtn.disabled = false;
      }

      function lineOfIndex(text, idx) {
        if (idx <= 0) return 1;
        let n = 1;
        for (let i = 0; i < idx && i < text.length; i++) {
          if (text[i] === '\\n') n += 1;
        }
        return n;
      }

      function addSelectionToPrompt() {
        const text = codeEl.value || '';
        const a = codeEl.selectionStart ?? 0;
        const b = codeEl.selectionEnd ?? 0;
        if (a === b) {
          statusEl.textContent = 'Select some text in the editor first.';
          return;
        }
        const sel = text.slice(a, b);
        const l1 = lineOfIndex(text, a);
        const l2 = lineOfIndex(text, b);
        const label = openFilePath ? `${openFilePath}:${l1}-${l2}` : `generated_scene.py:${l1}-${l2}`;
        chatInputEl.value += `\n\n[@ref ${label}]\n${sel}\n`;
        statusEl.textContent = `Added selection to prompt: ${label}`;
      }

      addSelectionBtn.addEventListener('click', addSelectionToPrompt);

      function animateCodeIntoEditor(code, opts) {
        const immediate = !!(opts && opts.immediate);
        const target = String(code || '');
        if (immediate || target.length < 400) {
          codeEl.value = target;
          refreshGutter();
          if (highlightOn) refreshHighlight();
          return;
        }
        // Fast "typing" illusion: chunk in quickly without freezing the UI.
        codeEl.value = '';
        refreshGutter();
        const chunk = 220;
        let i = 0;
        function tick() {
          i = Math.min(target.length, i + chunk);
          codeEl.value = target.slice(0, i);
          refreshGutter();
          if (highlightOn) refreshHighlight();
          if (i < target.length) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      async function persistGeneratedSceneFile(code, focusEditor = false) {
        if (!currentJobId || !code) return;
        const signature = `${currentJobId}:${code.length}:${String(code).slice(0, 128)}`;
        if (persistedSceneSignature === signature) return;
        const path = `notes/generated/${currentJobId}/scene.py`;
        upsertGeneratedTab(code);
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: code, overwrite: true })
          });
          const data = await resp.json();
          if (data.ok) {
            persistedSceneSignature = signature;
            upsertFileTab(data.path, code, !!focusEditor);
            if (focusEditor) {
              activeEditorTabId = `file:${data.path}`;
              applyActiveEditorTab();
              renderEditorTabs();
            }
            setSelectedTreePath(data.path, 'file');
            await loadWorkspaceFiles();
            pushHistory(`Generated ${data.path}`);
          }
        } catch {}
      }

      async function tryWriteWorkspaceFile(path, content) {
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: content || '' })
          });
          const data = await resp.json();
          if (data.ok) return data.path;
          return null;
        } catch {
          return null;
        }
      }

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error('read failed'));
          reader.onload = () => {
            const out = String(reader.result || '');
            const base64 = out.includes(',') ? out.split(',', 2)[1] : out;
            resolve(base64 || '');
          };
          reader.readAsDataURL(file);
        });
      }

      async function uploadImageToCurrentJob(file, role) {
        if (!currentJobId) {
          showToast('Create plan first to upload image assets.', 'err');
          return null;
        }
        const base64 = await fileToBase64(file);
        const resp = await fetch('/api/jobs/upload-asset', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            job_id: currentJobId,
            filename: file.name || 'image.png',
            content_base64: base64,
            role: role || 'background'
          })
        });
        const data = await resp.json();
        if (!data.ok) {
          showToast(data.error || 'Image upload failed.', 'err');
          return null;
        }
        return data.asset_path || null;
      }

      async function attachFilesFromPicker(files) {
        const list = Array.from(files || []);
        if (!list.length) return;
        for (const f of list) {
          if (f.size > 800_000) {
            showToast(`Skipped ${f.name}: file too large for inline attach.`, 'err');
            continue;
          }
          const isText = /^text\//.test(f.type) || /\.(md|txt|py|json|yaml|yml|csv)$/i.test(f.name);
          if (!isText) {
            showToast(`Skipped ${f.name}: only text files are supported right now.`, 'err');
            continue;
          }
          const text = await f.text();
          chatInputEl.value += `\\n\\n[File: ${f.name}]\\n${text}\\n`;
          // Also save into workspace for later re-use.
          const base = `notes/uploads/${f.name}`;
          let saved = await tryWriteWorkspaceFile(base, text);
          if (!saved) {
            // If name collides, try suffixes.
            for (let i = 2; i < 20 && !saved; i++) {
              const cand = `notes/uploads/${f.name.replace(/(\.[^.]*)?$/, `-${i}$1`)}`;
              saved = await tryWriteWorkspaceFile(cand, text);
            }
          }
          if (saved) {
            loadWorkspaceFiles();
            showToast(`Attached + saved: ${saved}`, 'ok');
          } else {
            showToast(`Attached: ${f.name}`, 'ok');
          }
        }
      }

      if (attachBtnEl && filePickerEl) {
        attachBtnEl.addEventListener('click', () => filePickerEl.click());
        filePickerEl.addEventListener('change', (e) => {
          attachFilesFromPicker(e.target.files);
          e.target.value = '';
        });
      }

      // Voice input (Chrome Web Speech). This is a best-effort enhancement.
      let recognition = null;
      let voiceOn = false;
      function setVoiceOn(on) {
        voiceOn = !!on;
        if (voiceBtnEl) voiceBtnEl.style.borderColor = voiceOn ? 'rgba(34,197,94,0.7)' : 'var(--border)';
      }
      if (voiceBtnEl) {
        voiceBtnEl.addEventListener('click', () => {
          const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!Rec) {
            showToast('Voice input not supported in this browser.', 'err');
            return;
          }
          if (!recognition) {
            recognition = new Rec();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            recognition.onresult = (event) => {
              let finalText = '';
              let interim = '';
              for (let i = event.resultIndex; i < event.results.length; i++) {
                const res = event.results[i];
                const t = res[0]?.transcript || '';
                if (res.isFinal) finalText += t;
                else interim += t;
              }
              if (finalText) chatInputEl.value += (chatInputEl.value.endsWith(' ') ? '' : ' ') + finalText.trim() + ' ';
              if (interim) statusEl.textContent = `Listening… ${interim.trim()}`;
            };
            recognition.onerror = () => {
              setVoiceOn(false);
              statusEl.textContent = 'Voice stopped.';
            };
            recognition.onend = () => {
              setVoiceOn(false);
              statusEl.textContent = 'Ready.';
            };
          }
          if (!voiceOn) {
            try {
              recognition.start();
              setVoiceOn(true);
              statusEl.textContent = 'Listening…';
            } catch {
              // Ignore repeated start errors.
            }
          } else {
            try { recognition.stop(); } catch {}
            setVoiceOn(false);
          }
        });
      }

      function escapeHtml(s) {
        return String(s || '')
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }

      function refreshGutter() {
        if (!codeGutterEl) return;
        const lineCount = Math.max(1, String(codeEl.value || '').split('\\n').length);
        let out = '';
        for (let i = 1; i <= lineCount; i++) out += i + '\\n';
        codeGutterEl.textContent = out;
        // Keep gutter scroll aligned.
        codeGutterEl.scrollTop = codeEl.scrollTop;
      }

      let highlightOn = true;
      function refreshHighlight() {
        const src = codeEl.value || '';
        let html = '';
        if (window.hljs && window.hljs.highlight) {
          try {
            html = window.hljs.highlight(src, { language: 'python' }).value || '';
          } catch {
            html = escapeHtml(src);
          }
        } else {
          html = escapeHtml(src);
        }
        const lines = html.split('\\n');
        codePrettyEl.innerHTML = lines.map((line) => {
          // Preserve empty lines so counters stay correct.
          const safe = (line && line.length) ? line : '&nbsp;';
          return `<span class=\"code-line\"><span>${safe}</span></span>`;
        }).join('\\n');
      }

      // Default to colorized code view; click "Edit" to switch to raw editor.
      if (codePrettyWrapEl) codePrettyWrapEl.classList.remove('hidden');
      if (codeEditorEl) codeEditorEl.classList.add('hidden');
      if (toggleHighlightBtn) toggleHighlightBtn.textContent = 'Edit';

      safeOn(toggleHighlightBtn, 'click', () => {
        highlightOn = !highlightOn;
        codePrettyWrapEl.classList.toggle('hidden', !highlightOn);
        if (codeEditorEl) codeEditorEl.classList.toggle('hidden', highlightOn);
        toggleHighlightBtn.textContent = highlightOn ? 'Edit' : 'Highlight';
        if (highlightOn) refreshHighlight();
        else codeEl.focus();
      });

      codeEl.addEventListener('scroll', () => refreshGutter());
      codeEl.addEventListener('input', () => {
        syncCurrentEditorIntoActiveTab();
        refreshGutter();
        if (highlightOn) refreshHighlight();
        scheduleAutosave();
      });
      function sceneIndexSummary(indexes, totalScenes = 0) {
        if (!Array.isArray(indexes) || !indexes.length) return 'none';
        const sorted = Array.from(new Set(indexes)).sort((a, b) => a - b);
        if (totalScenes > 0 && sorted.length === totalScenes) return 'all scenes';
        const out = [];
        let start = sorted[0];
        let prev = sorted[0];
        for (let i = 1; i < sorted.length; i++) {
          const cur = sorted[i];
          if (cur === prev + 1) {
            prev = cur;
            continue;
          }
          out.push(start === prev ? `S${start + 1}` : `S${start + 1}-S${prev + 1}`);
          start = cur;
          prev = cur;
        }
        out.push(start === prev ? `S${start + 1}` : `S${start + 1}-S${prev + 1}`);
        return out.join(', ');
      }

      function refreshAppliedAssetInfo() {
        if (bgAppliedInfoEl) {
          const bgIdx = [];
          timelineState.forEach((sc, i) => {
            if (sc?.assets?.background) bgIdx.push(i);
          });
          bgAppliedInfoEl.textContent = `Applied to: ${sceneIndexSummary(bgIdx, timelineState.length)}`;
        }
        if (fgAppliedInfoEl) {
          const fgIdx = [];
          timelineState.forEach((sc, i) => {
            if (sc?.assets?.foreground) fgIdx.push(i);
          });
          fgAppliedInfoEl.textContent = `Applied to: ${sceneIndexSummary(fgIdx, timelineState.length)}`;
        }
      }

      function getThumbAsset(role) {
        const el = role === 'foreground' ? fgThumbEl : bgThumbEl;
        if (!el) return '';
        return String(el.dataset.assetPath || '').trim();
      }

      function applyAssetToAllScenes(role) {
        const assetPath = getThumbAsset(role);
        if (!assetPath) {
          showToast(`Generate a ${role} image first.`, 'err');
          return;
        }
        if (!timelineState.length) {
          showToast('Create plan first.', 'err');
          return;
        }
        timelineState.forEach((sc) => {
          sc.assets = sc.assets || {};
          sc.assets[role] = assetPath;
        });
        renderTimeline();
        showToast(`${role === 'background' ? 'BG' : 'FG'} applied to all scenes.`, 'ok');
      }

      function clearAssetFromAllScenes(role) {
        if (!timelineState.length) return;
        timelineState.forEach((sc) => {
          if (!sc.assets) return;
          delete sc.assets[role];
        });
        renderTimeline();
        showToast(`${role === 'background' ? 'BG' : 'FG'} cleared from scenes.`, 'ok');
      }

      function setThumb(el, opts) {
        const url = opts?.url || '';
        const type = opts?.type || '';
        const relPath = opts?.relPath || '';
        el.innerHTML = '';
        el.dataset.assetType = type;
        el.dataset.assetPath = relPath;
        if (!url) {
          el.textContent = 'No image yet';
          el.classList.remove('draggable');
          el.removeAttribute('draggable');
          refreshAppliedAssetInfo();
          return;
        }
        const img = document.createElement('img');
        img.src = url;
        img.alt = type;
        el.appendChild(img);
        el.classList.add('draggable');
        el.draggable = true;
        el.title = `Drag into a scene (${type})`;
        el.ondragstart = (e) => {
          e.dataTransfer.setData('text/asset-type', type);
          e.dataTransfer.setData('text/asset-path', relPath);
          e.dataTransfer.effectAllowed = 'copy';
        };
        refreshAppliedAssetInfo();
      }

      async function generateImages() {
        if (!currentJobId) {
          showToast('Create plan first so images can be stored under a job folder.', 'err');
          statusEl.textContent = 'Create plan first, then click Generate images.';
          return;
        }
        const prompt = (imagePromptEl.value || '').trim();
        if (!prompt) {
          showToast('Add an image prompt first.', 'err');
          return;
        }
        if (genImagesBtn) genImagesBtn.disabled = true;
        try {
          setBusy(true, 'Generating images…', 'Images');
          await new Promise(requestAnimationFrame);
          const resp = await fetch('/api/images/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              job_id: currentJobId,
              image_prompt: prompt,
              image_mode: imageModeEl.value,
              image_model: imageModelOverrideEl.value || null
            })
          });
          const data = await resp.json();
          if (!data.ok) {
            showToast(data.error || 'Image generation failed.', 'err');
            return;
          }
          const bgRel = data.assets?.background || '';
          const fgRel = data.assets?.foreground || '';
          if (bgRel) {
            setThumb(bgThumbEl, { url: `/work/jobs/${currentJobId}/${bgRel}?t=${Date.now()}`, type: 'background', relPath: bgRel });
          } else {
            setThumb(bgThumbEl, { url: '', type: 'background', relPath: '' });
          }
          if (fgRel) {
            setThumb(fgThumbEl, { url: `/work/jobs/${currentJobId}/${fgRel}?t=${Date.now()}`, type: 'foreground', relPath: fgRel });
          } else {
            setThumb(fgThumbEl, { url: '', type: 'foreground', relPath: '' });
          }
          if (data.warning) {
            logsEl.textContent = data.warning;
            showToast('Images: partial failure (see logs).', 'err');
          } else {
            showToast('Images generated. Drag BG/FG into scenes.', 'ok');
            pushHistory(`Generated images for ${currentJobId}`);
          }
          scheduleAutosave();
        } catch (e) {
          showToast('Backend not reachable.', 'err');
        } finally {
          setBusy(false);
          if (genImagesBtn) genImagesBtn.disabled = false;
        }
      }

      async function openWorkspaceFile(path) {
        if (!path) return;
        setSelectedTreePath(path, 'file');
        syncCurrentEditorIntoActiveTab();
        let data = null;
        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`);
          data = await resp.json();
        } catch (e) {
          logsEl.textContent = 'Failed to reach backend.';
          return;
        }
        if (!data.ok) {
          logsEl.textContent = data.error || 'Failed to open file.';
          return;
        }
        upsertFileTab(data.path, data.content || '');
        openFileContent = data.content || '';
        pushHistory(`Opened ${data.path}`);
        setActiveTab('code');
        codeEl.focus();
      }

      async function saveWorkspaceFile() {
        if (!openFilePath) return;
        syncCurrentEditorIntoActiveTab();
        let data = null;
        try {
          const resp = await fetch('/api/files/file', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: openFilePath, content: codeEl.value })
          });
          data = await resp.json();
        } catch (e) {
          logsEl.textContent = 'Failed to reach backend.';
          return;
        }
        if (!data.ok) {
          logsEl.textContent = data.error || 'Failed to save file.';
          return;
        }
        const tab = getActiveEditorTab();
        if (tab) tab.content = codeEl.value || '';
        openFileContent = codeEl.value || '';
        logsEl.textContent = `Saved: ${openFilePath}`;
        showToast(`Saved: ${openFilePath}`, 'ok');
        pushHistory(`Saved ${openFilePath}`);
      }

      function startRename(fromPath, kind = '') {
        pendingRenameFrom = fromPath;
        pendingRenameKind = kind || '';
        newPathEl.value = fromPath;
        newPathEl.focus();
        const lastSlash = fromPath.lastIndexOf('/');
        const dot = fromPath.lastIndexOf('.');
        const selStart = lastSlash >= 0 ? lastSlash + 1 : 0;
        const selEnd = (dot > selStart) ? dot : fromPath.length;
        try {
          newPathEl.setSelectionRange(selStart, selEnd);
        } catch {}
        fileStatusEl.textContent = 'Rename: edit the path above and press Enter (or click ✓).';
        applyRenameBtn.classList.remove('hidden');
      }

      function looksLikeFileName(path) {
        const leaf = String(path || '').split('/').filter(Boolean).pop() || '';
        return /\.[A-Za-z0-9]{1,8}$/.test(leaf);
      }

      async function doRenamePath(fromPath, toPath, kind = '') {
        if (!fromPath || !toPath) return { ok: false, error: 'Invalid rename path.' };
        if (kind === 'dir' && looksLikeFileName(toPath)) {
          return { ok: false, error: 'Folder names cannot look like files (example: folder.py).' };
        }
        let data = null;
        try {
          const resp = await fetch('/api/files/rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ from_path: fromPath, to_path: toPath })
          });
          data = await resp.json();
        } catch (e) {
          return { ok: false, error: 'Failed to reach backend.' };
        }
        if (!data.ok) {
          return { ok: false, error: data.error || 'Rename failed.' };
        }

        editorTabsState.forEach((t) => {
          if (!t.path) return;
          if (t.path === fromPath || t.path.startsWith(`${fromPath}/`)) {
            t.path = t.path === fromPath ? toPath : `${toPath}${t.path.slice(fromPath.length)}`;
            t.id = `file:${t.path}`;
            t.label = fileBaseName(t.path);
          }
        });
        if (openFilePath === fromPath) {
          openFilePath = toPath;
          updateEditorMode();
        }
        renderEditorTabs();
        await loadWorkspaceFiles();
        pushHistory(`Renamed ${fromPath} → ${toPath}`);
        return { ok: true };
      }

      async function renamePending() {
        const toPath = newPathEl.value.trim();
        const fromPath = pendingRenameFrom;
        if (!fromPath) return;
        if (!toPath) {
          fileStatusEl.textContent = 'Rename cancelled: empty path.';
          pendingRenameFrom = null;
          pendingRenameKind = '';
          applyRenameBtn.classList.add('hidden');
          return;
        }
        fileStatusEl.textContent = 'Renaming...';
        const out = await doRenamePath(fromPath, toPath, pendingRenameKind);
        if (!out.ok) {
          fileStatusEl.textContent = out.error || 'Rename failed.';
          return;
        }
        pendingRenameFrom = null;
        pendingRenameKind = '';
        applyRenameBtn.classList.add('hidden');
        newPathEl.value = '';
        fileStatusEl.textContent = `Renamed: ${fromPath} → ${toPath}`;
      }

      function startInlineRename(rowEl, fromPath, kind = '') {
        if (!rowEl || !fromPath) return;
        const nameWrap = rowEl.querySelector('.tree-row-name');
        const actions = rowEl.querySelector('.tree-row-actions');
        if (!nameWrap || !actions) return;
        const oldLeaf = String(fromPath).split('/').filter(Boolean).pop() || fromPath;
        const parent = fromPath.includes('/') ? fromPath.slice(0, fromPath.lastIndexOf('/')) : '';
        const input = document.createElement('input');
        input.value = oldLeaf;
        input.placeholder = kind === 'dir' ? 'folder-name' : 'file-name.ext';
        nameWrap.innerHTML = '';
        nameWrap.appendChild(input);
        actions.innerHTML = '';
        const okBtn = document.createElement('button');
        okBtn.className = 'tree-act confirm';
        okBtn.title = 'Confirm rename';
        okBtn.textContent = '✓';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'tree-act reject';
        cancelBtn.title = 'Cancel rename';
        cancelBtn.textContent = '✕';
        actions.appendChild(okBtn);
        actions.appendChild(cancelBtn);

        const submit = async () => {
          const newLeaf = (input.value || '').trim();
          if (!newLeaf) {
            fileStatusEl.textContent = 'Rename cancelled: empty name.';
            await loadWorkspaceFiles();
            return;
          }
          const toPath = parent ? `${parent}/${newLeaf}` : newLeaf;
          fileStatusEl.textContent = 'Renaming...';
          const out = await doRenamePath(fromPath, toPath, kind);
          if (!out.ok) {
            fileStatusEl.textContent = out.error || 'Rename failed.';
            await loadWorkspaceFiles();
            return;
          }
          fileStatusEl.textContent = `Renamed: ${fromPath} → ${toPath}`;
        };
        const cancel = async () => {
          await loadWorkspaceFiles();
        };
        okBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          submit();
        });
        cancelBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          cancel();
        });
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            submit();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancel();
          }
        });
        setTimeout(() => {
          input.focus();
          input.setSelectionRange(0, oldLeaf.length);
        }, 0);
      }

      async function loadWorkspaceFiles() {
        try {
          const resp = await fetch('/api/files');
          const data = await resp.json();
          workspaceTreeEl.innerHTML = '';
          renderTree(data.tree, workspaceTreeEl);
          markTreeSelection();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
        }
      }

      async function createFolder() {
        const path = newPathEl.value.trim();
        if (!path) {
          // Quick-create a unique folder, then prompt rename.
          const stamp = Date.now().toString().slice(-6);
          const candidate = `New Folder ${stamp}`;
          try {
            const resp = await fetch('/api/files/folder', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: candidate })
            });
            const data = await resp.json();
            if (!data.ok) {
              fileStatusEl.textContent = data.error || 'Failed to create a new folder.';
              return;
            }
            loadWorkspaceFiles();
            startRename(data.path, 'dir');
            pushHistory(`Created folder ${data.path}`);
            return;
          } catch (e) {
            fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
            return;
          }
        }
        if (looksLikeFileName(path)) {
          fileStatusEl.textContent = 'Folder names cannot look like files (example: folder.py).';
          return;
        }
        fileStatusEl.textContent = 'Creating folder...';
        let data = null;
        try {
          const resp = await fetch('/api/files/folder', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path })
          });
          data = await resp.json();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
          return;
        }
        if (!data.ok) {
          fileStatusEl.textContent = data.error || 'Failed to create folder.';
          return;
        }
        fileStatusEl.textContent = `Folder created: ${data.path}`;
        startRename(data.path, 'dir');
        loadWorkspaceFiles();
        pushHistory(`Created folder ${data.path}`);
      }

      async function createFile() {
        const path = newPathEl.value.trim();
        if (!path) {
          // Quick-create a unique file, then prompt rename.
          const stamp = Date.now().toString().slice(-6);
          const candidate = `untitled-${stamp}.md`;
          try {
            const resp = await fetch('/api/files/file', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: candidate, content: '' })
            });
            const data = await resp.json();
            if (!data.ok) {
              fileStatusEl.textContent = data.error || 'Failed to create a new file.';
              return;
            }
            loadWorkspaceFiles();
            startRename(data.path, 'file');
            await openWorkspaceFile(data.path);
            pushHistory(`Created file ${data.path}`);
            return;
          } catch (e) {
            fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
            return;
          }
        }
        fileStatusEl.textContent = 'Creating file...';
        let data = null;
        try {
          const resp = await fetch('/api/files/file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path, content: '' })
          });
          data = await resp.json();
        } catch (e) {
          fileStatusEl.textContent = 'Backend unreachable. Start server: source .venv/bin/activate && python -m uvicorn backend.main:app --reload --port 8000';
          return;
        }
        if (!data.ok) {
          fileStatusEl.textContent = data.error || 'Failed to create file.';
          return;
        }
        fileStatusEl.textContent = `File created: ${data.path}`;
        startRename(data.path, 'file');
        loadWorkspaceFiles();
        await openWorkspaceFile(data.path);
        pushHistory(`Created file ${data.path}`);
      }

      chatInputEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        chatInputEl.classList.add('drop-target');
      });
      chatInputEl.addEventListener('dragleave', () => {
        chatInputEl.classList.remove('drop-target');
      });
      chatInputEl.addEventListener('drop', async (e) => {
        e.preventDefault();
        chatInputEl.classList.remove('drop-target');
        const dt = e.dataTransfer;
        const indexedSnippet = (dt.getData('text/source-snippet') || '').trim();
        if (indexedSnippet) {
          chatInputEl.value += `\n\n${indexedSnippet}\n`;
          statusEl.textContent = 'Attached indexed source to prompt.';
          return;
        }
        const indexedFile = (dt.getData('text/source-file') || '').trim();
        if (indexedFile) {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(indexedFile)}`);
            const data = await resp.json();
            if (data.ok) {
              chatInputEl.value += `\n\n[File: ${data.path}]\n${data.content}\n`;
            } else {
              chatInputEl.value += `\n\n[File: ${indexedFile}]\n`;
            }
          } catch {
            chatInputEl.value += `\n\n[File: ${indexedFile}]\n`;
          }
          statusEl.textContent = 'Attached source file to prompt.';
          return;
        }
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetPath) {
          chatInputEl.value += `\n\n[Asset: ${assetType || 'image'}]\nPath: ${assetPath}\n`;
          statusEl.textContent = 'Attached asset reference to prompt.';
          return;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          for (const file of droppedFiles) {
            if (file.type && file.type.startsWith('image/')) {
              let attached = null;
              try {
                attached = await uploadImageToCurrentJob(file, 'background');
              } catch {}
              if (attached) {
                chatInputEl.value += `\n\n[Asset: background]\nPath: ${attached}\n`;
              } else {
                chatInputEl.value += `\n\n[Image file dropped]\nName: ${file.name}\nType: ${file.type}\n`;
              }
              continue;
            }
            try {
              const text = await file.text();
              chatInputEl.value += `\n\n[File: ${file.name}]\n${text}\n`;
            } catch {
              chatInputEl.value += `\n\n[File dropped]\nName: ${file.name}\n`;
            }
          }
          statusEl.textContent = 'Attached dropped files to prompt.';
          return;
        }

        const raw = (dt.getData('text/plain') || '').trim();
        if (!raw) return;

        const droppedPathKind = dt.getData('text/path-kind');
        const looksLikePath = !!droppedPathKind || /[\/\\]|\.md$|\.txt$|\.py$|\.json$|\.csv$|\.ya?ml$|\.png$|\.jpe?g$|\.gif$|\.webp$/i.test(raw);
        if (!looksLikePath || raw.includes('\n')) {
          chatInputEl.value += `\n\n[Snippet]\n${raw}\n`;
          statusEl.textContent = 'Attached dropped snippet to prompt.';
          return;
        }
        if (droppedPathKind === 'folder') {
          chatInputEl.value += `\n\n[Folder: ${raw}]\n`;
          statusEl.textContent = 'Attached folder reference to prompt.';
          return;
        }

        try {
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
          const data = await resp.json();
          if (data.ok) {
            chatInputEl.value += `\n\n[File: ${data.path}]\n${data.content}\n`;
            statusEl.textContent = `Attached ${data.path}`;
            return;
          }
          const kind = droppedPathKind || 'path';
          chatInputEl.value += `\n\n[${kind === 'folder' ? 'Folder' : 'Path'}: ${raw}]\n`;
          statusEl.textContent = 'Attached path reference to prompt.';
        } catch {
          chatInputEl.value += `\n\n[Path: ${raw}]\n`;
          statusEl.textContent = 'Backend unreachable. Path attached as reference only.';
        }
      });

      async function resolveDroppedContent(dt) {
        const indexedSnippet = (dt.getData('text/source-snippet') || '').trim();
        if (indexedSnippet) return indexedSnippet;
        const indexedFile = (dt.getData('text/source-file') || '').trim();
        if (indexedFile) {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(indexedFile)}`);
            const data = await resp.json();
            if (data.ok) return `[File: ${data.path}]\n${data.content}`;
          } catch {}
          return `[File: ${indexedFile}]`;
        }
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetPath) {
          return `[Asset: ${assetType || 'image'}]\nPath: ${assetPath}`;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          const parts = [];
          for (const file of droppedFiles) {
            if (file.type && file.type.startsWith('image/')) {
              let rel = null;
              try { rel = await uploadImageToCurrentJob(file, 'background'); } catch { rel = null; }
              if (rel) parts.push(`[Asset: background]\nPath: ${rel}`);
              else parts.push(`[Image]\nName: ${file.name}`);
              continue;
            }
            try {
              parts.push(`[File: ${file.name}]\n${await file.text()}`);
            } catch {
              parts.push(`[File]\nName: ${file.name}`);
            }
          }
          return parts.join('\n\n');
        }

        const raw = (dt.getData('text/plain') || '').trim();
        if (!raw) return '';
        const droppedPathKind = dt.getData('text/path-kind');
        const looksLikePath = !!droppedPathKind || /[\/\\]|\.md$|\.txt$|\.py$|\.json$|\.csv$|\.ya?ml$/i.test(raw);
        if (droppedPathKind === 'folder') return `[Folder: ${raw}]`;
        if (looksLikePath && droppedPathKind !== 'folder') {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
            const data = await resp.json();
            if (data.ok) return `[File: ${data.path}]\n${data.content}`;
          } catch {}
          return `[Path: ${raw}]`;
        }
        return raw;
      }

      function enableContextDrop(inputEl, label) {
        if (!inputEl) return;
        inputEl.addEventListener('dragover', (e) => {
          e.preventDefault();
          inputEl.classList.add('context-drop');
        });
        inputEl.addEventListener('dragleave', () => inputEl.classList.remove('context-drop'));
        inputEl.addEventListener('drop', async (e) => {
          e.preventDefault();
          inputEl.classList.remove('context-drop');
          const text = await resolveDroppedContent(e.dataTransfer);
          if (!text) return;
          const cur = String(inputEl.value || '').trim();
          inputEl.value = cur ? `${cur}\n\n${text}` : text;
          showToast(`Attached to ${label}.`, 'ok');
          scheduleAutosave();
        });
      }

      enableContextDrop(memoryContentEl, 'memory');
      enableContextDrop(sourceNotesEl, 'docs');
      enableContextDrop(skillContentEl, 'skill');
      enableContextDrop(subagentsTextEl, 'subagents');

      async function loadTemplates() {
        const resp = await fetch('/api/templates');
        const data = await resp.json();
        templates = data.templates || [];
        templateSelectEl.innerHTML = '';
        templates.forEach((t, idx) => {
          const opt = document.createElement('option');
          opt.value = t.id;
          opt.textContent = `${t.name} (${t.category})`;
          if (idx === 0) opt.selected = true;
          templateSelectEl.appendChild(opt);
        });
        // If we have an autosave snapshot, respect its template selection without
        // re-applying template defaults (which would overwrite restored fields).
        if (pendingRestore && pendingRestore.template_id) {
          const wanted = String(pendingRestore.template_id);
          const exists = templates.some(t => t.id === wanted);
          if (exists) templateSelectEl.value = wanted;
          showToast('Restored last session.', 'ok');
          return;
        }
        if (templates[0]) applyTemplate(templates[0]);
      }

      function applyTemplate(tpl) {
        if (!tpl) return;
        templateDescriptionEl.value = tpl.description;
        if (tpl.example_prompt) chatInputEl.value = tpl.example_prompt;
        if (tpl.director_brief) directorBriefEl.value = tpl.director_brief;
        const d = tpl.defaults || {};
        if (d.audience) audienceEl.value = d.audience;
        if (d.tone) toneEl.value = d.tone;
        if (d.style) styleEl.value = d.style;
        if (d.pace) paceEl.value = d.pace;
        if (d.color_palette) paletteEl.value = d.color_palette;
        if (d.aspect_ratio) { aspectEl.value = d.aspect_ratio; setPreviewAspect(d.aspect_ratio); }
        if (d.quality) qualityEl.value = d.quality;
        if (typeof d.include_equations === 'boolean') equationsEl.value = d.include_equations ? 'true' : 'false';
        if (typeof d.include_graphs === 'boolean') graphsEl.value = d.include_graphs ? 'true' : 'false';
        if (typeof d.include_narration === 'boolean') narrationEl.value = d.include_narration ? 'true' : 'false';
        if (d.target_seconds) targetSecondsEl.value = d.target_seconds;
      }

      templateSelectEl.addEventListener('change', () => {
        const tpl = templates.find(t => t.id === templateSelectEl.value);
        applyTemplate(tpl);
      });
      if (resetToTemplateBtn) {
        resetToTemplateBtn.addEventListener('click', () => {
          const tpl = templates.find(t => t.id === templateSelectEl.value);
          if (!tpl) return;
          applyTemplate(tpl);
          showToast('Reset to template defaults.', 'ok');
        });
      }

      const SETTINGS_SAVED_MASK = '******';

      async function loadSettings() {
        const resp = await fetch('/api/settings');
        const data = await resp.json();
        if (data.text_model) {
          settingsTextModelEl.value = data.text_model;
          chatModelEl.value = data.text_model;
        }
        if (data.image_model) settingsImageModelEl.value = data.image_model;
        if (data.manim_py) settingsManimPyEl.value = data.manim_py;
        if (settingsProjectRootEl) settingsProjectRootEl.textContent = data.project_root || '—';
        if (settingsWorkRootEl) settingsWorkRootEl.textContent = data.work_root || '—';
        if (settingsOutputCopyDirEl) settingsOutputCopyDirEl.value = data.output_copy_dir || '';
        if (settingsElevenVoiceIdEl) settingsElevenVoiceIdEl.value = data.elevenlabs_voice_id || '';
        if (settingsElevenModelIdEl) settingsElevenModelIdEl.value = data.elevenlabs_model_id || '';
        if (settingsApiKeyEl) {
          settingsApiKeyEl.placeholder = data.has_api_key ? 'Saved (hidden)' : 'Paste key';
          settingsApiKeyEl.value = data.has_api_key ? SETTINGS_SAVED_MASK : '';
        }
        if (settingsElevenApiKeyEl) {
          settingsElevenApiKeyEl.placeholder = data.has_elevenlabs_key ? 'Saved (hidden)' : 'Paste key';
          settingsElevenApiKeyEl.value = data.has_elevenlabs_key ? SETTINGS_SAVED_MASK : '';
        }
        if (!data.has_api_key) {
          statusEl.textContent = 'Hackathon tip: open Settings and paste your Gemini API key.';
          try {
            const seen = localStorage.getItem('seenApiKeyHint');
            if (!seen) {
              openSettingsTab('api');
              localStorage.setItem('seenApiKeyHint', '1');
            }
          } catch {}
        }
      }

      async function saveSettings() {
        const apiKeyValue = settingsApiKeyEl ? settingsApiKeyEl.value.trim() : '';
        const elevenKeyValue = settingsElevenApiKeyEl ? settingsElevenApiKeyEl.value.trim() : '';
        const apiKey = apiKeyValue && apiKeyValue !== SETTINGS_SAVED_MASK ? apiKeyValue : null;
        const elevenKey = elevenKeyValue && elevenKeyValue !== SETTINGS_SAVED_MASK ? elevenKeyValue : null;
        const resp = await fetch('/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            api_key: apiKey,
            text_model: settingsTextModelEl.value || null,
            image_model: settingsImageModelEl.value || null,
            manim_py: settingsManimPyEl.value || null,
            output_copy_dir: settingsOutputCopyDirEl ? (settingsOutputCopyDirEl.value || null) : null,
            elevenlabs_api_key: elevenKey,
            elevenlabs_voice_id: settingsElevenVoiceIdEl ? (settingsElevenVoiceIdEl.value || null) : null,
            elevenlabs_model_id: settingsElevenModelIdEl ? (settingsElevenModelIdEl.value || null) : null
          })
        });
        const data = await resp.json();
        if (data.ok) {
          statusEl.textContent = 'Settings saved.';
          if (settingsApiKeyEl && data.has_api_key) {
            settingsApiKeyEl.placeholder = 'Saved (hidden)';
            settingsApiKeyEl.value = SETTINGS_SAVED_MASK;
          }
          if (settingsElevenApiKeyEl && data.has_elevenlabs_key) {
            settingsElevenApiKeyEl.placeholder = 'Saved (hidden)';
            settingsElevenApiKeyEl.value = SETTINGS_SAVED_MASK;
          }
          if (data.text_model) chatModelEl.value = data.text_model;
          showToast('Settings saved.', 'ok');
          pushHistory('Saved settings');
        }
      }

      async function runHealth() {
        healthEl.textContent = 'Checking...';
        let data = null;
        try {
          const resp = await fetch('/api/health');
          data = await resp.json();
        } catch (e) {
          healthEl.textContent = 'Failed to reach backend. Is the server running?';
          return null;
        }
        const manimStatus = data.manim_ok ? 'OK' : 'Missing';
        const ffmpegStatus = data.ffmpeg_ok ? 'OK' : 'Missing';
        const py = data.manim_py || 'python3';
        if (badgeManimEl) {
          badgeManimEl.textContent = `Manim: ${manimStatus}`;
          badgeManimEl.classList.toggle('ok', !!data.manim_ok);
          badgeManimEl.classList.toggle('bad', !data.manim_ok);
        }
        if (badgeFfmpegEl) {
          badgeFfmpegEl.textContent = `ffmpeg: ${ffmpegStatus}`;
          badgeFfmpegEl.classList.toggle('ok', !!data.ffmpeg_ok);
          badgeFfmpegEl.classList.toggle('bad', !data.ffmpeg_ok);
        }
        const cands = (data.python_candidates || []).join(', ');
        const ffmpegPath = data.ffmpeg_path || '';
        const voiceReady = !!data.elevenlabs_ready;
        const voiceId = data.elevenlabs_voice_id || '';
        const voiceModel = data.elevenlabs_model_id || '';
        const lines = [
          `Manim: ${manimStatus}`,
          `ffmpeg: ${ffmpegStatus}`,
          `ElevenLabs narrator: ${voiceReady ? 'Ready' : 'Not configured'}`,
          `python: ${py}`,
        ];
        if (data.manim_version) lines.push(data.manim_version);
        if (cands) lines.push(`python candidates: ${cands}`);
        if (ffmpegPath) lines.push(`ffmpeg path: ${ffmpegPath}`);
        if (voiceId) lines.push(`voice id: ${voiceId}`);
        if (voiceModel) lines.push(`voice model: ${voiceModel}`);
        if (!voiceReady) {
          lines.push('');
          lines.push('Narrator setup: Settings -> API & Models -> Voiceover (ElevenLabs).');
          lines.push('- Set ElevenLabs API key');
          lines.push('- Set Voice ID');
          lines.push('- Optional model id (default: eleven_multilingual_v2)');
        }
        if (!data.manim_ok) {
          lines.push('');
          lines.push('Fix: choose a Python that has Manim installed (or leave blank to auto-detect).');
          lines.push('macOS quickstart (from repo root):');
          lines.push('- source .venv/bin/activate');
          lines.push('- python -m pip install manim');
        }
        if (!data.ffmpeg_ok) {
          lines.push('');
          lines.push('Fix (macOS): brew install ffmpeg');
        }
        healthEl.textContent = lines.join('\n');
        lastHealthData = data;
        return data;
      }

      function showInstallPrompt(missingList) {
        if (!installPromptEl || !installMissingListEl) return;
        if (!missingList.length) {
          installPromptEl.classList.add('hidden');
          return;
        }
        installMissingListEl.textContent = missingList.join(', ');
        installPromptEl.classList.remove('hidden');
      }

      async function installMissingDeps() {
        const data = lastHealthData || await runHealth();
        if (!data) return;
        const missing = [];
        if (!data.manim_ok) missing.push('manim');
        if (!data.ffmpeg_ok) missing.push('ffmpeg');
        if (!missing.length) {
          showInstallPrompt([]);
          showToast('All dependencies already installed.', 'ok');
          return;
        }
        setTerminalMode(true);
        showToast('Installing missing dependencies…', 'ok');
        const py = (settingsManimPyEl.value || data.manim_py || 'python3').trim() || 'python3';
        if (missing.includes('manim')) {
          await execTerminalCommand(`${py} -m pip install -U pip`, { append: true });
          await execTerminalCommand(`${py} -m pip install manim`, { append: true });
        }
        if (missing.includes('ffmpeg')) {
          const brewCheck = await execTerminalCommand('command -v brew', { append: true, silent: true });
          if (brewCheck && !brewCheck.startsWith('(exit')) {
            await execTerminalCommand('brew install ffmpeg', { append: true });
          } else {
            logsEl.textContent += '\nBrew not found. Install ffmpeg manually or use: apt-get install ffmpeg\n';
          }
        }
        lastHealthData = await runHealth();
        showInstallPrompt([]);
      }

      async function loadMemories() {
        const resp = await fetch('/api/memories');
        const data = await resp.json();
        memoryListEl.innerHTML = '';
        (data.memories || []).forEach(mem => {
          const row = document.createElement('div');
          row.className = 'tree-file';
          row.innerHTML = `<label><input type="checkbox" data-id="${mem.id}" /> ${mem.title}</label>`;
          memoryListEl.appendChild(row);
        });
      }

      async function addMemory() {
        await fetch('/api/memories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: memoryTitleEl.value, content: memoryContentEl.value })
        });
        memoryTitleEl.value = '';
        memoryContentEl.value = '';
        loadMemories();
      }

      function selectedMemoryIds() {
        return Array.from(memoryListEl.querySelectorAll('input[type="checkbox"]')).filter(cb => cb.checked).map(cb => cb.dataset.id);
      }

      function normalizeMentionName(value) {
        return String(value || '').toLowerCase().replace(/[^a-z0-9]/g, '');
      }

      function cleanInline(value) {
        return String(value || '')
          .replace(/\\n/g, ' ')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      }

      function compactLabel(value, maxLen = 28) {
        return cleanInline(value).slice(0, maxLen);
      }

      function makeHandle(value, fallback = 'item') {
        const clean = cleanInline(value)
          .replace(/[:|]/g, ' ')
          .replace(/[^A-Za-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .replace(/_+/g, '_');
        const out = clean.slice(0, 16);
        return out || fallback;
      }

      function pickTitle(name, content, fallback) {
        const fromName = compactLabel(name, 52);
        if (fromName) return fromName;
        const firstLine = String(content || '').split(/\r?\n/g)[0];
        const fromContent = compactLabel(firstLine, 52);
        if (fromContent) return fromContent;
        return fallback;
      }

      function parseSubagentLines() {
        const raw = (subagentsTextEl?.value || '').split('\n');
        const items = [];
        raw.forEach((line) => {
          const txt = String(line || '').trim();
          if (!txt) return;
          const idx = txt.indexOf(':');
          const n = items.length + 1;
          if (idx > 0) {
            const name = compactLabel(txt.slice(0, idx).trim(), 42);
            const content = compactLabel(txt.slice(idx + 1).trim(), 180);
            items.push({
              name,
              content,
              nick: makeHandle(name || content, `agent_${n}`),
            });
          } else {
            const name = compactLabel(txt, 42);
            items.push({ name, content: '', nick: makeHandle(name, `agent_${n}`) });
          }
        });
        return items;
      }

      function renderMentionBar() {
        if (!mentionBarEl) return;
        mentionBarEl.innerHTML = '';
        const chips = [];
        const maxMentionsVisible = 10;

        function insertMentionToken(token) {
          const cur = chatInputEl.value || '';
          const sep = cur && !/\s$/.test(cur) ? ' ' : '';
          chatInputEl.value = `${cur}${sep}${token} `;
          chatInputEl.focus();
        }

        (skillsCache || []).forEach((s) => {
          const nick = s._nick || makeHandle(s.name, 'skill');
          const token = `@${nick}`;
          chips.push({ token, label: nick, tip: 'Skill', kind: 'skill' });
        });
        parseSubagentLines().forEach((a) => {
          const nick = a.nick || makeHandle(a.name, 'agent');
          const token = `@${nick}`;
          chips.push({ token, label: nick, tip: 'Subagent', kind: 'agent' });
        });

        if (!chips.length) {
          mentionBarEl.classList.add('hidden');
          if (mentionInfoEl) {
            mentionInfoEl.dataset.summary = 'No references yet';
            mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
          }
          updateMentionVisibility();
          return;
        }
        mentionBarEl.classList.remove('hidden');
        const visible = chips.slice(0, maxMentionsVisible);
        visible.forEach((c) => {
          const btn = document.createElement('button');
          btn.className = `mention-chip ${c.kind === 'agent' ? 'agent' : ''}`;
          btn.title = `${c.tip} reference: click to insert ${c.token}`;
          btn.innerHTML = `<span class="mention-icon">${c.kind === 'agent' ? 'A' : 'S'}</span><span class="mention-text">@${c.label}</span>`;
          btn.addEventListener('click', () => insertMentionToken(c.token));
          mentionBarEl.appendChild(btn);
        });
        if (chips.length > visible.length) {
          const more = chips.length - visible.length;
          if (mentionInfoEl) {
            mentionInfoEl.dataset.summary = `${visible.length}/${chips.length} refs shown (+${more} hidden)`;
            mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
          }
        } else if (mentionInfoEl) {
          mentionInfoEl.dataset.summary = `${chips.length} refs`;
          mentionInfoEl.textContent = mentionInfoEl.dataset.summary;
        }
        updateMentionVisibility();
      }

      function renderSubagentCards() {
        if (!subagentCardsEl) return;
        subagentCardsEl.innerHTML = '';
        const items = parseSubagentLines();
        items.forEach((item) => {
          const card = document.createElement('div');
          card.className = 'saved-card';
          const nick = item.nick || makeHandle(item.name, 'agent');
          card.innerHTML = `<div class="saved-card-title">A • ${compactLabel(item.name, 42)}</div><div class="saved-card-body">@${nick} ${item.content || 'No details yet.'}</div>`;
          card.title = `Insert @${nick} into prompt`;
          card.style.cursor = 'pointer';
          card.addEventListener('click', () => {
            const cur = chatInputEl.value || '';
            const sep = cur && !/\s$/.test(cur) ? ' ' : '';
            chatInputEl.value = `${cur}${sep}@${nick} `;
            chatInputEl.focus();
          });
          subagentCardsEl.appendChild(card);
        });
        renderMentionBar();
      }

      async function loadSkills() {
        const resp = await fetch('/api/skills');
        const data = await resp.json();
        const skills = data.skills || [];
        const seeded = await seedDefaultSkills(skills);
        if (!skills.length || seeded) {
          const resp2 = await fetch('/api/skills');
          const data2 = await resp2.json();
          return renderSkills(data2.skills || []);
        }
        renderSkills(skills);
      }

      function renderSkills(skills) {
        skillsCache = (skills || []).map((skill, idx) => {
          const rawName = String(skill.name || '').replace(/\\n/g, '\n');
          const firstNameLine = cleanInline(rawName.split('\n')[0] || '');
          const rawContent = cleanInline(String(skill.content || '').replace(/\\n/g, ' ').replace(/\n/g, ' '));
          let display = firstNameLine || pickTitle('', rawContent, `Skill ${idx + 1}`);
          if (display.startsWith('@')) {
            const token = display.split(/\s+/g)[0].replace(/^@+/, '');
            if (token) display = token;
          }
          display = display.replace(/^@+/, '').replace(/_+/g, '_').replace(/[^\w -]/g, ' ').replace(/\s+/g, ' ').trim();
          if (display.includes(':')) display = compactLabel(display.split(':')[0], 42);
          if (display.split(' ').length > 4) display = display.split(' ').slice(0, 4).join(' ');
          display = compactLabel(display, 32);
          if (!display) display = `Skill ${idx + 1}`;
          const nick = makeHandle(display, `skill_${idx + 1}`);
          return {
            ...skill,
            name: display,
            content: rawContent,
            _display: display,
            _nick: nick,
          };
        });
        skillListEl.innerHTML = '';
        if (savedSkillCardsEl) savedSkillCardsEl.innerHTML = '';
        (skillsCache || []).forEach(skill => {
          const displayName = skill._display || 'Skill';
          const row = document.createElement('div');
          row.className = 'tree-file';
          row.innerHTML = `<label><input type="checkbox" data-id="${skill.id}" data-name="${displayName}" /> ${displayName}</label>`;
          skillListEl.appendChild(row);

          if (savedSkillCardsEl) {
            const card = document.createElement('div');
            card.className = 'saved-card';
            const nick = skill._nick || makeHandle(displayName, 'skill');
            card.innerHTML = `<div class="saved-card-title">S • ${displayName}</div><div class="saved-card-body">@${nick} ${(skill.content || '').replace(/\\n/g, ' ').slice(0, 140)}</div>`;
            card.title = `Insert @${nick} into prompt`;
            card.style.cursor = 'pointer';
            card.addEventListener('click', () => {
              const cur = chatInputEl.value || '';
              const sep = cur && !/\s$/.test(cur) ? ' ' : '';
              chatInputEl.value = `${cur}${sep}@${nick} `;
              chatInputEl.focus();
            });
            savedSkillCardsEl.appendChild(card);
          }
        });
        renderMentionBar();
      }

      async function seedDefaultSkills(existingSkills = []) {
        const existingNormalized = new Set(
          (existingSkills || []).map((s) => normalizeMentionName(s?.name || s?.id || '')).filter(Boolean)
        );
        const defaults = [
          {
            name: 'Photoelectric Director',
            content: 'For photoelectric scenes: compare low-frequency high-intensity vs high-frequency low-intensity. Always label threshold f0, work function phi, and K_max.'
          },
          {
            name: 'EM Wave Animator',
            content: 'Animate wavelength/frequency with clean sinusoid or packets. Keep arrows short, centered, and color-code red vs blue with legend.'
          },
          {
            name: 'Equation Builder',
            content: 'Introduce equations term-by-term: K_max = h f - phi and e V_s = K_max. Highlight one term at a time with matching narration.'
          },
          {
            name: 'Graph Interpreter',
            content: 'When plotting K_max vs frequency, show x-intercept at f0, slope h, and no emission below threshold. Keep axes labels large and centered.'
          },
          {
            name: 'Lab Apparatus Designer',
            content: 'Build clear experimental setup visuals: metal plate, incident light arrow, emitted e- dots, collector, and stopping potential battery icon.'
          },
          {
            name: 'Optics Visualizer',
            content: 'Use clean rays, lenses, and wavefronts to explain optics. Keep beams short, labels large, and show refraction or diffraction clearly.'
          },
          {
            name: 'Quantum Story Beat',
            content: 'Use sequence: hook -> failed classical expectation -> Einstein photon model -> equation -> graph -> recap takeaway.'
          },
          {
            name: 'Clarity QA',
            content: 'Check overlap, safe margins for 9:16 and 16:9, and one concept per scene. Reject tiny labels or overlapping equations.'
          },
          {
            name: 'Narration Sync',
            content: 'Keep narration aligned to visible action. No narration-only spans longer than 2 seconds; each line should map to one visual change.'
          }
        ];
        let createdAny = false;
        for (const item of defaults) {
          const key = normalizeMentionName(item.name);
          if (existingNormalized.has(key)) continue;
          try {
            await fetch('/api/skills', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(item)
            });
            existingNormalized.add(key);
            createdAny = true;
          } catch {}
        }
        return createdAny;
      }

      function ensurePhysicsSubagentsForDemo() {
        const existing = (subagentsTextEl?.value || '')
          .split('\n')
          .map((x) => String(x || '').trim())
          .filter(Boolean);
        const existingMap = new Set(existing.map((line) => normalizeMentionName(line.split(':')[0] || line)));
        const physicsDefaults = [
          'PhotonCoach: drives photon-vs-wave framing and keeps threshold intuition clear.',
          'LabDesigner: builds emitter plate, collector, stopping-potential layout with clean labels.',
          'EquationTutor: introduces K_max = h f - phi and eV_s = K_max one symbol at a time.',
          'GraphAnalyst: ensures K_max vs f graph shows f0 intercept and slope meaning.',
          'VisualPacer: enforces one concept at a time and smooth transitions for short-form video.',
          'SafetyQA: validates spacing, overlap, and readability for 9:16 and 16:9 exports.'
        ];
        const merged = [...existing];
        physicsDefaults.forEach((line) => {
          const name = normalizeMentionName(line.split(':')[0] || line);
          if (!existingMap.has(name)) {
            merged.push(line);
            existingMap.add(name);
          }
        });
        if (subagentsTextEl) subagentsTextEl.value = merged.join('\n');
      }

      async function saveSkill() {
        await fetch('/api/skills', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: skillNameEl.value, content: skillContentEl.value })
        });
        skillNameEl.value = '';
        skillContentEl.value = '';
        loadSkills();
      }

      async function generateSkill() {
        await fetch('/api/skills/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ idea: skillIdeaEl.value, name: skillGenerateNameEl.value })
        });
        skillIdeaEl.value = '';
        skillGenerateNameEl.value = '';
        loadSkills();
      }

      function selectedSkillIds() {
        return Array.from(skillListEl.querySelectorAll('input[type="checkbox"]')).filter(cb => cb.checked).map(cb => cb.dataset.id);
      }

      function selectedSkillIdsWithMentions(promptText) {
        const out = new Set(selectedSkillIds());
        const tags = Array.from(String(promptText || '').matchAll(/@([A-Za-z0-9_-]+)/g))
          .map((m) => normalizeMentionName(m[1]));
        if (!tags.length) return Array.from(out);
        (skillsCache || []).forEach((s) => {
          const byName = normalizeMentionName(s._nick || makeHandle(s.name, 'skill'));
          if (tags.includes(byName) && s.id) out.add(s.id);
        });
        return Array.from(out);
      }

      function sceneIndexFromClientX(clientX) {
        if (!timelineTrackEl || !timelineState.length) return -1;
        const rect = timelineTrackEl.getBoundingClientRect();
        const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
        const total = timelineState.reduce((s, sc) => s + Math.max(1, Number(sc.seconds || 1)), 0) || 1;
        let cursor = 0;
        const target = pct * total;
        for (let i = 0; i < timelineState.length; i++) {
          const dur = Math.max(1, Number(timelineState[i]?.seconds || 1));
          if (target <= cursor + dur) return i;
          cursor += dur;
        }
        return timelineState.length - 1;
      }

      async function applyDropToSceneIndex(idx, dataTransfer) {
        const sc = timelineState[idx];
        if (!sc) return false;
        const dt = dataTransfer;
        const assetType = dt.getData('text/asset-type');
        const assetPath = dt.getData('text/asset-path');
        if (assetType && assetPath) {
          sc.assets = sc.assets || {};
          sc.assets[assetType] = assetPath;
          renderTimeline();
          showToast(`Attached ${assetType.toUpperCase()} to scene ${idx + 1}.`, 'ok');
          return true;
        }

        const droppedFiles = Array.from(dt.files || []);
        if (droppedFiles.length) {
          const img = droppedFiles.find((f) => (f.type || '').startsWith('image/'));
          if (!img) {
            showToast('Drop an image file to attach to a scene.', 'err');
            return true;
          }
          const role = imageModeEl.value === 'foreground' ? 'foreground' : 'background';
          let rel = null;
          try {
            rel = await uploadImageToCurrentJob(img, role);
          } catch {
            rel = null;
          }
          if (!rel) return true;
          sc.assets = sc.assets || {};
          sc.assets[role] = rel;
          if (role === 'background') {
            setThumb(bgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'background', relPath: rel });
          } else {
            setThumb(fgThumbEl, { url: `/work/jobs/${currentJobId}/${rel}?t=${Date.now()}`, type: 'foreground', relPath: rel });
          }
          renderTimeline();
          showToast(`Attached ${img.name} to scene ${idx + 1}.`, 'ok');
          return true;
        }

        const sourceTimeline = (dt.getData('text/source-timeline') || '').trim();
        const sourceSnippet = (dt.getData('text/source-snippet') || '').trim();
        const raw = sourceTimeline || sourceSnippet || (dt.getData('text/plain') || '').trim();
        const kind = dt.getData('text/path-kind');
        if (!raw) return false;
        let snippet = '';
        if (kind === 'folder') {
          snippet = `[Folder ref: ${raw}]`;
        } else if (kind === 'file') {
          try {
            const resp = await fetch(`/api/files/file?path=${encodeURIComponent(raw)}`);
            const data = await resp.json();
            snippet = data.ok ? `[File ref: ${raw}]\n${String(data.content || '').slice(0, 600)}` : `[File ref: ${raw}]`;
          } catch {
            snippet = `[File ref: ${raw}]`;
          }
        } else {
          snippet = raw.slice(0, 600);
        }
        sc.narration = [sc.narration || '', snippet].filter(Boolean).join('\n');
        renderTimeline();
        showToast(`Added note to scene ${idx + 1}.`, 'ok');
        return true;
      }

      function renderTimelineRuler(totalSeconds, scenes) {
        if (!timelineRulerEl) return;
        timelineRulerEl.innerHTML = '';
        const total = Math.max(1, Math.floor(Number(totalSeconds || 1)));

        let minor = 1;
        let major = 5;
        if (total > 30 && total <= 120) { minor = 5; major = 10; }
        else if (total > 120 && total <= 300) { minor = 10; major = 30; }
        else if (total > 300) { minor = 30; major = 60; }

        function addTick(t, isMajor) {
          const pct = (t / total) * 100;
          const tick = document.createElement('div');
          tick.className = 'tick' + (isMajor ? ' major' : '');
          tick.style.left = `${pct}%`;
          timelineRulerEl.appendChild(tick);
          if (isMajor) {
            const label = document.createElement('div');
            label.className = 'tick-label';
            label.style.left = `${pct}%`;
            label.textContent = `${t}s`;
            timelineRulerEl.appendChild(label);
          }
        }

        for (let t = 0; t <= total; t += minor) {
          addTick(t, t % major === 0);
        }
        if (total % minor !== 0) addTick(total, true);
        const rows = Array.isArray(scenes) ? scenes : [];
        let cursor = 0;
        rows.forEach((sc, idx) => {
          const dur = Math.max(1, Number(sc?.seconds || 1));
          const mid = cursor + Math.max(0.5, dur / 2);
          const pct = (mid / total) * 100;
          const marker = document.createElement('div');
          marker.className = 'timeline-marker';
          marker.style.left = `${pct}%`;
          marker.title = `Scene ${idx + 1}: ${String(sc?.goal || 'Scene').slice(0, 120)}`;
          const dot = document.createElement('div');
          dot.className = 'timeline-marker-dot';
          const label = document.createElement('div');
          label.className = 'timeline-marker-label';
          label.textContent = `S${idx + 1}`;
          marker.appendChild(dot);
          marker.appendChild(label);
          timelineRulerEl.appendChild(marker);
          cursor += dur;
        });
      }

      function renderTimeline() {
        timelineTrackEl.innerHTML = '';
        if (!timelineState.length) {
          timelineLabelEl.textContent = 'Timeline';
          if (timelineRulerEl) timelineRulerEl.innerHTML = '';
          refreshAppliedAssetInfo();
          return;
        }
        const total = timelineState.reduce((s, sc) => s + sc.seconds, 0);
        timelineLabelEl.textContent = `Total ${total}s • ${timelineState.length} scenes`;
        renderTimelineRuler(total, timelineState);

        let cursor = 0;
        timelineState.forEach((scene, idx) => {
          const start = cursor;
          const end = start + Number(scene.seconds || 0);
          cursor = end;
          const block = document.createElement('div');
          block.className = 'timeline-block';
          block.draggable = true;
          block.dataset.index = idx;
          block.style.flex = `0 0 ${Math.max(120, Number(scene.seconds || 1) * 14)}px`;
          block.title = [
            `Scene ${idx + 1} • ${start}s–${end}s`,
            (scene.goal || 'Scene'),
            (scene.narration || '').trim() ? `Narration: ${(scene.narration || '').trim()}` : '',
            scene.assets?.background ? `BG: ${scene.assets.background}` : '',
            scene.assets?.foreground ? `FG: ${scene.assets.foreground}` : '',
          ].filter(Boolean).join('\n');

          const header = document.createElement('div');
          header.className = 'timeline-block-header';
          header.textContent = `Scene ${idx + 1} • ${start}s–${end}s`;

          const editRow = document.createElement('div');
          editRow.className = 'timeline-edit-row';
          const goalInput = document.createElement('input');
          goalInput.className = 'timeline-edit-input';
          goalInput.value = scene.goal || '';
          goalInput.placeholder = 'Scene goal';
          goalInput.title = 'Inline edit: scene goal';
          goalInput.addEventListener('mousedown', (e) => e.stopPropagation());
          goalInput.addEventListener('keydown', (e) => e.stopPropagation());
          goalInput.addEventListener('input', () => {
            timelineState[idx].goal = goalInput.value;
            scheduleAutosave();
          });

          const durInput = document.createElement('input');
          durInput.className = 'timeline-dur-input';
          durInput.type = 'number';
          durInput.min = '1';
          durInput.step = '1';
          durInput.value = String(Math.max(1, Number(scene.seconds || 1)));
          durInput.title = 'Scene duration in seconds';
          durInput.addEventListener('mousedown', (e) => e.stopPropagation());
          durInput.addEventListener('keydown', (e) => e.stopPropagation());
          durInput.addEventListener('change', () => {
            const next = Math.max(1, Math.round(Number(durInput.value || scene.seconds || 1)));
            timelineState[idx].seconds = next;
            renderTimeline();
          });
          editRow.appendChild(goalInput);
          editRow.appendChild(durInput);

          const badges = document.createElement('div');
          badges.className = 'timeline-badges';
          const durBadge = document.createElement('div');
          durBadge.className = 'timeline-badge';
          durBadge.textContent = `${scene.seconds}s`;
          badges.appendChild(durBadge);
          if (scene.assets?.background) {
            const bg = document.createElement('div');
            bg.className = 'timeline-badge';
            bg.textContent = 'BG';
            badges.appendChild(bg);
          }
          if (scene.assets?.foreground) {
            const fg = document.createElement('div');
            fg.className = 'timeline-badge';
            fg.textContent = 'FG';
            badges.appendChild(fg);
          }

          const noteInput = document.createElement('textarea');
          noteInput.className = 'timeline-edit-note';
          noteInput.placeholder = 'Inline scene note (drag source/file/snippet here)';
          noteInput.value = scene.narration || '';
          noteInput.addEventListener('mousedown', (e) => e.stopPropagation());
          noteInput.addEventListener('keydown', (e) => e.stopPropagation());
          noteInput.addEventListener('input', () => {
            timelineState[idx].narration = noteInput.value;
            scheduleAutosave();
          });

          const handle = document.createElement('div');
          handle.className = 'timeline-handle';
          handle.title = 'Drag to change duration';
          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const startX = e.clientX;
            const startSec = Number(timelineState[idx].seconds || 1);
            const trackW = timelineTrackEl.getBoundingClientRect().width || 1;
            const totalSec = timelineState.reduce((s, sc) => s + Number(sc.seconds || 0), 0) || 1;
            const pxPerSec = trackW / totalSec;

            function onMove(ev) {
              const dx = ev.clientX - startX;
              const delta = dx / Math.max(8, pxPerSec);
              const next = Math.max(1, Math.round(startSec + delta));
              timelineState[idx].seconds = next;
              block.style.flex = `0 0 ${Math.max(120, next * 14)}px`;
              durBadge.textContent = `${next}s`;
            }
            function onUp() {
              window.removeEventListener('mousemove', onMove);
              window.removeEventListener('mouseup', onUp);
              renderTimeline();
            }
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
          });

          block.appendChild(header);
          block.appendChild(editRow);
          block.appendChild(badges);
          block.appendChild(noteInput);
          block.appendChild(handle);

          block.addEventListener('dragstart', (e) => {
            block.classList.add('dragging');
            e.dataTransfer.setData('text/timeline-index', idx.toString());
            e.dataTransfer.setData('text/plain', idx.toString());
          });
          block.addEventListener('dragend', () => {
            block.classList.remove('dragging');
          });
          block.addEventListener('dragover', (e) => {
            e.preventDefault();
          });
          const handleSceneDrop = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const to = Number(block.dataset.index);
            const timelineFrom = Number(e.dataTransfer.getData('text/timeline-index'));
            if (Number.isFinite(timelineFrom) && !Number.isNaN(timelineFrom)) {
              if (timelineFrom === to) return;
              const moved = timelineState.splice(timelineFrom, 1)[0];
              timelineState.splice(to, 0, moved);
              renderTimeline();
              return;
            }
            await applyDropToSceneIndex(to, e.dataTransfer);
          };
          block.addEventListener('drop', handleSceneDrop);

          // Make drops reliable even when targeting nested controls inside a scene card.
          [header, editRow, goalInput, durInput, badges, noteInput].forEach((target) => {
            target.addEventListener('dragover', (e) => {
              e.preventDefault();
            });
            target.addEventListener('drop', handleSceneDrop);
          });

          timelineTrackEl.appendChild(block);
        });
        highlightTimelineAt(videoEl.currentTime || 0);
        if (lastPlanBox) syncPlanFromTimeline();
        refreshAppliedAssetInfo();
        scheduleAutosave();
      }

      if (timelineTrackEl) {
        let trackSeeking = false;
        function seekFromTrack(clientX) {
          if (!videoEl.duration) return;
          const rect = timelineTrackEl.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
          videoEl.currentTime = pct * videoEl.duration;
          timelineScrubEl.value = Math.floor(pct * 100);
          updateTransportUI();
        }
        timelineTrackEl.addEventListener('mousedown', (e) => {
          trackSeeking = true;
          seekFromTrack(e.clientX);
        });
        window.addEventListener('mousemove', (e) => {
          if (!trackSeeking) return;
          seekFromTrack(e.clientX);
        });
        window.addEventListener('mouseup', () => { trackSeeking = false; });

        timelineTrackEl.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        timelineTrackEl.addEventListener('drop', async (e) => {
          e.preventDefault();
          if (!timelineState.length) return;
          const idx = sceneIndexFromClientX(e.clientX);
          if (idx < 0) return;
          const timelineFrom = Number(e.dataTransfer.getData('text/timeline-index'));
          if (Number.isFinite(timelineFrom) && !Number.isNaN(timelineFrom)) {
            if (timelineFrom === idx) return;
            const moved = timelineState.splice(timelineFrom, 1)[0];
            timelineState.splice(idx, 0, moved);
            renderTimeline();
            return;
          }
          await applyDropToSceneIndex(idx, e.dataTransfer);
        });
      }

      function activeSceneIndexAt(second) {
        const t = Number(second || 0);
        let cursor = 0;
        for (let i = 0; i < timelineState.length; i++) {
          const dur = Math.max(1, Number(timelineState[i]?.seconds || 1));
          if (t >= cursor && t < cursor + dur) return i;
          cursor += dur;
        }
        return -1;
      }

      function highlightTimelineAt(second) {
        const activeIdx = activeSceneIndexAt(second);
        const blocks = Array.from(timelineTrackEl.querySelectorAll('.timeline-block'));
        blocks.forEach((b, idx) => {
          b.classList.toggle('active', idx === activeIdx);
        });
      }

      function syncPlanFromTimeline() {
        if (!lastPlanBox || !timelineState.length) return;
        const total = timelineState.reduce((s, sc) => s + sc.seconds, 0);
        const plan = {
          title: timelineMeta.title || 'Scene Plan',
          total_seconds: total,
          scenes: timelineState.map((sc) => ({
            seconds: sc.seconds,
            goal: sc.goal || 'Updated scene',
            elements: sc.elements || [],
            actions: sc.actions || [],
            narration: sc.narration || '',
            assets: sc.assets || {}
          }))
        };
        lastPlanBox.value = JSON.stringify(plan, null, 2);
        currentPlanText = lastPlanBox.value;
      }

      function buildDirectorBrief() {
        const pieces = [];
        if (directorBriefEl.value.trim()) pieces.push(directorBriefEl.value.trim());
        const rules = rulesTextEl.value.trim();
        if (rules) pieces.push(`Rules:\n${rules}`);
        const sub = subagentsTextEl.value.trim();
        if (sub) pieces.push(`Subagents:\n${sub}`);

        const sources = getSources();
        if (sources.length) {
          const block = sources.map((raw, i) => {
            const s = normalizeSourceRecord(raw);
            const lines = [];
            lines.push(`Source ${i + 1}: ${s.title || s.url || 'source'}`);
            if (s.kind === 'youtube' && s.video_id) lines.push(`Type: youtube (${s.video_id})`);
            else lines.push(`Type: ${s.kind || 'web'}`);
            if (s.url) lines.push(`URL: ${s.url}`);
            if (s.summary) lines.push(`Summary: ${s.summary}`);
            if (Array.isArray(s.key_points) && s.key_points.length) {
              lines.push('Key points:');
              s.key_points.slice(0, 8).forEach((p) => lines.push(`- ${p}`));
            }
            if (s.prompt_hint) lines.push(`Prompt hint: ${s.prompt_hint}`);
            if (s.file_path) lines.push(`Workspace summary file: ${s.file_path}`);
            if (!s.summary && s.notes) lines.push(`Notes: ${s.notes.slice(0, 800)}`);
            return lines.join('\n');
          }).join('\n\n');
          pieces.push(`References:\n${block}`);
        }
        return pieces.join('\n\n') || null;
      }

      async function runSlashCommand(text) {
        const raw = text.trim();
        if (!raw.startsWith('/')) return false;
        const parts = raw.split(/\s+/g);
        const cmd = parts[0].toLowerCase();
        if (cmd === '/health') {
          openSettingsTab('render');
          await runHealth();
          return true;
        }
        if (cmd === '/settings') {
          openSettingsTab('api');
          return true;
        }
        if (cmd === '/clear') {
          document.getElementById('backBtn').click();
          return true;
        }
        if (cmd === '/attach') {
          const path = parts.slice(1).join(' ');
          if (!path) {
            statusEl.textContent = 'Usage: /attach notes/outline.md';
            return true;
          }
          const resp = await fetch(`/api/files/file?path=${encodeURIComponent(path)}`);
          const data = await resp.json();
          if (!data.ok) {
            statusEl.textContent = data.error || 'Attach failed.';
            return true;
          }
          chatInputEl.value = `Attached file: ${data.path}\n\n${data.content}\n\n`;
          return true;
        }
        statusEl.textContent = `Unknown command: ${cmd}`;
        return true;
      }

      async function createPlan() {
        resetSteps();
        setStep('plan', 'active');
        setStepNote('plan', 'Sending prompt to Gemini for scene planning…');

        const idea = chatInputEl.value.trim();
        if (!idea) return;

        if (await runSlashCommand(idea)) return;

        addChat('user', 'You', idea);
        setBusy(true, 'Planning…', 'Planning');
        await new Promise(requestAnimationFrame);

        let data = null;
        try {
          const resp = await fetch('/api/plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              idea,
              audience: audienceEl.value,
              tone: toneEl.value,
              style: styleEl.value,
              pace: paceEl.value,
              color_palette: paletteEl.value,
              include_equations: equationsEl.value === 'true',
              include_graphs: graphsEl.value === 'true',
              include_narration: narrationEl.value === 'true',
              target_seconds: targetSecondsEl.value ? Number(targetSecondsEl.value) : null,
              max_scenes: maxScenesEl.value ? Number(maxScenesEl.value) : null,
              max_objects: maxObjectsEl.value ? Number(maxObjectsEl.value) : null,
              aspect_ratio: aspectEl.value,
              director_brief: buildDirectorBrief(),
              include_images: includeImagesEl.value === 'true',
              image_prompt: imagePromptEl.value || null,
              memory_ids: selectedMemoryIds(),
              skill_ids: selectedSkillIdsWithMentions(idea),
              model: chatModelEl.value || null
            })
          });
          data = await resp.json();
        } catch (e) {
          setBusy(false, 'Failed to reach backend.');
          showToast('Backend not reachable.', 'err');
          setStep('plan', 'error');
          setStepNote('plan', 'Backend unreachable. Start FastAPI server and retry.');
          return;
        } finally {
          setBusy(false);
        }
        if (!data.ok) {
          statusEl.textContent = data.error || 'Plan failed.';
          showToast(data.error || 'Plan failed.', 'err');
          setStep('plan', 'error');
          setStepNote('plan', data.error || 'Plan failed.');
          return;
        }
        currentJobId = data.job_id;
        persistedSceneSignature = '';
        didAnimateCode = false;
        currentPlanText = data.plan_text;
        jobIdEl.textContent = currentJobId;
        pushHistory(`Created plan ${currentJobId}`);
        if (appendFromJobId && appendFromJobId !== currentJobId) {
          statusEl.textContent = `Append mode active: base ${appendFromJobId} -> next ${currentJobId}`;
        }
        updateOutputPaths();
        updateJobFiles(data.job_files);
        if (genImagesBtn) genImagesBtn.disabled = false;
        updateBackEnabled();
        scheduleAutosave();

        const planBox = document.createElement('textarea');
        planBox.style.width = '100%';
        planBox.style.minHeight = '120px';
        planBox.style.maxHeight = '260px';
        planBox.value = data.plan_text;
        lastPlanBox = planBox;

        const approveBtn = document.createElement('button');
        approveBtn.textContent = 'Approve & Render';
        approveBtn.style.marginTop = '8px';

        const wrapper = document.createElement('div');
        if (data.plan) {
          wrapper.appendChild(buildPlanInspector(data.plan, planBox));
        }
        const jsonEditor = document.createElement('details');
        jsonEditor.className = 'drawer-section';
        const sum = document.createElement('summary');
        sum.style.cursor = 'pointer';
        sum.style.color = 'var(--muted)';
        sum.textContent = 'Editable plan JSON';
        jsonEditor.appendChild(sum);
        jsonEditor.appendChild(planBox);
        wrapper.appendChild(jsonEditor);
        wrapper.appendChild(approveBtn);

        addChat('agent', 'Scene Plan (edit if needed)', '', wrapper);
        setStep('plan', 'done');
        setStepNote('plan', `Plan ready: ${data.plan?.scenes?.length || 0} scenes.`);
        setStep('approve', 'active');
        setStepNote('approve', 'Review the plan JSON, then click Approve & Render.');

        approveBtn.addEventListener('click', async () => {
          approveBtn.disabled = true;
          approveBtn.textContent = 'Rendering…';
          if (timelineState.length) {
            syncPlanFromTimeline();
          }
          await approvePlan(lastPlanBox ? lastPlanBox.value : planBox.value);
          approveBtn.disabled = false;
          approveBtn.textContent = 'Approve & Render';
        });

        if (data.plan && data.plan.scenes) {
          timelineMeta.title = data.plan.title || 'Scene Plan';
          timelineState = data.plan.scenes.map(sc => ({
            seconds: sc.seconds || 3,
            goal: sc.goal,
            elements: sc.elements,
            actions: sc.actions,
            narration: sc.narration
          }));
          renderTimeline();
        }
      }

      async function approvePlan(planText) {
        if (!currentJobId) return { ok: false };
        setStep('approve', 'active');
        setStepNote('approve', 'Running preflight checks…');

        let preflight = null;
        try {
          const preResp = await fetch('/api/preflight');
          preflight = await preResp.json();
        } catch {
          preflight = null;
        }
        if (!preflight || !preflight.ok) {
          const missing = Array.isArray(preflight?.missing) ? preflight.missing : ['backend'];
          const msg = `Preflight failed: ${missing.join(', ')}.`;
          statusEl.textContent = msg;
          showToast(msg, 'err');
          setStep('approve', 'error');
          setStepNote('approve', msg);

          const wrap = document.createElement('div');
          wrap.className = 'drawer-section';
          const p = document.createElement('div');
          p.className = 'muted';
          p.textContent = `${msg} Use the fix button, then retry Approve & Render.`;
          const fixBtn = document.createElement('button');
          fixBtn.textContent = 'Fix now';
          fixBtn.style.marginTop = '8px';
          fixBtn.addEventListener('click', async () => {
            const action = preflight?.fix_action || '';
            if (action === 'open_settings_api') openSettingsTab('api');
            else openSettingsTab('render');
            if (action === 'open_settings_render_get_started' && getStartedBtn) {
              try { getStartedBtn.click(); } catch {}
            }
          });
          wrap.appendChild(p);
          wrap.appendChild(fixBtn);
          addChat('agent', 'Preflight check', msg, wrap);
          return { ok: false, error: msg };
        }

        setStep('approve', 'done');
        setStep('code', 'active');
        setStepNote('code', 'Preflight passed. Starting code generation…');
        if (timelineState.length && lastPlanBox) {
          syncPlanFromTimeline();
          planText = lastPlanBox.value;
        }
        const runJobId = currentJobId;
        didAnimateCode = false;
        let lastPushedCode = '';
        let shownCodeToast = false;
        let finished = false;
        let resolved = false;
        return await new Promise(async (resolveRun) => {
          const finish = (payload) => {
            if (resolved) return;
            resolved = true;
            resolveRun(payload || {});
          };

          function pushCode(code, opts) {
            const text = String(code || '');
            if (!text.trim()) return;
            if (text === lastPushedCode) return;
            lastPushedCode = text;
            didAnimateCode = true;
            setActiveTab('code');
            animateCodeIntoEditor(text, opts);
            persistGeneratedSceneFile(text, true);
            statusEl.textContent = `Coding… saved to notes/generated/${runJobId}/scene.py`;
            setStepNote('code', `Code generated and saved: notes/generated/${runJobId}/scene.py`);
            if (!shownCodeToast) {
              shownCodeToast = true;
              showToast('Code generated.', 'ok');
            }
          }

          async function maybeAppendVideo() {
            if (!appendFromJobId || appendFromJobId === runJobId) return null;
            const baseId = appendFromJobId;
            try {
              const resp = await fetch('/api/jobs/append', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  base_job_id: baseId,
                  next_job_id: runJobId,
                }),
              });
              const data = await resp.json();
              if (!data.ok) {
                showToast(data.error || 'Append failed.', 'err');
                return null;
              }
              appendFromJobId = runJobId;
              return { ...data, appended_from: baseId };
            } catch {
              showToast('Append failed.', 'err');
              return null;
            }
          }

          async function applyFinalState(st, errText) {
            if (!st || !st.ok) {
              showToast(st?.error || 'Failed to load job results.', 'err');
              setStep('render', 'error');
              setStepNote('render', st?.error || 'Failed to load final state.');
              finish(st || { ok: false });
              return;
            }
            if (st.status === 'failed') {
              const hasCode = !!(st.code && String(st.code).trim());
              if (hasCode && st.code) pushCode(st.code, { immediate: true });
              if (hasCode) setStep('code', 'done');
              else setStep('code', 'error');
              setStep('render', 'error');
              const tail = (st.logs_tail || errText || 'Render failed.');
              setStepNote('render', 'Render failed. Check logs and retry.');
              if (/no module named manim/i.test(tail) || /manim/i.test(tail) && /not found|no such file|missing/i.test(tail)) {
                openSettingsTab('render');
                try { await runHealth(); } catch {}
              }
              const retryBtn = document.createElement('button');
              retryBtn.textContent = 'Retry Render';
              retryBtn.className = 'secondary';
              retryBtn.addEventListener('click', () => approvePlan(lastPlanBox ? lastPlanBox.value : planText));
              const wrap = document.createElement('div');
              wrap.appendChild(retryBtn);
              addChat('agent', 'Render failed', `<pre style="white-space:pre-wrap; margin:0;">${(st.logs_tail || errText || 'Render failed.').slice(0, 6000)}</pre><div class="muted" style="margin-top:6px;">Tip: Settings → Health to verify Manim/ffmpeg.</div>`, wrap);
              showToast('Render failed.', 'err');
              finish(st);
              return;
            }

            let finalState = st;
            const appendResult = await maybeAppendVideo();
            if (appendResult?.ok) {
              if (appendResult.video_path) finalState.video_path = appendResult.video_path;
              if (appendResult.plan) finalState.plan = appendResult.plan;
              if (appendResult.job_files) finalState.job_files = appendResult.job_files;
              setStepNote('render', `Rendered and stitched with previous segment (${appendResult.appended_from || ''}).`);
              showToast('Segment appended to previous video.', 'ok');
            }

            setStep('code', 'done');
            setStep('render', 'done');
            setStepNote('render', 'Render complete. MP4 is ready.');
            if (finalState.video_path) {
              const src = '/' + finalState.video_path + '?t=' + Date.now();
              lastVideoUrl = src;
              videoEl.src = src;
              videoEl.load();
              setVideoAvailable(true);
              pushHistory(`Rendered ${runJobId}`);
              addRenderToDeck({
                job_id: runJobId,
                video_path: finalState.video_path,
                appended_from: appendResult?.appended_from || '',
              });
            }
            lastCaptionsUrl = '';
            if (finalState.captions_path) {
              lastCaptionsUrl = '/' + finalState.captions_path + '?t=' + Date.now();
              setVideoAvailable(true);
            }
            if (finalState.code) {
              pushCode(finalState.code, { immediate: true });
              updateEditorMode();
            }
            if (finalState.plan && finalState.plan.scenes) {
              timelineMeta.title = finalState.plan.title || 'Scene Plan';
              timelineState = finalState.plan.scenes.map(sc => ({
                seconds: sc.seconds || 3,
                goal: sc.goal,
                elements: sc.elements,
                actions: sc.actions,
                narration: sc.narration,
                assets: sc.assets || {}
              }));
              renderTimeline();
            }
            if (finalState.job_files) updateJobFiles(finalState.job_files);
            if (finalState.logs_tail) logsEl.textContent = finalState.logs_tail;
            const noticeKey = `${runJobId}`;
            if (!renderNoticeByJob.has(noticeKey)) {
              renderNoticeByJob.add(noticeKey);
              if (finalState.video_path) {
                statusEl.textContent = `Render complete. Output: ${finalState.video_path}`;
              } else {
                statusEl.textContent = 'Render complete.';
              }
              showToast('Render complete.', 'ok');
            }
            updateBackEnabled();
            finish(finalState);
          }

          activeEditorTabId = 'generated';
          upsertGeneratedTab('# Generating Manim scene...\n');
          applyActiveEditorTab();

          setBusy(true, 'Generating video…', 'Rendering');
          setStep('approve', 'done');
          setStep('code', 'active');
          setStep('render', 'active');
          setStepNote('approve', 'Approved. Generating code…');
          setStepNote('code', 'Gemini is writing Manim code…');
          setStepNote('render', 'Renderer is queued…');
          setActiveTab('code');
          await new Promise(requestAnimationFrame);

          try {
            const resp = await fetch('/api/approve', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                job_id: runJobId,
                plan_text: planText,
                include_images: includeImagesEl.value === 'true',
                image_prompt: imagePromptEl.value || null,
                image_mode: imageModeEl.value,
                image_model: imageModelOverrideEl.value || null,
                quality: qualityEl.value,
                aspect_ratio: aspectEl.value,
                model: chatModelEl.value || null
              })
            });
            const data = await resp.json();
            if (!data.ok) {
              setBusy(false, 'Render failed.');
              showToast(data.error || 'Render failed.', 'err');
              setStep('code', 'error');
              setStep('render', 'error');
              setStepNote('render', data.error || 'Render failed.');
              logsEl.textContent = data.error || 'Render failed.';
              finish(data);
              return;
            }
            if (data.status === 'already_running') {
              setStepNote('render', 'Render already in progress. Streaming live state…');
            }
          } catch (e) {
            setBusy(false, 'Failed to reach backend.');
            showToast('Backend not reachable.', 'err');
            setStep('code', 'error');
            setStep('render', 'error');
            setStepNote('render', 'Backend unreachable.');
            finish({ ok: false, error: 'Backend not reachable.' });
            return;
          }

          // Stream logs + state live via SSE until the job completes.
          try { if (jobEventSource) jobEventSource.close(); } catch {}
          logsEl.textContent = '';
          let pollTimer = null;
          const stopPoll = () => {
            if (pollTimer) {
              clearInterval(pollTimer);
              pollTimer = null;
            }
          };
          const es = new EventSource(`/api/jobs/${encodeURIComponent(runJobId)}/events`);
          jobEventSource = es;
          pollTimer = setInterval(async () => {
            if (!runJobId || finished) return;
            try {
              const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
              const st = await stResp.json();
              if (!st.ok) return;
              if (st.code) pushCode(st.code);
              if (st.job_files) updateJobFiles(st.job_files);
              if (st.status === 'done' || st.status === 'failed') {
                finished = true;
                stopPoll();
                try { es.close(); } catch {}
                jobEventSource = null;
                setBusy(false);
                await applyFinalState(st, st.error || '');
              }
            } catch {}
          }, 450);
          es.onerror = () => {
            if (!finished) {
              statusEl.textContent = 'Live stream dropped, using polling fallback…';
              setStepNote('render', 'SSE dropped, polling fallback active.');
            }
          };
          es.addEventListener('log', (e) => {
            try {
              const data = JSON.parse(e.data);
              if (data.chunk) {
                logsEl.textContent += data.chunk;
                logsEl.scrollTop = logsEl.scrollHeight;
              }
            } catch {}
          });
          es.addEventListener('code', (e) => {
            try {
              const data = JSON.parse(e.data);
              if (data.code) pushCode(data.code);
            } catch {}
          });
          es.addEventListener('state', async (e) => {
            let s = null;
            try { s = JSON.parse(e.data); } catch { s = null; }
            const status = s?.status || '';
            const step = s?.step || '';
            const msg = s?.message || '';
            const err = s?.error || '';
            if (msg) statusEl.textContent = msg;
            if (busySubEl && msg) busySubEl.textContent = msg;

            if (step === 'code') {
              setStep('code', 'active');
              setStep('render', '');
              setStepNote('code', msg || 'Generating code…');
            }
            if (step === 'render') {
              setStep('code', 'done');
              setStep('render', 'active');
              setStepNote('render', msg || 'Rendering…');
              if (!didAnimateCode) {
                try {
                  const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
                  const st = await stResp.json();
                  if (st.ok && st.code) pushCode(st.code);
                  if (st.ok && st.job_files) updateJobFiles(st.job_files);
                } catch {}
              }
            }
            if (status === 'repairing') {
              setStep('render', 'active');
              setStepNote('render', msg || 'Repairing code and retrying render…');
            }

            if (status === 'done' || status === 'failed') {
              if (finished) return;
              finished = true;
              stopPoll();
              try { es.close(); } catch {}
              jobEventSource = null;
              setBusy(false);
              let st = null;
              try {
                const stResp = await fetch(`/api/jobs/${encodeURIComponent(runJobId)}`);
                st = await stResp.json();
              } catch {
                showToast('Failed to load final job state.', 'err');
                setStep('render', 'error');
                setStepNote('render', 'Failed to load final state.');
                finish({ ok: false, error: 'Failed to load final state.' });
                return;
              }
              await applyFinalState(st, err);
            }
          });
        });
      }

      renderCodeBtn.addEventListener('click', async () => {
        if (!codeEl.value.trim()) return;
        if (openFilePath && !openFilePath.endsWith('.py')) {
          statusEl.textContent = 'Render disabled: you are editing a non-Python workspace file.';
          return;
        }
        const resp = await fetch('/api/render-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: codeEl.value, quality: qualityEl.value })
        });
        const data = await resp.json();
        if (!data.ok) {
          statusEl.textContent = data.error || 'Render failed.';
          showToast(data.error || 'Render failed.', 'err');
          logsEl.textContent = data.logs || data.error || 'Render failed.';
          return;
        }
        const src = '/' + data.video_path + '?t=' + Date.now();
        lastVideoUrl = src;
        videoEl.src = src;
        videoEl.load();
        setVideoAvailable(true);
        addRenderToDeck({
          job_id: currentJobId || 'manual',
          video_path: data.video_path,
          appended_from: '',
        });
        updateEditorMode();
        updateJobFiles(data.job_files);
        logsEl.textContent = data.logs || 'Render complete.';
        showToast('Render complete.', 'ok');
        pushHistory(`Rendered ${currentJobId || 'code'}`);
      });

      downloadVideoBtn.addEventListener('click', () => {
        if (!videoEl.src) return;
        const a = document.createElement('a');
        a.href = videoEl.src;
        a.download = currentJobId ? `${currentJobId}.mp4` : 'out.mp4';
        document.body.appendChild(a);
        a.click();
        a.remove();
        showToast('Downloading video…', 'ok');
      });

      async function execTerminalCommand(cmd, { append = false, silent = false } = {}) {
        const command = (cmd || '').trim();
        if (!command) return '';
        termRunEl.disabled = true;
        termCmdEl.value = command;
        const prefix = `${append ? '\n' : ''}> ${command}\n`;
        logsEl.textContent = (append ? (logsEl.textContent || '') : '') + prefix;
        try {
          const resp = await fetch('/api/terminal/run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command })
          });
          const data = await resp.json();
          const output = data.ok ? (data.output || '') : (data.error || 'Command failed');
          if (!silent) logsEl.textContent += (output || '') + '\n';
          if (data.ok) pushHistory(`Terminal: ${command}`);
          return output || '';
        } catch (e) {
          logsEl.textContent += 'Failed to reach backend.\n';
          return '';
        } finally {
          termRunEl.disabled = false;
        }
      }

      async function runTerminalCommand() {
        const cmd = (termCmdEl.value || '').trim();
        if (!cmd) return;
        await execTerminalCommand(cmd, { append: false });
      }
      safeOn(termRunEl, 'click', runTerminalCommand);
      safeOn(termCmdEl, 'keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          runTerminalCommand();
        }
      });

      safeOn(timelineScrubEl, 'input', () => {
        if (!videoEl.duration) return;
        const pct = Number(timelineScrubEl.value) / 100;
        videoEl.currentTime = pct * videoEl.duration;
        updateTransportUI();
      });
      safeOn(videoEl, 'timeupdate', () => {
        if (!videoEl.duration) return;
        timelineScrubEl.value = Math.floor((videoEl.currentTime / videoEl.duration) * 100);
        updateTransportUI();
      });
      if (timelineRulerEl) {
        let rulerSeeking = false;
        function seekFromRulerClientX(clientX) {
          if (!videoEl.duration) return;
          const rect = timelineRulerEl.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (clientX - rect.left) / Math.max(1, rect.width)));
          videoEl.currentTime = pct * videoEl.duration;
          timelineScrubEl.value = Math.floor(pct * 100);
          updateTransportUI();
        }
        timelineRulerEl.addEventListener('mousedown', (e) => {
          rulerSeeking = true;
          seekFromRulerClientX(e.clientX);
        });
        window.addEventListener('mousemove', (e) => {
          if (!rulerSeeking) return;
          seekFromRulerClientX(e.clientX);
        });
        window.addEventListener('mouseup', () => {
          rulerSeeking = false;
        });
      }

      safeOn(planBtn, 'click', createPlan);
      safeOn(saveSettingsBtn, 'click', saveSettings);
      safeOn(getStartedBtn, 'click', async () => {
        openSettingsTab('render');
        lastHealthData = await runHealth();
        if (!lastHealthData) return;
        const missing = [];
        if (!lastHealthData.manim_ok) missing.push('manim');
        if (!lastHealthData.ffmpeg_ok) missing.push('ffmpeg');
        if (!missing.length) {
          showInstallPrompt([]);
          showToast('All dependencies are ready.', 'ok');
          return;
        }
        showInstallPrompt(missing);
        showToast('Missing dependencies detected.', 'err');
      });
      safeOn(installDepsBtn, 'click', installMissingDeps);
      safeOn(cancelInstallBtn, 'click', () => showInstallPrompt([]));
      safeOn(copyOutputNowBtn, 'click', async () => {
        if (!currentJobId) {
          showToast('Render a video first.', 'err');
          return;
        }
        try {
          const resp = await fetch(`/api/jobs/${encodeURIComponent(currentJobId)}/copy-output`, { method: 'POST' });
          const data = await resp.json();
          if (!data.ok) {
            showToast(data.error || 'Copy failed.', 'err');
            return;
          }
          showToast(`Copied to ${data.copied_path}`, 'ok');
          pushHistory(`Copied output for ${currentJobId}`);
        } catch {
          showToast('Copy request failed.', 'err');
        }
      });
      safeOn(runHealthBtn, 'click', runHealth);
      safeOn(resetLayoutBtn, 'click', resetLayout);
      safeOn(addMemoryBtn, 'click', addMemory);
      safeOn(saveSkillBtn, 'click', saveSkill);
      safeOn(generateSkillBtn, 'click', generateSkill);
      safeOn(subagentsTextEl, 'input', () => {
        renderSubagentCards();
        scheduleAutosave();
      });
      safeOn(aspectEl, 'change', () => setPreviewAspect(aspectEl.value));
      safeOn(durationPresetEl, 'change', () => {
        const val = Number(durationPresetEl.value || 0);
        if (!Number.isFinite(val) || val <= 0) return;
        targetSecondsEl.value = String(val);
        scheduleAutosave();
      });
      safeOn(applyRenameBtn, 'click', renamePending);
      safeOn(genImagesBtn, 'click', generateImages);
      safeOn(applyBgAllBtn, 'click', () => applyAssetToAllScenes('background'));
      safeOn(clearBgAllBtn, 'click', () => clearAssetFromAllScenes('background'));
      safeOn(applyFgAllBtn, 'click', () => applyAssetToAllScenes('foreground'));
      safeOn(clearFgAllBtn, 'click', () => clearAssetFromAllScenes('foreground'));
      safeOn(createFolderBtn, 'click', createFolder);
      safeOn(createFileBtn, 'click', createFile);
      safeOn(newCodeTabBtn, 'click', createNewCodeTabFile);
      safeOn(newPathEl, 'keydown', (e) => {
        if (e.key === 'Enter' && pendingRenameFrom) {
          e.preventDefault();
          renamePending();
        }
      });

      safeOn(saveFileBtn, 'click', saveWorkspaceFile);
      safeOn(undoCodeBtn, 'click', () => {
        codeEl.focus();
        try { document.execCommand('undo'); } catch {}
      });
      safeOn(redoCodeBtn, 'click', () => {
        codeEl.focus();
        try { document.execCommand('redo'); } catch {}
      });
      window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
          if (openFilePath) {
            e.preventDefault();
            saveWorkspaceFile();
          }
        }
      });

      safeOn(indexSourceBtn, 'click', async () => {
        const url = sourceUrlEl.value.trim();
        const notes = sourceNotesEl.value.trim();
        const sourceType = (sourceTypeEl?.value || 'auto').trim();
        if (!url) {
          sourceStatusEl.textContent = 'Enter a source URL first.';
          showToast('Enter a source URL first.', 'err');
          return;
        }
        sourceStatusEl.textContent = 'Indexing source with Gemini...';
        indexSourceBtn.disabled = true;
        try {
          const resp = await fetch('/api/docs/index', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url,
              notes,
              source_type: sourceType,
              model: chatModelEl?.value || null,
            }),
          });
          const data = await resp.json();
          if (!data.ok || !data.indexed) {
            sourceStatusEl.textContent = data.error || 'Indexing failed.';
            showToast(data.error || 'Indexing failed.', 'err');
            return;
          }
          const indexed = normalizeSourceRecord({
            ...data.indexed,
            notes,
            source_type: sourceType,
            saved_at: new Date().toISOString(),
          });
          const savedPath = await persistSourceSummaryFile(data.indexed);
          if (savedPath) indexed.file_path = savedPath;
          upsertSource(indexed);
          renderSources();
          if (savedPath) {
            sourceStatusEl.textContent = `Indexed ${indexed.kind} source. Summary saved: ${savedPath}`;
          } else {
            sourceStatusEl.textContent = `Indexed ${indexed.kind} source.`;
          }
          if (data.warning) {
            showToast(data.warning, 'err');
          } else {
            showToast('Source indexed.', 'ok');
          }
          sourceUrlEl.value = '';
          sourceNotesEl.value = '';
          scheduleAutosave();
        } catch {
          sourceStatusEl.textContent = 'Failed to reach backend. Is the server running?';
          showToast('Failed to reach backend.', 'err');
        } finally {
          indexSourceBtn.disabled = false;
        }
      });

      safeOn(saveSourceBtn, 'click', () => {
        const url = sourceUrlEl.value.trim();
        const notes = sourceNotesEl.value.trim();
        if (!url && !notes) {
          sourceStatusEl.textContent = 'Enter a URL or notes before saving.';
          return;
        }
        const manual = normalizeSourceRecord({
          id: `src-manual-${Date.now()}`,
          url,
          notes,
          source_type: sourceTypeEl?.value || 'auto',
          kind: sourceTypeEl?.value === 'youtube' ? 'youtube' : 'web',
          title: url ? `Manual source: ${compactLabel(url, 48)}` : 'Manual notes source',
          summary: cleanInline(notes).slice(0, 320),
          key_points: [],
          prompt_hint: '',
          saved_at: new Date().toISOString(),
        });
        upsertSource(manual);
        renderSources();
        sourceUrlEl.value = '';
        sourceNotesEl.value = '';
        sourceStatusEl.textContent = 'Saved source without indexing.';
        showToast('Saved source.', 'ok');
        scheduleAutosave();
      });

      safeOn(openInstallGuideBtn, 'click', () => {
        openSettingsTab('render');
        if (!healthEl) return;
        healthEl.textContent = [
          'Install Guide (macOS)',
          '1) cd /Users/hema/Desktop/Gemini-Hack-Manim',
          '2) python3 -m venv .venv',
          '3) source .venv/bin/activate',
          '4) python -m pip install -U pip',
          '5) python -m pip install -r requirements.txt',
          '6) python -m pip install manim',
          '7) brew install ffmpeg',
          '8) python -m manim --version',
          '9) python -m uvicorn backend.main:app --reload --port 8000',
          '',
          'Install Guide (Linux)',
          'A) sudo apt-get update',
          'B) sudo apt-get install -y ffmpeg libcairo2-dev pango1.0-tools',
          'C) run steps 1, 3, 4, 5, 6, 8, 9 above',
        ].join('\n');
      });

      function seedDemoDefaults() {
        // Keep this lightweight: only fill if the user hasn't typed anything.
        if (!chatInputEl.value.trim()) {
          chatInputEl.value = 'Explain the photoelectric effect in 60 seconds (red vs blue light, threshold frequency, Einstein equation).';
        }
        if (!imagePromptEl.value.trim()) {
          imagePromptEl.value = 'Scientist walking in a park at sunrise';
        }
        if (!includeImagesEl.value) includeImagesEl.value = 'true';
        if (!imageModeEl.value) imageModeEl.value = 'background';

        if (!aspectEl.value) aspectEl.value = '9:16';
        if (!audienceEl.value) audienceEl.value = 'high school';
        if (!toneEl.value) toneEl.value = 'epic';
        if (!styleEl.value) styleEl.value = 'cinematic';
        if (!paceEl.value) paceEl.value = 'medium';
        if (!paletteEl.value) paletteEl.value = 'cool';
        if (!qualityEl.value) qualityEl.value = 'pqm';
        if (!targetSecondsEl.value.trim()) targetSecondsEl.value = '60';
        if (!maxScenesEl.value.trim()) maxScenesEl.value = '6';

        if (!rulesTextEl.value.trim()) {
          rulesTextEl.value = [
            'Show 1 concept at a time.',
            'Keep all text centered with safe padding for 9:16.',
            'Always label variables when introduced; avoid clutter.',
            'Use simple arrows/axes; avoid tiny text.',
          ].join('\\n');
        }
        if (!subagentsTextEl.value.trim()) {
          subagentsTextEl.value = [
            'PhotonCoach: drives photon-vs-wave framing and keeps threshold intuition clear.',
            'LabDesigner: builds emitter plate, collector, stopping-potential layout with clean labels.',
            'EquationTutor: introduces K_max = h f - phi and eV_s = K_max one symbol at a time.',
            'GraphAnalyst: ensures K_max vs f graph shows f0 intercept and slope meaning.',
            'VisualPacer: enforces one concept at a time and smooth transitions for short-form video.',
            'SafetyQA: validates spacing, overlap, and readability for 9:16 and 16:9 exports.',
          ].join('\\n');
        }

        try {
          const sources = getSources();
          if (!sources.length) {
            setSources([{
              url: 'https://example.com/photoelectric-effect',
              notes: 'Key points to include:\\n- Intensity changes number of emitted electrons (when above threshold).\\n- Frequency must exceed threshold: f > f0 (work function).\\n- Einstein: K_max = h f - ϕ.\\n- Stopping potential: e V_s = K_max.',
              saved_at: new Date().toISOString()
            }]);
            renderSources();
          }
        } catch {}

        if (termCmdEl && !termCmdEl.value.trim()) termCmdEl.value = 'help';
        setPreviewAspect(aspectEl.value);
        renderSubagentCards();
        renderMentionBar();
      }

      // Boot
      // Keep the button clickable; if there's no job_id yet we'll show a hint toast.
      loadTemplates();
      loadSettings();
      loadMemories();
      loadSkills();
      loadWorkspaceFiles();
      renderSources();
      setPreviewAspect(aspectEl.value);
      updateEditorMode();
      applyLayoutColumns();
      const didRestore = restoreProject();
      if (!didRestore) seedDemoDefaults();
      ensurePhysicsSubagentsForDemo();
      renderSubagentCards();
      renderMentionBar();
      ensureGeneratedTab();
      renderEditorTabs();
      renderHistory();
      renderDeckUI();
      setTerminalMode(false);
      setContextTab('memory');
      setVideoAvailable(false);
      updateOutputPaths();
      updateTopbarToggles();
      updateStepProgress();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  </body>
</html>
